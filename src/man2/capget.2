.\" written by Andrew Morgan <morgan@kernel.org>
.\" may be distributed as per GPL
.\" Modified by David A. Wheeler <dwheeler@ida.org>
.\" Modified 2004-05-27, mtk
.\" Modified 2004-06-21, aeb
.\" Modified 2008-04-28, morgan of kernel.org
.\"     Update in line with addition of file capabilities and
.\"     64-bit capability sets in kernel 2.6.2[45].
.\" Modified 2009-01-26, andi kleen
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CAPGET 2 2010\-09\-20 Linux "Руководство программиста Linux"
.SH ИМЯ
capget, capset \- установка/получение мандатов нити(ей)
.SH ОБЗОР
\fB#include <sys/capability.h>\fP
.sp
\fBint capget(cap_user_header_t \fP\fIhdrp\fP\fB, cap_user_data_t \fP\fIdatap\fP\fB);\fP
.sp
\fBint capset(cap_user_header_t \fP\fIhdrp\fP\fB, const cap_user_data_t
\fP\fIdatap\fP\fB);\fP
.SH ОПИСАНИЕ
Начиная с Linux 2.2, полномочия суперпользователя (root) были разделены на
несколько отдельных мандатов. У каждой нити есть набор действующих мандатов,
определяющих какие возможности (если есть) она может в данный момент
использовать. Каждая нить также имеет набор унаследованных мандатов, который
мог быть передан через вызов \fBexecve\fP(2), и набор разрешённых мандатов,
которые она может сделать эффективными или передать потомкам.
.PP
Данные функции представляют собой низкоуровневый интерфейс ядра для
получения и установки мандатов нити. Кроме того, что эти системные вызовы
есть только в Linux, из\-за них, вероятно, изменится программный интерфейс
ядра; с каждой новой версией ядра эти функции используются всё чаще (в
частности, типы \fIcap_user_*_t\fP), но старые программы работают как и прежде.
.sp
Переносимыми интерфейсами являются \fBcap_set_proc\fP(3) и \fBcap_get_proc\fP(3);
если возможно, в приложениях используйте именно их. Если требуется
использовать расширения Linux, используйте простые в использовании
\fBcapsetp\fP(3) и \fBcapgetp\fP(3).
.SS "Подробная информация"
На данный момент в ядре определены следующие структуры:
.sp
.nf
.in +4n
#define _LINUX_CAPABILITY_VERSION_1  0x19980330
#define _LINUX_CAPABILITY_U32S_1     1

#define _LINUX_CAPABILITY_VERSION_2  0x20071026
#define _LINUX_CAPABILITY_U32S_2     2

typedef struct __user_cap_header_struct {
   __u32 version;
   int pid;
} *cap_user_header_t;

typedef struct __user_cap_data_struct {
   __u32 effective;
   __u32 permitted;
   __u32 inheritable;
} *cap_user_data_t;
.fi
.in -4n
.sp
\fIeffective, permitted, inheritable\fP \(em это битовые маски мандатов,
определённых в \fIcapability(7).\fP Заметим, что значения \fICAP_*\fP являются
индексами битов и требуется сдвиг битов перед выполнением операции ИЛИ над
битовыми полями. Чтобы определить структуры для передачи в системный вызов,
используйте имена \fIstruct __user_cap_header_struct\fP и \fIstruct
__user_cap_data_struct\fP, так как typedef описаны только указатели.

Ядра до версии 2.6.25 предъявляют 32\-битные мандаты с версией
\fB_LINUX_CAPABILITY_VERSION_1\fP, а ядра 2.6.25+ предъявляют 64\-битные мандаты
с версией \fB_LINUX_CAPABILITY_VERSION_2\fP. Заметим, что в 64\-битных мандатах
используются \fIdatap\fP[0] и \fIdatap\fP[1], в то время как в 32\-битных только
\fIdatap\fP[0].
.sp
Другое изменение, влияющее на поведение этих системных вызовов, поддержка
ядром файловых мандатов (поддержка мандата VFS). Данная поддержка включается
параметром компиляции (добавлен в ядро версии 2.6.24).
.sp
С помощью вызова \fBcapget\fP() можно выполнить проверку мандатов любого
процесса, указав его ID в поле \fIhdrp\->pid\fP.
.SS "Ядро с поддержкой мандатов VFS"
При поддержке мандатов VFS существует файл\-атрибутный метод для добавления
мандатов привилегированных исполняемым файлам. Данная модель привилегий
делает устаревшей ядерную поддержку асинхронного назначения мандатов
процессов. То есть с поддержкой VFS в вызове \fBcapset\fP() разрешено только
значение \fIhdrp\->pid\fP равное 0 или \fBgetpid\fP(2), что приводит к одному
результату.
.SS "Ядро без поддержки мандатов VFS"
Когда ядро не поддерживает мандаты VFS, вызовом \fBcapset\fP() можно управлять
мандатами нити, указав значение не равное нулю в поле \fIpid\fP из \fIhdrp\fP, или
мандатами вызывающей нити, указав в \fIpid\fP значение 0. Если \fIpid\fP указывает
на процесс с одной нитью, то значением \fIpid\fP может быть ID обычного
процесса; управление нитью в многонитиевом процессе требует ID нити такого
же типа, что и возвращается \fBgettid\fP(2). У \fBcapset\fP() \fIpid\fP также может
быть: \-1 \(em выполнить изменение у всех нитей, за исключением вызывающей и
\fBinit\fP(8); меньше \-1 \(em выполнить изменение всех членов группы процесса,
чей ID равен \-\fIpid\fP.

Подробную информацию о данных смотрите в \fBcapabilities\fP(7).
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении возвращается 0. В случае ошибки возвращается \-1, а
\fIerrno\fP устанавливается в соответствующее значение.

Вызовы будут завершаться с ошибкой \fBEINVAL\fP и устанавливать поле \fIversion\fP
в \fIhdrp\fP в предпочитаемое ядром значение \fB_LINUX_CAPABILITY_VERSION_?\fP,
если указано неподдерживаемое значение \fIversion\fP. Таким способом можно
проверить какая версия мандатов является предпочтительной.
.SH ОШИБКИ
.TP 
\fBEFAULT\fP
Неправильный адрес памяти. Значение \fIhdrp\fP не должно быть равно
NULL. Значение \fIdatap\fP может быть NULL только, когда пользователь пытается
определить предпочтительную версию формата мандатов, поддерживаемую ядром.
.TP 
\fBEINVAL\fP
Один из аргументов неправилен.
.TP 
\fBEPERM\fP
Была сделана попытка добавить мандат к списку разрешённых, эффективных или
унаследованных мандатов, но это не разрешено согласно списку разрешённых.
.TP 
\fBEPERM\fP
Вызывающий процесс пытается использовать \fBcapset\fP() для изменения мандатов
не своей нити, но ему не хватает на это прав. Для ядер, поддерживающих
мандаты VFS, это всегда запрещено. Для ядер без поддержки VFS требуется
мандат \fBCAP_SETPCAP\fP. (Неправильная работа ядер до версии 2.6.11 приводила
к тому, что эта ошибка также возникала, если нить без данного мандата
пыталась изменить свои собственные мандаты, указывая в поле \fIpid\fP ненулевое
значение (т.е. значение, возвращаемое \fBgetpid\fP(2)), а не 0).
.TP 
\fBESRCH\fP
Такой нити нет.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данные системные вызовы есть только в Linux.
.SH ЗАМЕЧАНИЯ
Переносимый интерфейс для запроса и установки мандатов предоставляется
библиотекой \fIlibcap\fP, которая доступна по адресу:
.br
http://www.kernel.org/pub/linux/libs/security/linux\-privs
.SH "СМОТРИТЕ ТАКЖЕ"
\fBclone\fP(2), \fBgettid\fP(2), \fBcapabilities\fP(7)

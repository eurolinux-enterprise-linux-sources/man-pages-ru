.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1992 Drew Eckhardt <drew@cs.colorado.edu>, March 28, 1992
.\"		and Michael Kerrisk, 2001, 2002
.\" May be distributed under the GNU General Public License.
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 24 Jul 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified 21 Aug 1994 by Michael Chastain <mec@shell.portal.com>:
.\"   New man page (copied from 'fork.2').
.\" Modified 10 June 1995 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 25 April 1998 by Xavier Leroy <Xavier.Leroy@inria.fr>
.\" Modified 26 Jun 2001 by Michael Kerrisk
.\"     Mostly upgraded to 2.4.x
.\"     Added prototype for sys_clone() plus description
.\"	Added CLONE_THREAD with a brief description of thread groups
.\"	Added CLONE_PARENT and revised entire page remove ambiguity 
.\"		between "calling process" and "parent process"
.\"	Added CLONE_PTRACE and CLONE_VFORK
.\"	Added EPERM and EINVAL error codes
.\"	Renamed "__clone" to "clone" (which is the protype in <sched.h>)
.\"	various other minor tidy ups and clarifications.
.\" Modified 26 Jun 2001 by Michael Kerrisk <mtk16@ext.canterbiry.ac.nz>
.\"	Updated notes for 2.4.7+ behaviour of CLONE_THREAD
.\" Modified 15 Oct 2002 by Michael Kerrisk <mtk16@ext.canterbiry.ac.nz>
.\"	Added description for CLONE_NEWNS, which was added in 2.4.19
.\" Slightly rephrased, aeb.
.\" Modified 1 Feb 2003 - added CLONE_SIGHAND restriction, aeb.
.\"
.\"
.\" Дата последней коррекции перевода 11.07.2004
.\" Перевод с английского сделал Виктор Вислобоков <corochoone@perm.ru>
.\" http://www.linuxshare.ru/projects/trans/mans.html
.\"
.TH CLONE 2 2001-12-31 "Linux 2.4" "Руководство программиста Linux"
.SH ИМЯ
clone \- создать процесс-потомок
.SH ОБЗОР
.B #include <sched.h>
.sp
.BI "int clone(int (*" "fn" ")(void *), void *" "child_stack" ", int " "flags" ", void *" "arg" );
.sp
.BI "_syscall2(int, " "clone" ", int, " "flags" ", void *, " "child_stack" )

.SH ОПИСАНИЕ
.B clone 
создаёт новый процесс как и
.BR fork (2).
.B clone
является библиотечной функцией верхнего уровня над системным вызовом
.BR clone ,
который далее будет называться
.BR sys_clone .
Описание
.BR sys_clone
даётся далее в конце данной страницы руководства.

В отличие от
.BR fork (2),
вышеуказанные системные вызовы позволяют процессу-потомку разделять части
их контекста выполнения с вызывающим процессом: такие как область памяти,
таблицу файловых дескрипторов и таблицу обработчиков сигналов.
(Заметим, что на данной странице руководства, "вызывающий процесс"
обычно соответствует "родительскому процессу". Но см. ниже описание
.BR CLONE_PARENT ).

Вызов
.B clone
в основном используется для реализации тредов (нитей): несколько тредов
управления в какой-либо программе, которые запущены конкурентно в
разделяемом пространстве памяти.

Когда процесс-потомок создаётся с помощью
.BR clone , 
он запускает функциональное приложение
.IR fn ( arg ).  
(Это отличается от
.BR fork (2), 
где выполнение продолжается в потомке от точки вызова
.BR fork (2) ).
Аргумент
.I fn
является указателем на функцию, которая вызывается процессом-потомком
в начале своего выполнения.
Аргумент
.I arg
передаётся этой
.I fn
функции.

Когда происходит возврат из функционального приложения
.IR fn ( arg ),
процесс-потомок завершается. Целое значение, возвращаемое
.IR fn ,
является кодом выхода процесса-потомка. Процесс-потомок может также
быть завершён явным образом, с помощью вызова
.BR exit (2)
или после получения фатального сигнала.

Аргумент
.I child_stack
задаёт положение стека, используемого процессом-потомком.
Начиная с момента, когда процесс-потомок и вызывающий процесс могут
разделять память, процесс-потомок не может выполняться в том же стеке,
что и вызывающий процесс. Вызывающий процесс должен, таким образом,
установить пространство памяти для стека процесса-потомка и передать
указатель на это пространство в вызове
.BR clone .
Стеки растут вниз для всех процессоров, на которых работает Linux
(за исключением HP PA процессоров), так что
.I child_stack
обычно указывает на наиболее высокий адрес в пространстве памяти,
которое устанавливается для стека процесса-потомка.

Младший байт
.I flags
содержит номер сигнала, который посылается родителю, когда потомок
умирает. Если этот сигнала задаётся как нечто отличное от
.BR SIGCHLD ,
то родительский процесс должен задать опцию
.B __WALL 
или 
.B __WCLONE
при ожидании завершения работы потомка с помощью вызова
.BR wait (2).  
Если никакой сигнал не задан, то родительский процесс не извещается
сигналом, когда потомок завершается.

Аргумент
.I flags
состоит из одного или более данных ниже битовых флагов, которые
складываются по правилам битового сложения (OR). Флаги задают
порядок процессов и то, что разделяется между вызывающим процессом
и процессом-потомком:

.TP
.B CLONE_PARENT
(ветка Linux 2.4 и выше) Если установлен флаг
.BR CLONE_PARENT ,
то родитель нового потомка (как возращает вызов
.BR getppid (2))
будет таким же как и у вызывающего процесса.

Если флаг
.B CLONE_PARENT
не установлен, то (как и в
.BR fork (2))
родителем будет вызывающий процесс.

Заметим, что это тот родительский процесс, который возращается
вызовом
.BR getppid (2),
и которому приходит сигнал, когда потомок завершается, так что
если
.B CLONE_PARENT
установлен, то сигнал будет посылаться родителю вызывающего
процесса, а не самому вызывающему процессу.

.TP
.B CLONE_FS
Если флаг
.B CLONE_FS
установлен, вызывающий процесс и процесс-потомок разделяют одну
и ту же информацию о фаловой системе. Она включает корневой каталог
файловой системы, текущий рабочий каталог и значение umask. Любые
вызовы
.BR chroot (2),
.BR chdir (2),
или
.BR umask (2)
выполняемые вызывающим процессом или процессом-потомком также
дают взаимный эффект.

Если флаг
.B CLONE_FS
не установлен, процесс-потомок работает с копией информации по
файловой системе от вызывающего процесса, снятой на момент вызова
.BR clone .
Вызовы
.BR chroot (2),
.BR chdir (2),
.BR umask (2)
выполняемые позже одним из процессов не оказывают эффект на другой
процесс.

.TP
.B CLONE_FILES
Если флаг
.B CLONE_FILES
установлен, то вызывающий процесс и процесс-потомок разделяют одну и
ту же таблицу файловых дескрипторов. Файловые дескрипторы всегда указывают
на те же файлы в вызывающем процессе и процессе-потомке. Любые файловые
дескрипторы, создаваемые вызывающим процессом или процессом-потомком
также работают в другом процессе. Также, если один из процессов закрывает
файловый дескриптор или изменяет ассоциированные с ним флаги, то
это оказывает влияние и на другой процесс.

Если флаг
.B CLONE_FILES
не установлен, процесс-потомок наследует копии всех файловых дескрипторов,
открытых в вызывающем процессе на время вызова
.BR clone .
Операции над файловыми дескрипторами, выполняемые позже вызывающим процессом
или процессом-потомком, не оказывают эффекта на другой процесс.

.TP
.B CLONE_NEWNS
(Начиная с Linux 2.4.19)
Запускает потомок в новом пространстве имён.

Каждый процесс живёт в некотором пространстве имён.
.I Пространство имён
процесса \- это данные (список смонтированных файловых систем), описывающие
файловую иерархию, видимую этим процессом. После вызова
.BR fork (2)
или
.BR clone (2)
где не установлен флаг
.BR CLONE_NEWNS ,
потомок живёт в том же пространстве имён, что и родитель.
Системные вызовы
.BR mount (2)
и
.BR umount (2)
изменяют пространство имён вызывающего процесса и, с этого момента,
оказывают эффект на все процессы, которые живут в этом же пространстве
имён, но не оказывают эффект на процессы в других пространствах имён.

После вызова
.BR clone (2)
где флаг
.B CLONE_NEWNS
установлен, потомок запускается в новом пространстве имён,
инициализированном копией пространства имён родителя.

Только привелегированный процесс может устанавливать флаг
.BR CLONE_NEWNS .
.\" The required capability is CAP_SYS_ADMIN. -- MTK, 15 Oct 02
Не допускается совместное использование флагов
.B CLONE_NEWNS
и
.B CLONE_FS
в одном вызове
.BR clone .

.TP
.B CLONE_SIGHAND
Если флаг
.B CLONE_SIGHAND
установлен, вызывающий процесс и процесс-потомок разделяют одну и ту же
таблицу обработчиков сигналов. Если вызывающий процесс или процесс-потомок
вызывают
.BR sigaction (2)
для изменения поведения при получении сигнала, то это поведение изменяется
также и в другом процессе. Однако, вызывающий процесс и процесс-потомок
имеют различные маски сигналов и списки ожидающих обработки сигналов. Так,
один из них может блокировать или деблокировать некоторые сигналы, используя
.BR sigprocmask (2)
и это не будет оказывать эффект на другой процесс.

Если флаг
.B CLONE_SIGHAND
не установлен, процесс-потомок наследует копию обработчиков событий
вызывающего процесса, снятую на момент вызова
.B clone .
Вызовы
.BR sigaction (2)
выполняемые после одним из процессов, не оказывают эффект на другой процесс.

.TP
.B CLONE_PTRACE
Если флаг
.B CLONE_PTRACE
установлен и вызывающий процесс находится в режиме трассировки, то процесс-потомок
таже будет работать в режиме трассировки (см.
.BR ptrace (2)).

.TP
.B CLONE_VFORK
Если флаг
.B CLONE_VFORK
установлен, то выполнение вызывающего процесса приостанавливается
пока потомок не освободит свои ресурсы виртуальной памяти через вызов
.BR execve (2)
или
.BR _exit (2)
(как в 
.BR vfork (2)).

Если флаг
.B CLONE_VFORK
не установлен, то после вызова и вызывающий процесс и процесс-потомок
включаются в параллельную работу через системный планировщик и приложение
не может знать в каком порядке будет осуществляться их выполнение.

.TP
.B CLONE_VM
Если флаг
.B CLONE_VM
установлен, вызывающий процесс и процесс-потомок запускаются в том же
пространстве памяти. В частности, записи в память, выполненные вызывающим
процессом или процессом-потомком также видны из другого процесса.
Кроме того, любые отражения памяти (mapping) или их завершение (unmapping)
выполняемые через
.BR mmap (2)
или
.BR munmap (2)
потомком или вызывающим процессом, также оказывают эффект на другой процесс.

Если флаг
.B CLONE_VM
не установлен, процесс потомок запускается в отдельной копии пространства
памяти вызывающего процесса, снятой на момент вызова
.BR clone .
Записи в память или отражения выполняемые одним процессом не дают эффекта
в другом процессе как и в
.BR fork (2).

.TP
.B CLONE_PID
Если флаг
.B CLONE_PID
установлен, процесс-потомок создаётся с таким же идентификатором процесса (ID)
как и вызывающий процесс.

Если
.B CLONE_PID
не установлен, процесс-потомок получает уникальный идентификатор процесса,
отличающийся от идентификатора вызывающего процесса.

Данный флаг может быть установлен только процессом загрузки системы (с PID 0).

.TP 
.B CLONE_THREAD
(Начиная с Linux 2.4)  
Если флаг
.B CLONE_THREAD
установлен, потомок размещается в той же группе тредов, что и вызывающий
процесс.

Если флаг
.B CLONE_THREAD
не устанлвен, то потомок размещается в своей собственной (новой) группе
тредов, где ID группы такой же как и идентификатор процесса.

(Группы тредов являются особенностью, добавленной в Linux 2.4 для поддержки
класса тредов POSIX, списка тредов, разделяющих один и тот же PID. В Linux
2.4, вызов
.BR getpid (2)
возвращает идентификатор группы тредов, вызывающего процесса.)

.SS "sys_clone"
Системный вызов
.B sys_clone
соответствует более закрытому
.BR fork (2)
в том плане, что выполнение в потомке продолжается от места данного вызова.
Таким образом
.B sys_clone
требует только аргументы
.I flags
и 
.IR child_stack ,
которые имеют тот же смысл, что и для вызова
.BR clone .  
(Заметим, что порядок этих аргументов отличается от
.BR clone .)  

Другое отличие 
.B sys_clone
состоит в том, что аргумент
.I child_stack
может быть нулём, в этом случае семантика copy-on-write обеспечивает
получение потомком отдельных копий страниц стека, когда один из процессов
изменяет стек. В этом случае, для правильной работы, не должен быть задан
флаг
.BR CLONE_VM .

.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
В случае успеха, в вызывающий тред возращается PID процесса-потомка. В случае
ошибки, в контекст вызываюего процесса возвращается \-1, процесс потомок не
будет создан и значение
.I errno
устанавливается соответствующим образом.

.SH ОШИБКИ
.TP
.B EAGAIN
Уже запущено слишком много процессов.
.TP
.B ENOMEM
Не могу выделить требуемую память для структуры, описывающей процесс-потомок
или для копирования тех частей контекста вызывающего процесса, которые необходимо
скопировать.
.TP
.B EINVAL
Возвращается
.B clone 
когда для
.IR child_stack
было задано нулевое значение.
.TP
.B EINVAL
Оба флага
.B CLONE_FS
и
.B CLONE_NEWNS
были заданы в аргументе
.IR flags .
.TP
.B EINVAL
.B CLONE_THREAD
был задан, но
.B CLONE_SIGHAND
нет. (Начиная с Linux 2.5.35.)
.TP 
.B EPERM
.B CLONE_PID
был задан процессом с ненулевым значением PID.
.SH БАГИ

В версии ядра 2.1.97, флаг
.B CLONE_PID
не должен использоваться, так как другие части данного ядра и большинство
системного программного обеспечения рассчитывают, что идентификаторы
процессов являются уникальными.

Вызов
.B clone
отсутствует в libc версии 5.  libc 6 (известная как glibc 2) предоставляет
вызов
.B clone
как описывается на данной странице руководства.

.SH ЗАМЕЧАНИЯ
Для ядер версий 2.4.7-2.4.18 флаг CLONE_THREAD неявно подразумевает
флаг CLONE_PARENT.

.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Вызовы
.B clone
и
.B sys_clone
являются специфичными для Linux и не должны использоваться в программах,
которые задуманы как переносимые на другие платформы. Для программирования
приложений, использующих треды (несколько тредов управления в одной и
той же области памяти) лучше использовать библиотечную реализацию
POSIX 1003.1c thread API, такую как библиотека LinuxThreads (включённая
в glibc2).  См.
.BR pthread_create (3).

Данная страница руководства соответствует ядрам 2.0.x, 2.1.x, 2.2.x, 2.4.x,
а также glibc 2.0.x и 2.1.x.

.SH "СМОТРИ ТАКЖЕ"
.BR fork (2),
.BR wait (2),
.BR pthread_create (3)
.SH ПЕРЕВОД
Перевёл с английского Виктор Вислобоков <corochoone@perm.ru> 2004

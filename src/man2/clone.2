.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1992 Drew Eckhardt <drew@cs.colorado.edu>, March 28, 1992
.\" and Copyright (c) Michael Kerrisk, 2001, 2002, 2005
.\" May be distributed under the GNU General Public License.
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 24 Jul 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified 21 Aug 1994 by Michael Chastain <mec@shell.portal.com>:
.\"   New man page (copied from 'fork.2').
.\" Modified 10 June 1995 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 25 April 1998 by Xavier Leroy <Xavier.Leroy@inria.fr>
.\" Modified 26 Jun 2001 by Michael Kerrisk
.\"     Mostly upgraded to 2.4.x
.\"     Added prototype for sys_clone() plus description
.\"	Added CLONE_THREAD with a brief description of thread groups
.\"	Added CLONE_PARENT and revised entire page remove ambiguity
.\"		between "calling process" and "parent process"
.\"	Added CLONE_PTRACE and CLONE_VFORK
.\"	Added EPERM and EINVAL error codes
.\"	Renamed "__clone" to "clone" (which is the prototype in <sched.h>)
.\"	various other minor tidy ups and clarifications.
.\" Modified 26 Jun 2001 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Updated notes for 2.4.7+ behavior of CLONE_THREAD
.\" Modified 15 Oct 2002 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added description for CLONE_NEWNS, which was added in 2.4.19
.\" Slightly rephrased, aeb.
.\" Modified 1 Feb 2003 - added CLONE_SIGHAND restriction, aeb.
.\" Modified 1 Jan 2004 - various updates, aeb
.\" Modified 2004-09-10 - added CLONE_PARENT_SETTID etc. - aeb.
.\" 2005-04-12, mtk, noted the PID caching behavior of NPTL's getpid()
.\"	wrapper under BUGS.
.\" 2005-05-10, mtk, added CLONE_SYSVSEM, CLONE_UNTRACED, CLONE_STOPPED.
.\" 2005-05-17, mtk, Substantially enhanced discussion of CLONE_THREAD.
.\" 2008-11-18, mtk, order CLONE_* flags alphabetically
.\" 2008-11-18, mtk, document CLONE_NEWPID
.\" 2008-11-19, mtk, document CLONE_NEWUTS
.\" 2008-11-19, mtk, document CLONE_NEWIPC
.\" 2008-11-19, Jens Axboe, mtk, document CLONE_IO
.\"
.\" FIXME Document CLONE_NEWUSER, which is new in 2.6.23
.\"       (also supported for unshare()?)
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CLONE 2 2011\-09\-08 Linux "Руководство программиста Linux"
.SH ИМЯ
clone, __clone2 \- создать процесс\-потомок
.SH ОБЗОР
.nf
.\" Actually _BSD_SOURCE || _SVID_SOURCE
.\" FIXME See http://sources.redhat.com/bugzilla/show_bug.cgi?id=4749
\fB#define _GNU_SOURCE\fP             /* Смотрите feature_test_macros(7) */
\fB#include <sched.h>\fP

\fBint clone(int (*\fP\fIfn\fP\fB)(void *), void *\fP\fIchild_stack\fP\fB,\fP
\fB          int \fP\fIflags\fP\fB, void *\fP\fIarg\fP\fB, ... \fP
\fB          /* pid_t *\fP\fIptid\fP\fB, struct user_desc *\fP\fItls\fP\fB, pid_t *\fP\fIctid\fP\fB */ );\fP
.fi
.SH ОПИСАНИЕ
\fBclone\fP() создаёт новый процесс как и \fBfork\fP(2). На самом деле это
библиотечная функция, использующая системный вызов \fBclone\fP(), который далее
будет называться \fBsys_clone\fP. Описание \fBsys_clone\fP приводится в конце
данной справочной страницы.

В отличие от \fBfork\fP(2), вышеуказанные вызовы позволяют процессу\-потомку
использовать некоторые части контекста выполнения вызывающего процесса,
такие как: область памяти, таблица файловых дескрипторов и таблица
обработчиков сигналов. Заметим, что в данной справочной странице «вызывающий
процесс» обычно соответствует «родительскому процессу». Но см. ниже описание
\fBCLONE_PARENT\fP.

В основном, вызов \fBclone\fP() используется для реализации нитей: несколько
нитей управления в программе, выполняющиеся одновременно в общем
пространстве памяти.

Когда процесс\-потомок создаётся с помощью \fBclone\fP(), он запускает функцию
приложения \fIfn\fP(\fIarg\fP). Это отличается от \fBfork\fP(2), где выполнение
продолжается в потомке от точки вызова \fBfork\fP(2). Аргумент \fIfn\fP является
указателем на функцию, которая вызывается процессом\-потомком в начале своего
выполнения. Аргумент \fIarg\fP передаётся функции \fIfn\fP.

Когда происходит возврат из функции приложения \fIfn\fP(\fIarg\fP) процесс\-потомок
завершается. Целое значение, возвращаемое \fIfn\fP, является кодом выхода
процесса\-потомка. Процесс\-потомок может также быть завершён явным образом с
помощью вызова \fBexit\fP(2) или после получения завершающего сигнала.

Аргумент \fIchild_stack\fP задаёт положение стека, используемого
процессом\-потомком. Так как процесс\-потомок и вызывающий процесс могут
использовать общую память, процесс\-потомок не может выполняться в том же
стеке, что и вызывающий процесс. Поэтому вызывающий процесс должен
установить пространство памяти для стека процесса\-потомка и передать
указатель на это пространство в вызове \fBclone\fP(). Стеки растут вниз для
всех процессоров, на которых работает Linux (за исключением процессоров HP
PA), так что \fIchild_stack\fP, обычно, указывает на наибольший адрес в
пространстве памяти, которое устанавливается для стека процесса\-потомка.

Младший байт \fIflags\fP содержит номер \fIсигнала завершения\fP, который
посылается родителю, когда работа потомка завершается. Если этот сигнал
задаётся как нечто отличное от \fBSIGCHLD\fP, то родительский процесс должен
задать параметр \fB__WALL\fP или \fB__WCLONE\fP при ожидании завершения работы
потомка с помощью вызова \fBwait\fP(2). Если никакой сигнал не задан, то
родительский процесс не извещается сигналом, когда потомок завершается.

Аргумент \fIflags\fP состоит из одной или более данных ниже констант, которые
складываются по правилам битового сложения (OR). Флагами задаёт что будет
общим между вызывающим процессом и процессом\-потомком:
.TP 
\fBCLONE_CHILD_CLEARTID\fP (начиная с Linux 2.5.49)
Стирать идентификатор (ID) нити потомка, расположенный в \fIctid\fP в памяти
потомка, если потомок существует, и активизировать futex по этому
адресу. Соответствующий адрес может быть изменён системным вызовом
\fBset_tid_address\fP(2). Используется в библиотеках работы с нитями.
.TP 
\fBCLONE_CHILD_SETTID\fP (начиная с Linux 2.5.49)
Сохранить ID нити потомка, расположенный в \fIctid\fP в памяти потомка.
.TP 
\fBCLONE_FILES\fP
Если задан флаг \fBCLONE_FILES\fP, то вызывающий процесс и процесс\-потомок
используют одну и ту же таблицу файловых дескрипторов. Любые файловые
дескрипторы, создаваемые вызывающим процессом или процессом\-потомком, также
доступны и в другом процессе. Аналогично, если один из процессов закрывает
файловый дескриптор или изменяет ассоциированные с ним флаги (с помощью
\fBfcntl\fP(2) операцией \fBF_SETFD\fP), то это оказывает влияние и на другой
процесс.

Если флаг \fBCLONE_FILES\fP не задан, то процесс\-потомок наследует копии всех
файловых дескрипторов, открытых в вызывающем процессе на момент вызова
\fBclone\fP(). Дублируемые файловые дескрипторы в потомке указывают на те же
открытые файловые дескрипторы (см. \fBopen\fP(2)), соответствующие файловым
дескрипторам вызывающего процесса. Операции над файловыми дескрипторами,
выполняемые позже вызывающим процессом или процессом\-потомком, не оказывают
эффекта на другой процесс.
.TP 
\fBCLONE_FS\fP
Если задан флаг \fBCLONE_FS\fP, то вызывающий процесс и процесс\-потомок
используют одну и ту же информацию о файловой системе. К ней относится
корневой каталог файловой системы, текущий рабочий каталог и значение
umask. Любой вызов, \fBchroot\fP(2), \fBchdir\fP(2) или \fBumask\fP(2), выполняемый
одним процессом, оказывает влияние и на другой.

Если флаг \fBCLONE_FS\fP не задан, то процесс\-потомок работает с копией
информации о файловой системе вызывающего процесса, снятой на момент вызова
\fBclone\fP(). Вызовы \fBchroot\fP(2), \fBchdir\fP(2), \fBumask\fP(2), выполняемые позже
одним из процессов, не оказывают эффект на другой процесс.
.TP 
\fBCLONE_IO\fP (начиная Linux 2.6.25)
Если задан флаг \fBCLONE_IO\fP, то новый процесс использует общий контекст
ввода\-вывода с вызывающим процессом. Если этот флаг не установлен, то (как и
в \fBfork\fP(2)) новый процесс будет иметь свой отдельный контекст
ввода\-вывода.

.\" The following based on text from Jens Axboe
.\" the anticipatory and CFQ scheduler
.\" with CFQ and AS.
Контекст ввода\-вывода \(em это область ввода\-вывода в дисковом планировщике
(т.е то, что планировщик ввода\-вывода использует при планировании
ввода\-вывода процесса). Если процессы используют общий контекст
ввода\-вывода, то они рассматриваются планировщиком ввода\-вывода как
один. Следовательно, они совместно делят время доступа к диску. У некоторых
планировщиков ввода\-вывода, если два процесса используют общий контекст
ввода\-вывода, то им будет разрешено чередовать доступ к диску. Если
несколько нитей выполняют ввод\-вывод из одного процесса (например,
\fBaio_read\fP(3)), то для них нужно указать \fBCLONE_IO\fP для получения большей
производительности ввода\-вывода.

Если в ядре не указан параметр сборки \fBCONFIG_BLOCK\fP, то этот флаг ни на
что не влияет.
.TP 
\fBCLONE_NEWIPC\fP (начиная с Linux 2.6.19)
Если задан флаг \fBCLONE_NEWIPC\fP, то процесс создаётся в новом пространстве
имён IPC. Если этот флаг не установлен, то (как и в \fBfork\fP(2)) процесс
создаётся в том же пространстве имён IPC что и вызывающий процесс. Этот флаг
предназначен для реализации контейнеров.

Пространство имён IPC состоит из набора идентификаторов объектов System V
IPC. (Эти объекты создаются с помощью \fBmsgctl\fP(2), \fBsemctl\fP(2) и
\fBshmctl\fP(2)). Объекты, созданные в пространстве имён IPC, видимы всем
другим процессам, которые являются членами этого пространства имён, и
невидимы процессам из других пространств имён IPC.

При уничтожении пространства имён IPC (т.е, когда завершается последний
процесс из этого пространства имён), все объекты IPC из пространства имён
автоматически уничтожаются.

Для использования этого флага требуется: ядро, собранное с параметрами
\fBCONFIG_SYSVIPC\fP и \fBCONFIG_IPC_NS\fP, и процесс должен иметь мандат
(\fBCAP_SYS_ADMIN\fP). Этот флаг не может указываться одновременно с
\fBCLONE_SYSVSEM\fP.
.TP 
\fBCLONE_NEWNET\fP (начиная с Linux 2.6.24)
.\" FIXME Check when the implementation was completed
(Реализация этого флага завершена в Linux 2.6.29.)

Если задан флаг \fBCLONE_NEWNET\fP, то процесс создаётся в новом сетевом
пространстве имён. Если флаг не установлен, то (как и в \fBfork\fP(2)), процесс
создаётся в том же сетевом пространстве имён что и вызывающий процесс. Этот
флаг предназначен для реализации контейнеров.

Сетевое пространство имён предоставляет изолированное представление сетевого
стека (интерфейсы сетевых устройств, стеки протоколов IPv4 и IPv6, таблицы
маршрутизации IP, правила межсетевого экрана, дерево каталогов \fI/proc/net\fP
и \fI/sys/class/net\fP, сокеты и т.д.). Физическое сетевое устройство может
находиться только в одном сетевом пространстве имён. Пара виртуальных
сетевых устройств ("veth") предоставляет каналоподобную абстракцию, которую
можно использовать для создания туннелей между сетевыми пространствами имён
и создания моста к физическому сетевому устройству из другого пространства
имён.

Когда сетевое пространство имён высвобождается (т.е., когда завершается
последний процесс в пространстве имён), его физические сетевые устройства
перемещаются обратно в первоначальное сетевое пространство имён (не
родительского процесса).

Для работы флага требуется: ядро, собранное с параметром \fBCONFIG_NET_NS\fP, и
привилегированный процесс (\fBCAP_SYS_ADMIN\fP).
.TP 
\fBCLONE_NEWNS\fP (начиная с Linux 2.4.19)
Запускает потомка в новом пространстве имён монтирования.

Каждый процесс живёт в некотором пространстве имён
монтирования. \fIПространство имён\fP процесса \(em это данные (список
смонтированных файловых систем), описывающие иерархию файлов, видимую этим
процессом. После вызова \fBfork\fP(2) или \fBclone\fP(), если не установлен флаг
\fBCLONE_NEWNS\fP, потомок живёт в том же пространстве имён монтирования что и
родитель. Системные вызовы \fBmount\fP(2) и \fBumount\fP(2) изменяют пространство
имён монтирования вызывающего процесса и, следовательно, влияют на все
процессы, которые живут в этом же пространстве имён, но не влияют на
процессы в других пространствах имён монтирования.

После вызова \fBclone\fP() с установленным флагом \fBCLONE_NEWNS\fP потомок
запускается в новом пространстве имён монтирования, инициализированном
копией пространства имён родителя.

Только привилегированный процесс (имеющий мандат \fBCAP_SYS_ADMIN\fP) может
задавать флаг \fBCLONE_NEWNS\fP. Не допускается совместное использование флагов
\fBCLONE_NEWNS\fP и \fBCLONE_FS\fP в одном вызове \fBclone\fP().
.TP 
\fBCLONE_NEWPID\fP (начиная с Linux 2.6.24)
.\" This explanation draws a lot of details from
.\" http://lwn.net/Articles/259217/
.\" Authors: Pavel Emelyanov <xemul@openvz.org>
.\" and Kir Kolyshkin <kir@openvz.org>
.\"
.\" The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
.\" Author: Pavel Emelyanov <xemul@openvz.org>
Если задан флаг \fBCLONE_NEWPID\fP, то процесс создаётся в новом пространстве
имён PID. Если флаг не установлен, то (как и в \fBfork\fP(2)), процесс
создаётся в том же пространстве имён PID, что и вызывающий процесс. Этот
флаг предназначен для реализации контейнеров.

Пространство имён PID предоставляет изолированное окружение для
идентификаторов (PID): идентификаторы в новом пространстве имён начинаются с
1 как в автономной системе, и вызовы \fBfork\fP(2), \fBvfork\fP(2) или \fBclone\fP(2)
будут создавать процессы с уникальными идентификаторами в пределах
пространства имён.

Первый созданный процесс в новом пространстве имён (т.е., процесс, созданный
с флагом \fBCLONE_NEWPID\fP) имеет PID 1, и является "начальным" процессом в
пространстве имён. Потомкам, теряющим родителей в этом пространстве имён,
будет переназначен этот процесс, а не \fBinit\fP(8). В отличие от обычного
процесса \fBinit\fP, "начальный" процесс пространства имён PID может
завершиться и если это произойдёт, то все процессы в этом пространстве имён
также завершатся.

Пространства имён PID образуют иерархию. Когда создаётся новое пространство
имён PID, процессы в этом пространстве видимы в пространстве имён PID
процесса, который создал это новое пространство имён; аналогично, если
родитель пространства имён PID сам является потомком другого пространства
имён PID, то процессы в пространстве имён PID потомка и родителя будут
видимы в прародительском пространстве имён PID. И наоборот, процессы в
"дочернем" пространстве имён PID не видят процессы в родительском
пространстве имён. Существование иерархии пространства имён означает, что
каждый процесс теперь может иметь несколько PID \(em один на каждое
пространство имён, в котором он видим; каждый из этих PID уникален внутри
соответствующего пространства имён. Вызов \fBgetpid\fP(2) всегда возвращает
PID, связанный с пространством имён, в котором находится процесс.

.\" mount -t proc proc /proc
После создания нового пространства имён для потомка полезно изменить свой
корневой каталог и примонтировать новый экземпляр procfs в каталог \fI/proc\fP
так, чтобы различные инструменты, например \fBps\fP(1), работали
правильно. (Если в \fIflags\fP также установлен \fBCLONE_NEWNS\fP, то нет
необходимости изменять корневой каталог: новый экземпляр procfs можно
смонтировать непосредственно поверх \fI/proc\fP.)

Для использования флага требуется: ядро, собранное с параметром
\fBCONFIG_PID_NS\fP и привилегированный процесс (\fBCAP_SYS_ADMIN\fP). Данный флаг
не может указываться вместе с \fBCLONE_THREAD\fP.
.TP 
\fBCLONE_NEWUTS\fP (начиная с Linux 2.6.19)
Если задан флаг \fBCLONE_NEWUTS\fP, то процесс создаётся в новом пространстве
имён UTS, чьи идентификаторы инициализируются копией идентификаторов из
пространства имён UTS вызывающего процесса. Если флаг не указан, то (как и в
\fBfork\fP(2)), процесс создаётся в том же пространстве имён UTS что и
вызывающий процесс. Этот флаг предназначен для реализации контейнеров.

Пространство имён UTS \(em это набор идентификаторов, возвращаемых
\fBuname\fP(2); помимо остальных, сюда включены доменное имя и имя узла,
которые изменить с помощью \fBsetdomainname\fP(2) и \fBsethostname\fP(2),
соответственно. Изменившиеся идентификаторы в пространстве имён UTS видимы
всем остальным процессам в том же пространстве имён, но не видимы процессам
из других пространств имён UTS.

Для этого флага требуется: ядро, собранное с параметром \fBCONFIG_UTS_NS\fP и
привилегированный процесс (\fBCAP_SYS_ADMIN\fP).
.TP 
\fBCLONE_PARENT\fP (начиная с Linux 2.3.12)
Если задан флаг \fBCLONE_PARENT\fP, то родитель нового потомка (возвращаемый
\fBgetppid\fP(2)) будет таким же как и у вызывающего процесса.

Если флаг \fBCLONE_PARENT\fP не задан, то (как и в \fBfork\fP(2)) родителем будет
вызывающий процесс.

Заметим, что это тот родительский процесс, который возвращается вызовом
\fBgetppid\fP(2), и которому приходит сигнал когда потомок завершается, так что
если указан флаг \fBCLONE_PARENT\fP, то сигнал будет посылаться родителю
вызывающего процесса, а не самому вызывающему процессу.
.TP 
\fBCLONE_PARENT_SETTID\fP (начиная с Linux 2.5.49)
Сохраняет ID нити потомка в расположение \fIptid\fP в память родителя и
потомка. (В Linux 2.5.32\-2.5.48 был флаг \fBCLONE_SETTID\fP, который делал
это.)
.TP 
\fBCLONE_PID\fP (устарел)
Если задан флаг \fBCLONE_PID\fP, то процесс\-потомок создаётся с таким же
идентификатором процесса (ID) как и вызывающий процесс. Это хорошо для
ковыряния в системе, но не более того. Начиная с 2.3.21 этот флаг может быть
указан только в системном загрузочном процессе (PID 0). Флаг удалён в Linux
2.5.16.
.TP 
\fBCLONE_PTRACE\fP
Если задан флаг \fBCLONE_PTRACE\fP и вызывающий процесс находится в режиме
трассировки, то процесс\-потомок также будет работать в режиме трассировки
(см. \fBptrace\fP(2)).
.TP 
\fBCLONE_SETTLS\fP (начиная с Linux 2.5.32)
Аргумент \fInewtls\fP содержит новый дескриптор TLS (локальная память
нитей). (См. \fBset_thread_area\fP(2).)
.TP 
\fBCLONE_SIGHAND\fP
Если задан флаг \fBCLONE_SIGHAND\fP, то вызывающий процесс и процесс\-потомок
используют одну и ту же таблицу обработчиков сигналов. Если вызывающий
процесс или процесс\-потомок вызывают \fBsigaction\fP(2) для изменения поведения
при получении сигнала, то это поведение изменяется также и в другом
процессе. Однако, вызывающий процесс и процесс\-потомок имеют различные маски
сигналов и списки ожидающих обработки сигналов. Так, один из них может
блокировать или деблокировать некоторые сигналы, используя
\fBsigprocmask\fP(2), и это не будет влиять на другой процесс.

Если флаг \fBCLONE_SIGHAND\fP не указан, то процесс\-потомок наследует копию
обработчиков событий вызывающего процесса, снятую на момент вызова
\fBclone\fP(). Вызовы \fBsigaction\fP(2), выполняемые позже одним из процессов, не
оказывают влияния на другой процесс.

Начиная с Linux 2.6.0\-test6, \fIflags\fP должен также включать \fBCLONE_VM\fP,
если указан \fBCLONE_SIGHAND\fP.
.TP 
\fBCLONE_STOPPED\fP (начиная с Linux 2.6.0\-test2)
Если указан флаг \fBCLONE_STOPPED\fP, то после создания потомок перейдёт в
состояние останова (как если бы ему послали сигнал \fBSIGSTOP\fP), и начнёт
работу по сигналу \fBSIGCONT\fP.

.\" glibc 2.8 removed this defn from bits/sched.h
Этот флаг \fIустарел\fP начиная с Linux 2.6.25 и был \fIудалён\fP в Linux 2.6.38.
.TP 
\fBCLONE_SYSVSEM\fP (начиная с Linux 2.5.10)
Если указан флаг \fBCLONE_SYSVSEM\fP, то потомок и вызывающий процесс будут
использовать общий список значений undo для семафоров System V (смотрите
\fBsemop\fP(2)). Если флаг не указан, то потомок получит отдельный список undo,
который изначально пуст.
.TP 
\fBCLONE_THREAD\fP (начиная с Linux 2.4.0\-test8)
Если указан флаг \fBCLONE_THREAD\fP, то потомок размещается в той же группе
нитей, что и вызывающий процесс. Чтобы сделать остаток обсуждения
\fBCLONE_THREAD\fP более понятным, термин "нить" используется для ссылки на
процессы внутри группы нитей.

Группы нитей были добавлены в Linux 2.4 для поддержки нитей POSIX,
описываемых как набор нитей, использующих один и тот же PID. Внутренне общий
PID \(em это так называемый идентификатор группы нитей (TGID). Начиная с
Linux 2.4, вызов \fBgetpid\fP(2) возвращает идентификатор группы нитей
вызывающего процесса.

Внутри группы нити можно различать по их (глобальному) уникальному
идентификатору нити (TID). TID новой нити возвращается вызывающему как
результат \fBclone\fP(), а нить может узнать свой TID с помощью вызова
\fBgettid\fP(2).

Когда вызов \fBclone\fP() делается без \fBCLONE_THREAD\fP, то получаемая нить
помещается в новую группу нитей, чей TGID совпадает с TID нити. Эта нить
будет \fIлидером\fP новой группы нитей.

Новая нить, созданная с \fBCLONE_THREAD\fP, имеет тот же родительский процесс
что и вызвавший \fBclone\fP() (т.е., как \fBCLONE_PARENT\fP), поэтому при вызове
\fBgetppid\fP(2) возвращается одинаковое значение для всех нитей в группе
нитей. Когда нить \fBCLONE_THREAD\fP завершается, нити, создавшей её с помощью
\fBclone\fP(), не посылается сигнал \fBSIGCHLD\fP (или другой сигнал завершения);
состояние такой нити нельзя получить с помощью \fBwait\fP(2). Про нить говорят,
что она \fIотсоединена\fP (detached).

После завершения работы всех нитей в группе нитей родительскому процессу
группы нитей посылается сигнал \fBSIGCHLD\fP (или другой завершающий сигнал).

Если в любой из нитей группы нитей выполняется вызов \fBexecve\fP(2), то все
нити отличные от лидера группы нитей, завершаются и выполняется новая
программы в лидере группы нитей.

Если одна из нитей группы нитей создаёт потомка с помощью \fBfork\fP(2), то
любая нить группы может вызвать \fBwait\fP(2) для ожидания этого потомка.

Начиная с Linux 2.5.35, аргумент \fIflags\fP должен также включать
\fBCLONE_SIGHAND\fP, если указан флаг \fBCLONE_THREAD\fP.

Сигналы могут посылаться как всей группе (т.е., TGID) с помощью \fBkill\fP, так
и заданной нити (т.е., TID) с помощью \fBtgkill\fP(2).

Расположение и действия сигналов распространяются на весь процесс: если
необработанный сигнал доставляется нити, то это влияет (завершение,
остановка, продолжение, игнорирование) на все члены группы нитей.

Каждая нить имеет свою маску сигналов, задаваемую с помощью
\fBsigprocmask\fP(2), но сигналы могут ожидать обработки: всем процессом (т.е.,
доставляются всем членам группы нитей), если посылаются с помощью
\fBkill\fP(2); или отдельной нитью, если посылаются с помощью
\fBtgkill\fP(2). Вызов \fBsigpending\fP(2) возвращает набор сигналов, который
представляет собой объединение ожидающих сигналов для всего процесса и
сигналов, которые ожидает вызывающая нить.

Если для отправки сигнала группе нитей используется \fBkill\fP(2) и у группы
нитей установлен обработчик сигнала, то обработчик будет вызван только один
раз в произвольно выбранном члене группы нитей, который не блокирует
сигнал. Если несколько нитей в группе ждут приёма того же сигнала с помощью
\fBsigwaitinfo\fP(2), то ядро произвольно выберет одну из этих нитей для приёма
сигнала, отправленного с помощью \fBkill\fP(2).
.TP 
\fBCLONE_UNTRACED\fP (начиная с Linux 2.5.46)
Если указан флаг \fBCLONE_UNTRACED\fP, то выполняющий трассировку процесс не
сможет указать \fBCLONE_PTRACE\fP на этом процессе\-потомке.
.TP 
\fBCLONE_VFORK\fP
Если указан флаг \fBCLONE_VFORK\fP, то выполнение вызывающего процесса
приостанавливается до тех пор, пока потомок не освободит ресурсы виртуальной
памяти с помощь вызова \fBexecve\fP(2) или \fB_exit\fP(2) (как с \fBvfork\fP(2)).

Если флаг \fBCLONE_VFORK\fP не указан, то вызывающий процесс и потомок доступны
для планирования после вызова, и приложение не должно полагаться на то, что
выполнение производится в каком\-то определённом порядке.
.TP 
\fBCLONE_VM\fP
Если задан флаг \fBCLONE_VM\fP, то вызывающий и дочерний процесс работают в
одном пространстве памяти. В частности, запись в память одним процессом
видна другому. Кроме того, выполнение отображения или снятия отображения в
память, выполняемая с помощью \fBmmap\fP(2) или \fBmunmap\fP(2), одним процессом,
влияет на другой.

Если флаг \fBCLONE_VM\fP не установлен, то дочерний процесс выполняется в
отдельной копии пространства памяти вызывающего процесс с момента
\fBclone\fP(). Запись в память или отображение/снятие отображения файла,
выполняемое одним процессом, не влияет на другой (как с \fBfork\fP(2)).
.SS sys_clone
Системный вызов \fBsys_clone\fP больше похож на \fBfork\fP(2) в том плане, что
выполнение в потомке продолжается от места данного вызова. Таким образом
\fBsys_clone\fP требует только аргументы \fIflags\fP и \fIchild_stack\fP, которые
имеют то же значение что и для вызова \fBclone\fP(). Заметим, что порядок этих
аргументов отличается от \fBclone\fP().

Другое отличие \fBsys_clone\fP состоит в том, что аргумент \fIchild_stack\fP может
быть нулём, в этом случае семантика копирование\-при\-записи обеспечивает
получение потомком отдельных копий страниц стека, когда один из процессов
изменяет стек. В этом случае для правильной работы не должен быть задан флаг
\fBCLONE_VM\fP.

В Linux 2.4 и более ранних \fBclone\fP() не принимал аргументов \fIptid\fP, \fItls\fP
и \fIctid\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
.\" gettid(2) returns current->pid;
.\" getpid(2) returns current->tgid;
При успешном выполнении в вызывающую исполняемую нить возвращается ID нити
дочернего процесса. Иначе в контекст вызывающего возвращается \-1, дочерний
процесс не создаётся и \fIerrno\fP устанавливается в соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEAGAIN\fP
Уже выполняется максимальное количество процессов.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_SIGHAND\fP, но нет \fBCLONE_VM\fP (начиная с Linux
2.6.0\-test6).
.TP 
\fBEINVAL\fP
.\" .TP
.\" .B EINVAL
.\" Precisely one of
.\" .B CLONE_DETACHED
.\" and
.\" .B CLONE_THREAD
.\" was specified.
.\" (Since Linux 2.6.0-test6.)
Указан флаг \fBCLONE_THREAD\fP, но нет \fBCLONE_SIGHAND\fP (начиная с Linux
2.5.35).
.TP 
\fBEINVAL\fP
Указаны оба флага, \fBCLONE_FS\fP и \fBCLONE_NEWNS\fP, в \fIflags\fP.
.TP 
\fBEINVAL\fP
Указаны оба флага, \fBCLONE_NEWIPC\fP и \fBCLONE_SYSVSEM\fP, в \fIflags\fP.
.TP 
\fBEINVAL\fP
Указаны оба флага, \fBCLONE_NEWPID\fP и \fBCLONE_THREAD\fP, в \fIflags\fP.
.TP 
\fBEINVAL\fP
Возвращается \fBclone\fP(), если \fIchild_stack\fP равен нулю.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWIPC\fP в \fIflags\fP, но ядро собрано без параметров
\fBCONFIG_SYSVIPC\fP и \fBCONFIG_IPC_NS\fP.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWNET\fP в \fIflags\fP, но ядро собрано без параметра
\fBCONFIG_NET_NS\fP.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWPID\fP в \fIflags\fP, но ядро собрано без параметра
\fBCONFIG_PID_NS\fP.
.TP 
\fBEINVAL\fP
Указан флаг \fBCLONE_NEWUTS\fP в \fIflags\fP, но ядро собрано без параметра
\fBCONFIG_UTS\fP.
.TP 
\fBENOMEM\fP
Не удалось выделить достаточно памяти для структуры задач потомка или
скопировать необходимые части контекста вызывающего.
.TP 
\fBEPERM\fP
Указан флаг \fBCLONE_NEWIPC\fP, \fBCLONE_NEWNET\fP, \fBCLONE_NEWNS\fP,
\fBCLONE_NEWPID\fP, или \fBCLONE_NEWUTS\fP, но процесс не имеет достаточно прав
(нет мандата \fBCAP_SYS_ADMIN\fP).
.TP 
\fBEPERM\fP
Указан флаг \fBCLONE_PID\fP, но ID процесса не равен 0.
.SH ВЕРСИИ
Вызов \fBclone\fP() отсутствует в libc5. В glibc2 есть \fBclone\fP(), который
соответствует данному описанию.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Вызовы \fBclone\fP() и \fBsys_clone\fP есть только в Linux и не должны
использовать в переносимых программах.
.SH ЗАМЕЧАНИЯ
Для ядер версий 2.4.x флаг \fBCLONE_THREAD\fP не делает родителем новой нити
того же родителя что и у вызывающего процесса. Однако для ядер версий
2.4.7\-2.4.18 флаг \fBCLONE_THREAD\fP неявно подразумевает флаг \fBCLONE_PARENT\fP
(как в ядре 2.6).

Некоторое время существовал флаг \fBCLONE_DETACHED\fP (начиная с 2.5.32):
родитель не хочет получать сигнал завершения потомка. В версии 2.6.2 это
стало действием по умолчанию и флаг \fBCLONE_THREAD\fP был убран. Этот флаг ещё
определён, но не оказывает никакого действия.

На архитектуре i386 \fBclone\fP() не должен вызываться через vsyscall, а
запускаться явно с помощью \fIint $0x80\fP.

На ia64 используется другой системный вызов:
.nf

\fBint __clone2(int (*\fP\fIfn\fP\fB)(void *), \fP
\fB             void *\fP\fIchild_stack_base\fP\fB, size_t \fP\fIstack_size\fP\fB,\fP
\fB             int \fP\fIflags\fP\fB, void *\fP\fIarg\fP\fB, ... \fP
\fB          /* pid_t *\fP\fIptid\fP\fB, struct user_desc *\fP\fItls\fP\fB, pid_t *\fP\fIctid\fP\fB */ );\fP
.fi
.PP
Системный вызов \fB__clone2\fP() работает также как и \fBclone\fP() за исключением
того, что \fIchild_stack_base\fP указывает на самый нижний адрес области стека
потомка, и в \fIstack_size\fP задаётся размер стека, указываемого в
\fIchild_stack_base\fP.
.SH ДЕФЕКТЫ
Версии библиотеки GNU C, которые включают библиотеку нитей NPTL, содержат
обёрточную функцию \fBgetpid\fP(2), которая выполняет кэширование PID. Это
кэширование полагается на поддержку обёртки glibc для \fBclone\fP(), но,
согласно имеющейся реализации, в некоторых случаях кэш может содержать
неактуальные данные. В частности, если сигнал доставляется потомку сразу
после вызова \fBclone\fP(), то вызов \fBgetpid\fP(2) в обработчике сигнала может
может вернуть PID вызывающего процесса («родителя»), если у обёртки clone
ещё не было возможности обновить кэш PID в потомке. (В этом описании не
рассматривается случай где потомок был создан с использованием флага
\fBCLONE_THREAD\fP, когда \fBgetpid\fP(2) \fIдолжен\fP вернуть одинаковое значение и
в потомок и в процесс, который вызвал \fBclone\fP(), так как вызывающий и
потомок находятся в одной группе нитей. Также проблема устаревания кэша
возникает, если аргумент \fIflags\fP содержит \fBCLONE_VM\fP.) Чтобы получить
правильное значение, может потребоваться использовать следующий код:
.nf

    #include <syscall.h>

    pid_t mypid;

    mypid = syscall(SYS_getpid);
.fi
.\" See also the following bug reports
.\" https://bugzilla.redhat.com/show_bug.cgi?id=417521
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=6910
.SH "СМОТРИТЕ ТАКЖЕ"
\fBfork\fP(2), \fBfutex\fP(2), \fBgetpid\fP(2), \fBgettid\fP(2), \fBset_thread_area\fP(2),
\fBset_tid_address\fP(2), \fBtkill\fP(2), \fBunshare\fP(2), \fBwait\fP(2),
\fBcapabilities\fP(7), \fBpthreads\fP(7)

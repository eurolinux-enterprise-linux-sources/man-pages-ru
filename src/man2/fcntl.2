.\" t
.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" This manpage is Copyright (C) 1992 Drew Eckhardt;
.\"                 and Copyright (C) 1993 Michael Haardt, Ian Jackson;
.\"                 and Copyright (C) 1998 Jamie Lokier;
.\"                 and Copyright (C) 2002-2010 Michael Kerrisk.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified 1993-07-24 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1995-09-26 by Andries Brouwer <aeb@cwi.nl>
.\" and again on 960413 and 980804 and 981223.
.\" Modified 1998-12-11 by Jamie Lokier <jamie@imbolc.ucc.ie>
.\" Applied correction by Christian Ehrhardt - aeb, 990712
.\" Modified 2002-04-23 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added note on F_SETFL and O_DIRECT
.\"	Complete rewrite + expansion of material on file locking
.\"	Incorporated description of F_NOTIFY, drawing on
.\"		Stephen Rothwell's notes in Documentation/dnotify.txt.
.\"	Added description of F_SETLEASE and F_GETLEASE
.\" Corrected and polished, aeb, 020527.
.\" Modified 2004-03-03 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Modified description of file leases: fixed some errors of detail
.\"     Replaced the term "lease contestant" by "lease breaker"
.\" Modified, 27 May 2004, Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added notes on capability requirements
.\" Modified 2004-12-08, added O_NOATIME after note from Martin Pool
.\" 2004-12-10, mtk, noted F_GETOWN bug after suggestion from aeb.
.\" 2005-04-08 Jamie Lokier <jamie@shareable.org>, mtk
.\"	Described behavior of F_SETOWN/F_SETSIG in
.\"	multithreaded processes, and generally cleaned
.\"	up the discussion of F_SETOWN.
.\" 2005-05-20, Johannes Nicolai <johannes.nicolai@hpi.uni-potsdam.de>,
.\"	mtk: Noted F_SETOWN bug for socket file descriptor in Linux 2.4
.\"	and earlier.  Added text on permissions required to send signal.
.\" 2009-09-30, Michael Kerrisk
.\"     Note obsolete F_SETOWN behavior with threads.
.\"     Document F_SETOWN_EX and F_GETOWN_EX
.\" 2010-06-17, Michael Kerrisk
.\"	Document F_SETPIPE_SZ and F_GETPIPE_SZ.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH FCNTL 2 2012\-04\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
fcntl \- работа с файловым дескриптором
.SH ОБЗОР
.nf
\fB#include <unistd.h>\fP
\fB#include <fcntl.h>\fP
.sp
\fBint fcntl(int \fP\fIfd\fP\fB, int \fP\fIcmd\fP\fB, ... /* \fP\fIarg\fP\fB */ );\fP
.fi
.SH ОПИСАНИЕ
\fBfcntl\fP() позволяет выполнять различные команды над открытым файловым
дескриптором \fIfd\fP. Команда определяется содержимым аргумента \fIcmd\fP.

\fBfcntl\fP() может принимать необязательный третий аргумент. Необходимость его
указания зависит от значения, указанного в \fIcmd\fP. Тип необходимого
аргумента указан в скобках после каждого имени значения \fIcmd\fP (в
большинстве случаев требуется тип \fIint\fP, и мы определяем аргумент с помощью
имени \fIarg\fP), или указывается \fIvoid\fP, если аргумент не нужен.
.SS "Создание дубликата файлового дескриптора"
.TP 
\fBF_DUPFD\fP (\fIint\fP)
Найти наименьший доступный номер файлового дескриптора, который больше или
равен \fIarg\fP, и сделать из него копию дескриптора \fIfd\fP. Отличие от
\fBdup2\fP(2) в том, что там дескриптор задаётся явно.
.IP
При успешном выполнении этой команды, возвращается новый файловый
дескриптор.
.IP
Дополнительную информацию смотрите в \fBdup\fP(2).
.TP 
\fBF_DUPFD_CLOEXEC\fP (\fIint\fP; начиная с Linux 2.6.24)
Как \fBF_DUPFD\fP, но на новом дескрипторе дополнительно устанавливается флаг
закрытия\-при\-exec. Установка этого флага позволяет программам не делать
дополнительный вызов \fBfcntl\fP() с командой \fBF_SETFD\fP для установки флага
\fBFD_CLOEXEC\fP. О том, зачем нужен этот флаг, смотрите описание \fBO_CLOEXEC\fP
в \fBopen\fP(2).
.SS "Флаги файлового дескриптора"
Следующие команды работают с флагами, связанными с файловым дескриптором. В
настоящее время определён только один флаг: \fBFD_CLOEXEC\fP, флаг
закрытия\-при\-exec. Если бит \fBFD_CLOEXEC\fP равен 0, то файловый дескриптор
останется открытым при вызове \fBexecve\fP(2), иначе он будет закрыт.
.TP 
\fBF_GETFD\fP (\fIvoid\fP)
Прочитать флаги файлового дескриптора; \fIarg\fP игнорируется.
.TP 
\fBF_SETFD\fP (\fIint\fP)
Установить флаги файлового дескриптора согласно значению, указанному в
аргументе \fIarg\fP.
.SS "Флаги состояния файла"
.\" or
.\" .BR creat (2),
Каждое описание открытого файла имеет несколько связанных с ним флагов
состояния, которые инициализируются вызовом \fBopen\fP(2) и, возможно,
изменяются затем вызовом \fBfcntl\fP(). Эти флаги совместно используются
копиями файловых дескрипторов (сделанными с помощью \fBdup\fP(2),
\fBfcntl\fP(F_DUPFD), \fBfork\fP(2) и т.д.), которые указывают на одно описание
открытого файла.

Эти флаги состояния и их смысл описаны в \fBopen\fP(2).
.TP 
\fBF_GETFL\fP (\fIvoid\fP)
Получить права доступа к файлу и флаги состояния файла; \fIarg\fP игнорируется.
.TP 
\fBF_SETFL\fP (\fIint\fP)
.\" FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
.\" via fcntl(2), but currently Linux does not permit this
.\" See http://bugzilla.kernel.org/show_bug.cgi?id=5994
Установить флаги состояния файла согласно значению, указанному в аргументе
\fIarg\fP. Режим доступа к файлу (\fBO_RDONLY\fP, \fBO_WRONLY\fP, \fBO_RDWR\fP) и флаги
создания файла (т.е. \fBO_CREAT\fP, \fBO_EXCL\fP, \fBO_NOCTTY\fP, \fBO_TRUNC\fP) в
\fIarg\fP игнорируются. В Linux эта команда может изменять только флаги
\fBO_APPEND\fP, \fBO_ASYNC\fP, \fBO_DIRECT\fP, \fBO_NOATIME\fP и \fBO_NONBLOCK\fP.
.SS "Консультативная (advisory) блокировка"
Команды \fBF_GETLK\fP, \fBF_SETLK\fP и \fBF_SETLKW\fP используются для установки,
снятия и тестирования существования блокировок записей (также известных как
блокировки сегмента или области файла). Третий аргумент, \fIlock\fP, является
указателем на структуру, которая имеет, по крайней мере, следующие поля (в
произвольном порядке):
.in +4n
.nf
.sp
struct flock {
    ...
    short l_type;    /* Тип блокировки: F_RDLCK,
                        F_WRLCK, F_UNLCK */
    short l_whence;  /* Как интерпретировать l_start:
                        SEEK_SET, SEEK_CUR, SEEK_END */
    off_t l_start;   /* Начальное смещение для блокировки */
    off_t l_len;     /* Количество блокируемых байт */
    pid_t l_pid;     /* PID процесса, блокирующего нашу блокировку
                        (только для F_GETLK) */
    ...
};
.fi
.in
.P
Поля \fIl_whence\fP, \fIl_start\fP и \fIl_len\fP этой структуры задают диапазон байт,
который мы хотим заблокировать. Могут блокироваться байты за концом файла,
но не перед началом файла.

\fIl_start\fP \(em это начальное смещение для блокировки, которое
интерпретируется как начало файла (если значение \fIl_whence\fP равно
\fBSEEK_SET\fP); как текущая позиция в файле (если значение \fIl_whence\fP равно
\fBSEEK_CUR\fP); как конец файла (если значение \fIl_whence\fP равно
\fBSEEK_END\fP). В последних двух случаях, \fIl_start\fP может иметь отрицательное
значение, предоставляя смещение, которого не может указать до начала файла.

В \fIl_len\fP задаётся количество байт, которые нужно заблокировать. Если
\fIl_len\fP положительно, то диапазон блокировки начинается со \fIl_start\fP и
кончается \fIl_start\fP+\fIl_len\fP\-\fI1\fP включительно. Если в \fIl_len\fP указан 0,
то блокируются все байты начиная с места, указанного \fIl_whence\fP и
\fIl_start\fP и до конца файла, независимо от величины файла.

POSIX.1\-2001 позволяет (но не требует) реализации поддерживать отрицательное
значение \fIl_len\fP; если \fIl_len\fP отрицательно, то интервал, описываемый
\fIlock\fP, имеет размер \fIl_start\fP+\fIl_len\fP до \fIl_start\fP\-1 включительно. Это
поддерживается в Linux начиная с ядер версии 2.4.21 и 2.5.49.

Поле \fIl_type\fP может быть использовано для указания типа блокировки файла:
чтение (\fBF_RDLCK\fP) или запись (\fBF_WRLCK\fP). Любое количество процессов
могут удерживать блокировку на чтение (общая блокировка) области файла, но
только один процесс может удерживать блокировку на запись (эксклюзивная
блокировка). Эксклюзивная блокировка исключает все другие блокировки, как
общие так и эксклюзивные. Один процесс может удерживать только один тип
блокировки области файла; если происходит новая блокировка уже
заблокированной области, то существующая блокировка преобразуется в новый
тип блокировки. (Такие преобразования могут привести к разбиению, уменьшению
или срастанию с существующей блокировкой, если диапазон байт, заданный для
новой блокировки, неточно совпадает с диапазоном существующей блокировки.)
.TP 
\fBF_SETLK\fP (\fIstruct flock *\fP)
Установить блокировку (когда \fIl_type\fP равен \fBF_RDLCK\fP или \fBF_WRLCK\fP) или
снять блокировку (когда \fIl_type\fP равен \fBF_UNLCK\fP) байтов, указанных полями
\fIl_whence\fP, \fIl_start\fP и \fIl_len\fP структуры \fIlock\fP. Если конфликтующая
блокировка удерживается другим процессом, то данный вызов вернёт \-1 и
установит значение \fIerrno\fP в \fBEACCES\fP или \fBEAGAIN\fP.
.TP 
\fBF_SETLKW\fP (\fIstruct flock *\fP)
Как \fBF_SETLK\fP, но если конфликтующая блокировка удерживается на файле, то
выполняется ожидание снятия этой блокировки. Если во время ожидания поступил
сигнал, то данный вызов прерывается и (после возврата из обработчика
сигнала) из него происходит немедленный возврат (возвращается значение \-1 и
\fIerrno\fP устанавливается в \fBEINTR\fP; см. \fBsignal\fP(7)).
.TP 
\fBF_GETLK\fP (\fIstruct flock *\fP)
При входе в этот вызов, \fIlock\fP описывает блокировку, которую мы хотели бы
установить на файл. Если такая блокировка не может быть установлена,
\fBfcntl\fP() не устанавливает её, но возвращает \fBF_UNLCK\fP в поле \fIl_type\fP
структуры \fIlock\fP и оставляет другие поля структуры неизменёнными. Если одна
или более несовместимых блокировок мешают установке этой блокировки, то
\fBfcntl\fP() возвращает подробности об одной из этих блокировок в полях
\fIl_type\fP, \fIl_whence\fP, \fIl_start\fP и \fIl_len\fP структуры \fIlock\fP и
присваивает \fIl_pid\fP значение PID того процесса, который удерживает
блокировку.
.P
Для того, чтобы установить блокировку на чтение, \fIfd\fP должен быть открыт на
чтение. Для того, чтобы установить блокировку на запись, \fIfd\fP должен быть
открыт на запись. Чтобы установить оба типа блокировки, дескриптор должен
быть открыт на запись и на чтение.
.P
.\" (Additional file descriptors referring to the same file
.\" may have been obtained by calls to
.\" .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
Также как и при снятии блокировки через явное указание \fBF_UNLCK\fP,
блокировка автоматически снимается, когда процесс завершается или если он
закрывает \fIлюбой\fP файловый дескриптор, ссылающийся на файл, на котором
удерживается блокировка. Это плохо: это означает, что процесс может потерять
блокировки на файлах типа \fI/etc/passwd\fP или \fI/etc/mtab\fP, когда по
какой\-либо причине библиотечная функция решает их открыть, прочитать и
закрыть.
.P
Блокировки не наследуются потомком, созданным через \fBfork\fP(2), но
сохраняются при вызове \fBexecve\fP(2).
.P
Поскольку буферизация выполняется через библиотеку \fBstdio\fP(3),
использование блокировок с функциями в этом пакете нужно избегать; вместо
этих функций используйте \fBread\fP(2) и \fBwrite\fP(2).
.SS "Обязательная (mandatory) блокировка"
(Не POSIX) Описываемые блокировки могут быть или консультативные, или
обязательные; по умолчанию используются консультативные.

Консультативные блокировки не обязательны к выполнению и полезны только в
сотрудничающих процессах.

Обязательные блокировки влияют на все процессы. Если процесс пытается
получить несовместимый доступ (например, \fBread\fP(2) и \fBwrite\fP(2)) к области
файла, на которую установлена несовместимая обязательная блокировка, то
результат зависит от состояния флага \fBO_NONBLOCK\fP в описании этого
открытого файла. Если флаг \fBO_NONBLOCK\fP не установлен, то системный вызов
блокируется до удаления блокировки или преобразуется в режим, который
совместим с доступом. Если флаг \fBO_NONBLOCK\fP установлен, то системный вызов
завершается с ошибкой \fBEAGAIN\fP.

Чтобы использовать обязательные блокировки, обязательное блокирование должно
быть включено в файловой системе, содержащей файл, и на самом
файле. Обязательное блокирование включается в файловой системе с помощью
параметра "\-o mand" команды \fBmount\fP(8) или с помощью флага \fBMS_MANDLOCK\fP в
\fBmount\fP(2). Обязательное блокирование включается на файле посредством
отключения права исполнения группе и установкой бита set\-group\-ID
(см. \fBchmod\fP(1) и \fBchmod\fP(2)).

Реализация обязательного блокирования в Linux ненадёжна. Смотрите раздел
ДЕФЕКТЫ далее.
.SS "Управление сигналами"
Для управления сигналами доступности ввода/вывода используются команды
\fBF_GETOWN\fP, \fBF_SETOWN\fP, \fBF_GETOWN_EX\fP, \fBF_SETOWN_EX\fP, \fBF_GETSIG\fP и
\fBF_SETSIG\fP:
.TP 
\fBF_GETOWN\fP (\fIvoid\fP)
Получить (как результат работы функции) идентификатор процесса или группы
процесса, который в текущий момент принимает сигналы \fBSIGIO\fP и \fBSIGURG\fP
для событий на файловом дескрипторе \fIfd\fP. Идентификатор процесса
возвращается как положительное число; идентификатор группы возвращается как
отрицательное число (но см. раздел ДЕФЕКТЫ далее). Аргумент \fIarg\fP
игнорируется.
.TP 
\fBF_SETOWN\fP (\fIint\fP)
Установить идентификатор процесса или группы процесса, которые будут
принимать сигналы \fBSIGIO\fP и \fBSIGURG\fP для событий на файловом дескрипторе
\fIfd\fP; идентификатор задаётся в аргументе \fIarg\fP. Идентификатор процесса
задаётся положительным числом, идентификатор группы задаётся отрицательным
числом. Обычно, вызывающий процесс указывает самого себя в качестве
принимающего (то есть в \fIarg\fP указывается результат \fBgetpid\fP(2)).

.\" From glibc.info:
Если вы установили на файловый дескриптор флаг состояния \fBO_ASYNC\fP с
помощью команды \fBF_SETFL\fP в \fBfcntl\fP(), то сигнал \fBSIGIO\fP посылается
всякий раз, когда для данного файлового дескриптора становится возможным
ввод или вывод. \fBF_SETSIG\fP можно использовать для включения доставки
сигнала, отличного от \fBSIGIO\fP. Если такая проверка разрешения завершится
неудачно, то сигнал просто отбрасывается.

Отправка сигнала процессу\-владельцу (группе), указанному с помощью
\fBF_SETOWN\fP \(em такая же проверка прав, как описанная для \fBkill\fP(2), где
посылающий процесс один из тех, который может пользоваться \fBF_SETOWN\fP (но
см. раздел ДЕФЕКТЫ далее).

.\" The following appears to be rubbish.  It doesn't seem to
.\" be true according to the kernel source, and I can write
.\" a program that gets a terminal-generated SIGIO even though
.\" it is not the foreground process group of the terminal.
.\" -- MTK, 8 Apr 05
.\"
.\" If the file descriptor
.\" .I fd
.\" refers to a terminal device, then SIGIO
.\" signals are sent to the foreground process group of the terminal.
Если файловый дескриптор \fIfd\fP указывает на сокет, то по команде \fBF_SETOWN\fP
для него также выбирается получатель сигналов \fBSIGURG\fP, которые
доставляются, когда на сокет поступают внеполосные данные. (\fBSIGURG\fP
посылается во всех ситуациях, когда вызов \fBselect\fP(2) говорит, что сокет
находится в состоянии "исключительной ситуации".)

Следующее верно для ядер 2.6.x, до 2.6.11 включительно:
.RS
.IP
.\" The relevant place in the (2.6) kernel source is the
.\" 'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
.\" send_sigurg()/send_sigurg_to_task() bypasses
.\" kill_fasync()/send_sigio()/send_sigio_to_task()
.\" to directly call send_group_sig_info()
.\"	-- MTK, Apr 2005 (kernel 2.6.11)
Если для \fBF_SETSIG\fP передаётся ненулевое значение в многонитивой процесс,
работающий с библиотекой нитей (например, NPTL), которая обеспечивает
поддержку групп нитей, то положительное значение, переданное \fBF_SETOWN\fP,
имеет другой смысл: вместо указания ID процесса, описывающего весь процесс,
она является ID нити, указывающим на определённую нить процесса. Поэтому
может понадобиться передать в \fBF_SETOWN\fP результат \fBgettid\fP(2), а не
\fBgetpid\fP(2), чтобы получить правильный результат при использовании
\fBF_SETSIG\fP. (В имеющихся реализациях Linux ID главной нити совпадает с ID
процесса. Это означает, что в программе с одной нитью можно использовать
любой вызов, \fBgettid\fP(2) или \fBgetpid\fP(2), в этом случае.) Однако заметим,
что утверждения этого абзаца не применимы к сигналу \fBSIGURG\fP, генерируемому
для внеполосных данных сокета: этот сигнал всегда посылается или процессу
или группе процессов, в зависимости от значения, указанного для \fBF_SETOWN\fP.
.RE
.IP
Описанное выше поведение было случайно удалено из Linux 2.6.12, и так и не
восстановлено. Начиная с Linux 2.6.32 используйте \fBF_SETOWN_EX\fP при
назначении сигналов \fBSIGIO\fP и \fBSIGURG\fP для определённой нити.
.TP 
\fBF_GETOWN_EX\fP (struct f_owner_ex *) (начиная с Linux 2.6.32)
Получить настройки владения текущим файловым дескриптором, установленные
предыдущей командой \fBF_SETOWN_EX\fP. Информация возвращается в структуре,
указанной в \fIarg\fP, которая имеет следующий вид:
.nf
.in +4n

struct f_owner_ex {
    int   type;
    pid_t pid;
};

.in
.fi
Поле \fItype\fP будет равно: \fBF_OWNER_TID\fP, \fBF_OWNER_PID\fP или
\fBF_OWNER_PGRP\fP. Значением поля \fIpid\fP будет положительное целое,
представляющее ID нити, ID процесса или ID группы процессов. Подробности
смотрите в описании \fBF_SETOWN_EX\fP.
.TP 
\fBF_SETOWN_EX\fP (struct f_owner_ex *) (начиная с Linux 2.6.32)
Эта команда выполняет задачу, подобную \fBF_SETOWN\fP. Она позволяет
вызывающему назначить сигналы доступности ввода\-вывода определённой нити,
процессу или группе процессов. Вызывающий указывает приёмник сигналов в
\fIarg\fP, выражаемый указателем на структуру \fIf_owner_ex\fP. Поле \fItype\fP имеет
одно из следующих значений, которое определяет чем считать \fIpid\fP:
.RS
.TP 
\fBF_OWNER_TID\fP
Посылать сигнал нити, чей ID (значение, возвращаемое вызовом \fBclone\fP(2) или
\fBgettid\fP(2)) указан в \fIpid\fP.
.TP 
\fBF_OWNER_PID\fP
Посылать сигнал процессу, чей ID указан в \fIpid\fP.
.TP 
\fBF_OWNER_PGRP\fP
Посылать сигнал группе процессов, чей ID указан в \fIpid\fP. (Заметим, что в
отличие от \fBF_SETOWN\fP, ID группы процессов здесь задаётся как положительное
значение.)
.RE
.TP 
\fBF_GETSIG\fP (\fIvoid\fP)
Получить (как результат функции) сигнал, посылаемый, когда становится
возможным ввод или вывод. Значение 0 означает сигнал \fBSIGIO\fP. Любое другое
значение (включая \fBSIGIO\fP) является другим сигналом, и в этом случае для
обработчика сигнала доступна дополнительная информация, если он был
установлен с \fBSA_SIGINFO\fP. Аргумент \fIarg\fP игнорируется.
.TP 
\fBF_SETSIG\fP (\fIint\fP)
.\"
.\" The following was true only up until 2.6.11:
.\"
.\" Additionally, passing a nonzero value to
.\" .B F_SETSIG
.\" changes the signal recipient from a whole process to a specific thread
.\" within a process.
.\" See the description of
.\" .B F_SETOWN
.\" for more details.
Установить сигнал, который будет посылаться когда станет возможен ввод или
вывод, в значение, указанное в \fIarg\fP. Значение 0 означает сигнал по
умолчанию \fBSIGIO\fP. Любое другое значение (включая \fBSIGIO\fP) является другим
сигналом, и в этом случае, для обработчика сигнала доступна дополнительная
информация, если он был установлен с \fBSA_SIGINFO\fP.

В случае использования \fBF_SETSIG\fP с ненулевым значением и установкой
\fBSA_SIGINFO\fP для обработчика сигнала (см. \fBsigaction\fP(2)) обработчику
передаётся дополнительная информация о событиях ввода/вывода в структуре
\fIsiginfo_t\fP. Если поле \fIsi_code\fP показывает, что источник \(em
\fBSI_SIGIO\fP, то поле \fIsi_fd\fP содержит файловый дескриптор, ассоциированный
с событием. В противном случае не существует никакого механизма, чтобы
сообщить с каким файловым дескриптором связан полученный сигнал, и вы должны
использовать обычные механизмы (\fBselect\fP(2), \fBpoll\fP(2), \fBread\fP(2) с
установленным \fBO_NONBLOCK\fP и т.д.), чтобы определить какой файловый
дескриптор доступен для ввода/вывода.

При выборе сигнала реального времени (значение >= \fBSIGRTMIN\fP) в очередь
может добавляться несколько событий ввода\-вывода с одинаковыми номерами
сигналов. (Размер очереди зависит от доступной памяти). Дополнительная
информация будет доступна как описано выше, если для обработчика сигнала
будет установлено \fBSA_SIGINFO\fP.

.\" See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
Заметим, что в Linux есть предел на количество сигналов реального времени,
которые могут находиться в очереди процесса (см. \fBgetrlimit\fP(2) и
\fBsignal\fP(7)), и если этот предел достигнут, то ядро изменяет пункт доставки
\fBSIGIO\fP, и этот сигнал доставляется всему процессу, а не указанной нити.
.PP
Используя эти механизмы, программа может реализовать полностью асинхронный
ввод\-вывод почти не используя в своей работе \fBselect\fP(2) или \fBpoll\fP(2).
.PP
Использование \fBO_ASYNC\fP, \fBF_GETOWN\fP, \fBF_SETOWN\fP является специфичным для
BSD и Linux. Команды \fBF_GETOWN_EX\fP, \fBF_SETOWN_EX\fP, \fBF_GETSIG\fP и
\fBF_SETSIG\fP являются специфичными для Linux. POSIX описывает асинхронный
ввод\-вывод и структуру \fIaio_sigevent\fP, используемую для сходных вещей; она
также доступна в Linux как часть библиотеки GNU C (Glibc).
.SS Аренда
Команды \fBF_SETLEASE\fP и \fBF_GETLEASE\fP (в Linux 2.4 и выше) используются,
соответственно, для установки новой и получения текущей аренды открытого
описания файла, на который указывает файловый дескриптор \fIfd\fP. Аренда файла
предоставляет механизм, посредством которого процесс, который удерживает
аренду («арендатор»), уведомляется (отправкой сигнала), когда процесс
(«нарушитель аренды») пытается выполнить вызов \fBopen\fP(2) или \fBtruncate\fP(2)
на файл, указанный в этом файловом дескрипторе.
.TP 
\fBF_SETLEASE\fP (\fIint\fP)
Установить или удалить аренду файла, в соответствии со значениями,
указываемыми в \fIarg\fP:
.RS
.TP 
\fBF_RDLCK\fP
.\" The following became true in kernel 2.6.10:
.\" See the man-pages-2.09 Changelog for further info.
Установить аренду чтения. Это приведёт к генерации уведомления вызывающего
процесса, когда файл открывается для записи или усечения. Аренда чтения
может быть выделена только на файловый дескриптор, открытый только на
чтение.
.TP 
\fBF_WRLCK\fP
Установить аренду записи. Это приведёт к генерации уведомления вызывающего
процесса, когда файл открывается для чтения или записи или выполняется его
усечение. Аренда записи может быть установлена на файл, только если этот
файл не имеет других открытых файловых дескрипторов.
.TP 
\fBF_UNLCK\fP
Удалить аренду с указанного файла.
.RE
.P
Аренды ассоциируются с открытым файловым описанием (см. \fBopen\fP(2)). Это
значит, что дублированные файловые дескрипторы (созданные, например,
\fBfork\fP(2) или \fBdup\fP(2)) указывают на одну и ту же аренду, и эта аренда
может изменяться или освобождаться через любой из этих дескрипторов. Более
того, аренда освобождается или через явную команду \fBF_UNLCK\fP на любом из
этих дублированных дескрипторов, или когда все эти дескрипторы будут
закрыты.
.P
Аренды могут быть выданы только на обычные файлы. Непривилегированный
процесс может получить аренду только на файл, чей UID (владельца) совпадает
с UID на файловой системе процесса. Процесс с мандатом \fBCAP_LEASE\fP может
получить аренду на любые файлы.
.TP 
\fBF_GETLEASE\fP (\fIvoid\fP)
Узнать какой тип аренды ассоциирован с файловым дескриптором \fIfd\fP;
возвращается одно из значений \fBF_RDLCK\fP, \fBF_WRLCK\fP или \fBF_UNLCK\fP,
соответственно означающих аренду на чтение, запись или что аренды
нет. Аргумент \fIarg\fP игнорируется.
.PP
Когда процесс («нарушителя аренды») выполняет вызов \fBopen\fP(2) или
\fBtruncate\fP(2), который конфликтует с арендой, установленной через
\fBF_SETLEASE\fP, то системный вызов блокируется ядром и ядро уведомляет
арендатора сигналом (по умолчанию \fBSIGIO\fP). Арендатор должен при получении
этого сигнала выполнить все необходимые действия по очистке для подготовки
этого файла к использованию другим процессом (например, сбросить буферы
кэша) и затем удалить или снизить условия аренды. Аренда удаляется по
команде \fBF_SETLEASE\fP с аргументом \fIarg\fP, установленным в \fBF_UNLCK\fP. Если
арендатор удерживает аренду на запись в файл, и нарушитель аренды открывает
файл на чтение, то достаточно того, что арендатор понизит условия аренды до
аренды на чтение. Это выполняется командой \fBF_SETLEASE\fP с аргументом
\fIarg\fP, установленным в \fBF_RDLCK\fP.

Если арендатор не освободит аренду или не снизит условия в течении
определённого количества секунд, указанного в файле
\fI/proc/sys/fs/lease\-break\-time\fP, то ядро принудительно удалит или снизит
условия аренды для арендатора.

После того, как был начат разрыв аренды, \fBF_GETLEASE\fP возвращает тип
назначения аренды (или \fBF_RDLCK\fP или \fBF_UNLCK\fP, в зависимости от
необходимости совместимости с нарушителем аренды) до тех пор, пока держатель
аренды добровольно не отдаст или не удалит аренду или ядро принудительно не
сделает это после истечения таймера разрыва аренды.

После того как аренда снята держателем аренды или принудительно удалена и
снижены условия, и предполагая, что нарушитель аренды не выполнял
неблокирующий системный вызов, ядро позволяет продолжить работу системного
вызова нарушителя аренды.

Если нарушитель аренды, заблокированный в \fBopen\fP(2) или \fBtruncate\fP(2),
прерывается обработчиком сигнала, то системный вызов завершается неудачно с
ошибкой \fBEINTR\fP, но другие шаги по\-прежнему выполняются как описано
ранее. Если нарушитель аренды завершается по сигналу будучи блокированным в
\fBopen\fP(2) или \fBtruncate\fP(2), то другие шаги по\-прежнему выполняются как
описано ранее. Если нарушитель аренды указал флаг \fBO_NONBLOCK\fP при вызове
\fBopen\fP(2), то вызов немедленно завершается неудачей с ошибкой
\fBEWOULDBLOCK\fP, но другие шаги по\-прежнему выполняются как описано ранее.

По умолчанию, для уведомления арендатора используется сигнал \fBSIGIO\fP, но
его можно изменить, используя команду \fBF_SETSIG\fP для \fBfcntl\fP(). Если
выполняется команда \fBF_SETSIG\fP (даже назначая сигнал \fBSIGIO\fP), и при этом
обработчик сигнала устанавливается с использованием \fBSA_SIGINFO\fP, то
обработчик получит в качестве второго аргумента структуру \fIsiginfo_t\fP, в
которой поле \fIsi_fd\fP будет содержать дескриптор арендованного файла, к
которому пытается получить доступ другой процесс. (Это полезно, если
вызывающий процесс удерживает аренду на несколько файлов).
.SS "Уведомления об изменении файла и каталога (dnotify)"
.TP 
\fBF_NOTIFY\fP (\fIint\fP)
(Начиная с Linux 2.4) Уведомлять при смене каталога, на который указывает
\fIfd\fP или когда изменились файлы, которые в нём содержатся. События, о
наступлении которых делается уведомление, задаются в аргументе \fIarg\fP,
который является битовой маской, получаемой сложением (OR) одного или более
следующих бит:
.RS
.sp
.PD 0
.TP  12
\fBDN_ACCESS\fP
Был произведён доступ к файлу (read, pread, readv).
.TP 
\fBDN_MODIFY\fP
Файл был изменён (write, pwrite, writev, truncate, ftruncate).
.TP 
\fBDN_CREATE\fP
Файл был создан (open, creat, mknod, mkdir, link, symlink, rename).
.TP 
\fBDN_DELETE\fP
Файл был удалён (unlink, rename to another directory, rmdir).
.TP 
\fBDN_RENAME\fP
Файл был переименован внутри каталога (rename).
.TP 
\fBDN_ATTRIB\fP
У файла были изменены атрибуты (chown, chmod, utime[s]).
.PD
.RE
.IP
(Чтобы получить эти определения, нужно задать макрос тестирования свойств
\fB_GNU_SOURCE\fP перед \fIвсеми\fP остальными заголовочными файлами.)

Уведомления об изменении состояния каталога обычно однократные и приложение
должно перерегистрировать установку уведомлений, чтобы и дальше получать
их. Однако, если в аргумент \fIarg\fP, добавить \fBDN_MULTISHOT\fP, то уведомления
будут приходить до тех пор, пока не будут явно отменены.

.\" The following does seem a poor API-design choice...
Серии запросов \fBF_NOTIFY\fP добавляются к событиям в \fIarg\fP, которые уже
установлены. Чтобы выключить уведомления всех событий, выполните вызов
\fBF_NOTIFY\fP, указав 0 в \fIarg\fP.

Уведомления выполняются через доставку сигнала. По умолчанию это \fBSIGIO\fP,
но вы можете изменить его, используя команду \fBF_SETSIG\fP для вызова
\fBfcntl\fP(). В последнем случае, обработчик сигнала принимает в качестве
второго аргумента структуру \fIsiginfo_t\fP (если обработчик был установлен с
помощью \fBSA_SIGINFO\fP), а поле \fIsi_fd\fP в этой структуре содержит дескриптор
файла, для которого было сгенерировано уведомление (полезно, когда
устанавливается уведомление для нескольких каталогов).

Кроме того, когда используется \fBDN_MULTISHOT\fP, для уведомлений должен бы
быть использован сигнал реального времени, так что множественные уведомления
могут быть поставлены в очередь.

\fBЗАМЕЧАНИЕ:\fP В новых приложениях нужно использовать интерфейс \fIinotify\fP
(доступен начиная с ядра 2.6.13), который предоставляет намного лучший
интерфейс для получения уведомлений о событиях в файловой системе. Смотрите
\fBinotify\fP(7).
.SS "Изменение ёмкости канала"
.TP 
\fBF_SETPIPE_SZ\fP (\fIint\fP; начиная с Linux 2.6.35)
Изменяет ёмкость канала, на который указывает \fIfd\fP; она становится равной
не менее \fIarg\fP байт. Непривилегированный процесс может подстроить ёмкость
канала до любого значения начиная с размера системной страницы до предела,
заданного в \fI/proc/sys/fs/pipe\-max\-size\fP (см. \fBproc\fP(5)). При задании
ёмкости меньше размера страницы, она будет без ошибок округлена до размера
страницы. При задании непривилегированным процессом ёмкости канала больше
предела из \fI/proc/sys/fs/pipe\-max\-size\fP приведёт к ошибке \fBEPERM\fP;
привилегированный процесс (с \fBCAP_SYS_RESOURCE\fP) может превысить этот
ограничение. При выделении буфера под канал ядро может использовать ёмкость
больше чем указано в \fIarg\fP, если это удобно в реализации. По команде
\fBF_GETPIPE_SZ\fP возвращается реально использованный размер. Попытка
установить ёмкость канала меньше чем количество пространства в буфере, в
настоящее время используемого для хранения данных, приведёт к ошибке
\fBEBUSY\fP.
.TP 
\fBF_GETPIPE_SZ\fP (\fIvoid\fP; начиная с Linux 2.6.35)
Возвращает (как результат функции) ёмкость канала, указываемого \fIfd\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении возвращаемое значение зависит от используемой
команды:
.TP  0.9i
\fBF_DUPFD\fP
Новый дескриптор.
.TP 
\fBF_GETFD\fP
Значение флагов файлового дескриптора.
.TP 
\fBF_GETFL\fP
Значение флагов состояния файла.
.TP 
\fBF_GETLEASE\fP
Тип аренды, установленной на файлом дескрипторе.
.TP 
\fBF_GETOWN\fP
Значение, представляющее собой владельца дескриптора.
.TP 
\fBF_GETSIG\fP
Значение сигнала, посылаемого когда становится возможным чтение или запись
или ноль для традиционного поведения \fBSIGIO\fP.
.TP 
\fBF_GETPIPE_SZ\fP
Ёмкость канала.
.TP 
Все остальные команды
Ноль.
.PP
В случае ошибки возвращается \-1 и значение \fIerrno\fP устанавливается
соответствующим образом.
.SH ОШИБКИ
.TP 
\fBEACCES\fP или \fBEAGAIN\fP
Операция запрещена блокировками, которые удерживаются другими процессами.
.TP 
\fBEAGAIN\fP
Операция запрещена, потому что файл отображается в память другим процессом.
.TP 
\fBEBADF\fP
Значение \fIfd\fP не является открытым файловым дескриптором или была указана
команда \fBF_SETLK\fP или \fBF_SETLKW\fP, но режим открытия файлового дескриптора
не совпадает с типом запрошенной блокировки.
.TP 
\fBEDEADLK\fP
Было обнаружено, что указанная команда \fBF_SETLKW\fP привела бы к взаимной
блокировке (deadlock).
.TP 
\fBEFAULT\fP
Значение \fIlock\fP находится за пределами доступного адресного пространства.
.TP 
\fBEINTR\fP
Выполнение команды \fBF_SETLKW\fP было прервана сигналом,
см. \fBsignal\fP(7). Выполнение команд \fBF_GETLK\fP и \fBF_SETLK\fP было прервано
сигналом перед тем как блокировка была проверена или
установлена. Большинство таких ошибок случается при блокировке удалённого
файла (например, блокировка через NFS), но иногда такое может случаться и
локально.
.TP 
\fBEINVAL\fP
При выполнении команды \fBF_DUPFD\fP значение \fIarg\fP отрицательное или больше
максимально возможного значения. При выполнении \fBF_SETSIG\fP значение \fIarg\fP
не содержит допустимый номер сигнала.
.TP 
\fBEMFILE\fP
При выполнении команды \fBF_DUPFD\fP процесс достиг максимального количества
открытых файловых дескрипторов.
.TP 
\fBENOLCK\fP
Открыто слишком много блокировок сегментов, таблица блокировок заполнена или
ошибка протокола удалённой блокировки (например, при блокировке через NFS).
.TP 
\fBEPERM\fP
Попытка сбросить флаг \fBO_APPEND\fP на файле, который открыт с атрибутом
только для добавления.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
SVr4, 4.3BSD, POSIX.1\-2001. В POSIX.1\-2001 указаны только команды
\fBF_DUPFD\fP, \fBF_GETFD\fP, \fBF_SETFD\fP, \fBF_GETFL\fP, \fBF_SETFL\fP, \fBF_GETLK\fP,
\fBF_SETLK\fP и \fBF_SETLKW\fP.

\fBF_GETOWN\fP и \fBF_SETOWN\fP указаны в POSIX.1\-2001. (Для получения их
определений, определите \fBBSD_SOURCE\fP или \fB_XOPEN_SOURCE\fP со значением 500
или больше, или определите \fB_POSIX_C_SOURCE\fP со значением 200809L или
больше.)

\fBF_DUPFD_CLOEXEC\fP указана в POSIX.1\-2008.  (Для получения определения,
определите \fB_POSIX_C_SOURCE\fP со значением 200809L или больше, или
\fB_XOPEN_SOURCE\fP со значением 700 или больше.)

.\" .PP
.\" SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
Команды \fBF_GETOWN_EX\fP, \fBF_SETOWN_EX\fP, \fBF_SETPIPE_SZ\fP, \fBF_GETPIPE_SZ\fP,
\fBF_GETSIG\fP, \fBF_SETSIG\fP, \fBF_NOTIFY\fP, \fBF_GETLEASE\fP и \fBF_SETLEASE\fP есть
только в Linux. (Для задействования этих определений определите макрос
\fB_GNU_SOURCE\fP.)
.SH ЗАМЕЧАНИЯ
Первоначальная версия системного вызова \fBfcntl\fP() в Linux не умела работать
с большими файловыми смещениями (в структуре \fIflock\fP). Позднее, в Linux 2.4
был добавлен системный вызов \fBfcntl64\fP(). Новый системный вызов использует
другую структуру для блокировки файлов \(em \fIflock64\fP и соответствующие
команды \(em \fBF_GETLK64\fP, \fBF_SETLK64\fP и \fBF_SETLKW64\fP. Однако, это
различие может игнорироваться приложениями, которые используют glibc, так
как имеющаяся в ней обёрточная функция \fBfcntl\fP() самостоятельно задействует
более новый системный вызов, если он доступен.

Ошибки, возвращаемые \fBdup2\fP(2), отличаются от тех, что возвращаются при
\fBF_DUPFD\fP.

Начиная с ядра 2.0, не существует разницы между типами блокировки, которые
осуществляют \fBflock\fP(2) и \fBfcntl\fP().

.\" e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
.\" documents it in fcntl(5).  mtk, May 2007
Некоторые системы имеют дополнительные поля в структуре \fIstruct flock\fP,
например, \fIl_sysid\fP. Вообще\-то, один \fIl_pid\fP не очень\-то полезен, если
процесс, удерживающий блокировку, может работать на другой машине.
.SH ДЕФЕКТЫ
.\" glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
.\" mtk, Dec 04: some limited testing on alpha and ia64 seems to
.\" indicate that ANY negative PGID value will cause F_GETOWN
.\" to misinterpret the return as an error. Some other architectures
.\" seem to have the same range check as i386.
Ограничение в соглашениях по системным вызовам Linux на некоторых
архитектурах (в частности i386) приводит к тому, что если значение ID группы
процесса (отрицательное), возвращаемое по команде \fBF_GETOWN\fP, попадает в
диапазон от \-1 до \-4095, то оно неправильно интерпретируется glibc и
считается ошибкой в системном вызове; то есть возвращаемое значение
\fBfcntl\fP() будет равно \-1, а \fIerrno\fP будет содержать значение ID группы
процесса (положительное). Команда \fBF_GETOWN_EX\fP (есть только в Linux) не
подвержена этой проблеме. Начиная с glibc версии 2.11, glibc делает проблему
для \fBF_GETOWN\fP невидимой, реализовав \fBF_GETOWN\fP с помощью \fBF_GETOWN_EX\fP.

В Linux 2.4 и более раннем, есть ошибка, которая может произойти когда
непривилегированный процесс использует \fBF_SETOWN\fP для задания владельца
дескриптора файла сокета как процесса (группу) отличного от вызывающего. В
этом случае \fBfcntl\fP() может вернуть \-1 с \fIerrno\fP равным \fBEPERM\fP, даже
когда процесс (группа) владелец такая же как и вызывающий имеет право
посылать сигнал. Несмотря на возвращаемую ошибку, владелец файлового
дескриптора всё равно устанавливается и сигналы будут посылаться владельцу.

.\" http://marc.info/?l=linux-kernel&m=119013491707153&w=2
Реализация обязательной блокировки во всех известных версиях Linux проводит
к состязательности процессов, что делает её ненадёжной: вызов \fBwrite\fP(2),
пересекающийся с блокировкой, может изменить данные после установления
обязательной блокировки; вызов \fBread\fP(2), пересекающийся с блокировкой,
может обнаружить изменившиеся данные, которые были внесены уже установления
блокировки на запись. Подобная состязательность существует между
обязательными блокировками и \fBmmap\fP(2). Поэтому нецелесообразно полагаться
на обязательную блокировку.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBdup2\fP(2), \fBflock\fP(2), \fBopen\fP(2), \fBsocket\fP(2), \fBlockf\fP(3),
\fBcapabilities\fP(7), \fBfeature_test_macros\fP(7)
.P
Смотрите также файлы \fIlocks.txt\fP, \fImandatory\-locking.txt\fP и \fIdnotify.txt\fP
из каталога с исходным кодом ядра \fIDocumentation/filesystems/\fP. (В старых
ядрах эти файлы были в каталоге \fIDocumentation/\fP, а
\fImandatory\-locking.txt\fP назывался \fImandatory.txt\fP.)

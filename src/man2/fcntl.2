.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" This manpage is Copyright (C) 1992 Drew Eckhardt;
.\"                               1993 Michael Haardt, Ian Jackson;
.\"                               1998 Jamie Lokier.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one
.\" 
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\" 
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.

.\"
.\" Modified Sat Jul 24 13:39:26 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified Tue Sep 26 21:47:21 1995 by Andries Brouwer <aeb@cwi.nl>
.\" and again on 960413 and 980804 and 981223.
.\" Modified Fri Dec 11 17:57:27 1998 by Jamie Lokier <jamie@imbolc.ucc.ie>
.\"
.TH FCNTL 2 "12 July 1999" "Linux" "Руководство программиста Linux"
.SH НАЗВАНИЕ
fcntl \- манипуляция файловым дескриптором
.SH КРАТКАЯ СВОДКА
.nf
.B #include <unistd.h>
.B #include <fcntl.h>
.sp
.BI "int fcntl(int " fd ", int " cmd );
.BI "int fcntl(int " fd ", int " cmd ", long " arg );
.BI "int fcntl(int " fd ", int " cmd ", struct flock *" lock );
.fi
.SH ОПИСАНИЕ
.B fcntl
выполняет одну из разнообразных операций с файловым дескриптором
.IR fd .
Какую именно -- определяется параметром
.IR cmd :
.TP 0.9i
.B F_DUPFD
Ищет первый доступный файловый дескриптор, больший или равный
.IR arg ,
и делает его копией
.IR fd .
.sp
Это поведение отличается от 
.BR dup2 (2),
которая использует именно заданный файловый дескриптор.
.sp
Старый и новый дескриптор могут использоваться друг вместо друга.  У
них общие блокировки, положение указателя в файле и флаги; например,
если положение указателя изменяется с помощью
.B lseek
на одном из дескрипторов, то оно также меняется на другом.
.sp
Два дескриптора, однако, не делят флаг закрыть-при-exec.  У копии этот
флаг будет установлен в ноль, означая, что он не будет закрыт при
выполнении exec.
.sp
При успешном завершении возвращается новый дескриптор.
.TP
.B F_GETFD
Получить состояние флага закрыть-при-exec.  Если бит
.B FD_CLOEXEC
результата равен нулю, то файл будет оставаться открытым после
выполнения
.BR exec ,
в противном случае он закроется.
.TP
.B F_SETFD
Установить флаг закрыть-при-exec, как указано в бите
.B FD_CLOEXEC
параметра
.IR arg .
.TP
.B F_GETFL
Прочитать флаги дескриптора (возвращаются все флаги, установленные при 
помощи
.BR open (2)).
.TP
.B F_SETFL
Установить флаги дескриптора в значение, заданное при помощи
.IR arg .
Можно установить только флаги
.BR O_APPEND ", " O_NONBLOCK " и " O_ASYNC ,
прочие флаги не будут затронуты.
.sp
Флаги являются общими для копий файлового дескриптора, сделанных с
помощью
.BR dup "(2), " fork (2),
и т.\~д.
.sp
Флаги и их семантика описаны в
.BR open (2).
.P
.BR F_GETLK ", " F_SETLK " и " F_SETLKW
используются для управления "мягкими" файловыми блокировками.  Третий
аргумент,
.IR lock ,
является указателем на 
.B struct flock
(которая может быть перезаписана этим системным вызовом).
.TP
.B F_GETLK
Возвращает структуру
.BR flock ,
которая мешает нам получить свою собственную блокировку, или
установить поле
.B l_type
в значение
.BR F_UNLCK ,
если других блокировок нет.
.TP
.B F_SETLK
Блокировка устанавливается (если поле
.B l_type
равно
.B F_RDLCK
или
.BR F_WRLCK )
или очищается (если это поле равно
.BR F_UNLCK ).
Если блокировка установлена кем-то ещё, этот вызов возвращает \-1 и
устанавливает
.I errno
в
.BR EACCESS " или " EAGAIN .
.TP
.B F_SETLKW
Аналогично
.BR F_SETLK ,
только вместо возвращения кода ошибки ожидает, пока блокировка не
будет снята.  Если в процессе ожидания приходит сигнал, то системный
вызов прерывается и, после того, как отработал обработчик сигнала,
немедленно возвращает \-1 и устанавливает
.I errno
в
.BR EINTR .
.P
.BR F_GETOWN ", " F_SETOWN ", " F_GETSIG " и " F_SETSIG
используются для управления сигналами доступности ввода/вывода:
.TP
.B F_GETOWN
Получить идентификатор процесса или группы процессов, получающих
сигналы
.BR SIGIO " и " SIGURG
для событий на файловом дескрипторе
.IR fd .
Группы процессов возвращаются как отрицательные значения.
.TP
.B F_SETOWN
Установить идентификатор процесса или группы процессов, которые будут
получать сигналы
.BR SIGIO " и " SIGURG
для событий на файловом дескрипторе
.IR fd .
Группы процессов задаются как отрицательные значения.
.RB ( F_SETSIG
может использоваться для задания другого сигнала вместо
.BR SIGIO ).

.\" Из glibc.info:
Если вы установите флаг
.B O_ASYNC
на файловом дескрипторе (передав этот флаг при вызове
.IR open (2)
или используя команду
.B F_SETFL
при вызове
.BR fcntl ),
то сигнал SIGIO будет посылаться каждый раз, когда на этом файловом
дескрипторе становится возможен ввод и вывод.
.sp
Процесс или группа процессов, которые будут получать сигнал, могут
быть выбраны с помощью команды
.B F_SETOWN
функции 
.BR fcntl .
Если файловый дескриптор -- это сокет, то при этом будет также выбран
адресат сигналов SIGURG, которые посылаются, когда по сокету приходят
данные вне основного канала.  (SIGURG отсылается в любой ситуации,
когда
.BR select (2)
сообщила бы, что в сокете наличествует "исключительная ситуация".)
Если файловый дескриптор соответствует терминальному устройству, то сигналы
SIGIO посылаются группе процессов на терминале, выполняющихся не в
фоне.
.TP
.B F_GETSIG
Узнать, какой сигнал посылается, когда становится возможным ввод или
вывод.   Ноль означает, что посылается SIGIO.  Любое другое значение
(включая SIGIO) -- это сигнал, который посылается вместо SIGIO, в этом 
случае доступна дополнительная информация, если обработчик сигнала был 
установлен с использованием
.BR SA_SIGINFO .
.TP
.B F_SETSIG
Задает сигнал, который посылается, когда становится возможным ввод или 
вывод.  Значение ноль означает, что нужно посылать стандартный сигнал
SIGIO.  Любое другое значение (включая SIGIO), означает, что нужно
послать другой сигнал, и в этом случае также доступна дополнительная
информация, если обработчик сигнала был установлен с SA_SIGINFO.
.sp
Используя F_SETSIG вместе с ненулевым значением и задавая обработчику
сигнала флаг SA_SIGINFO (см.
.BR sigaction (2)),
можно передать этому обработчику дополнительную информацию о событиях
ввода-вывода с помощью структуры
.IR siginfo_t .
Если поле
.I si_code
задает, что источником является SI_SIGIO, то
поле
.I si_fd
содержит файловый дескриптор, на котором произошло событие.  В
противном случае нет прямого указания, какие именно файловые
дескрипторы участвуют в происходящем, поэтому нужно использовать
обычные механизмы
.RB ( select "(2), " poll "(2), " read "(2) с флагом " O_NONBLOCK ,
и так далее), чтобы определить, для каких дескрипторов доступен
ввод-вывод.
.sp
Выбрав сигнал реального времени, соответствующий стандарту POSIX
(значение >= SIGRTMIN), можно использовать очереди из множества
событий ввода-вывода, использующих один и тот же номер сигнала.
(Построение очереди зависит от доступной памяти).  Дополнительная
информация доступна, если для обработчика установлен SA_SIGINFO, как
описано выше.
.PP
Используя эти механизмы, можно реализовать полностью асинхронный
ввод-вывод без использования, по большей части,
.BR select (2)
или 
.BR poll (2).
.PP
Использование
.BR O_ASYNC ,
.BR F_GETOWN ,
.B F_SETOWN
специфично для систем BSD и Linux.
.B F_GETSIG
и
.B F_SETSIG
специфичны для Linux.  POSIX включает в себя асинхронный ввод-вывод и
структуру
.IR aio_sigevent ,
с помощью которой достигаются подобные вещи;  они также доступны под
Linux как часть библиотеки GNU C (Glibc).
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном завершении возвращаемое значение зависит от операции:
.TP 0.9i
.B F_DUPFD
Новый дескриптор.
.TP
.B F_GETFD
Значение флага.
.TP
.B F_GETFL
Значение флагов.
.TP
.B F_GETOWN
Владелец дескриптора.
.TP
.B F_GETSIG
Номер сигнала, который посылается, когда появляется возможность читать 
или писать, или же ноль, означающий традиционное поведение, сигнал
SIGIO.
.TP
Все другие команды
Нуль.
.PP
При ошибке возвращается \-1, а
.I errno
устанавливается должным образом.
.SH ОШИБКИ

.TP 0.9i
.B EACCES
Операция запрещена блокировкой, установленной другим процессом.
.TP
.B EAGAIN
Операция запрещена, потому что файл был отображен в память другим
процессом.
.TP
.B EBADF
.I fd
не является открытым файловым дескриптором.
.TP
.B EDEADLK
Обнаружено, что заданная команда
.B F_SETLKW
вызвала бы мертвую блокировку.
.TP
.B EFAULT
.I lock
указывает за пределы доступного адресного пространства.
.TP
.B EINTR
Команда
.BR F_SETLKW
была прервана сигналом.  Команды
.BR F_GETLK " и " F_SETLK ,
были прерваны сигналом, пока блокировка еще не была проверена или
установлена.  Чаще всего случается при блокировке сетевого файла
(например, при работе с NFS), но иногда может случиться и локально.
.TP
.B EINVAL
Команда
.BR F_DUPFD :
.I arg
отрицателен или больше, чем максимально разрешенное значение.
Команда
.BR F_SETSIG :
.I arg
не является разрешенным номером сигнала.
.TP
.B EMFILE
Команда
.BR F_DUPFD :
процесс уже открыл максимальное количество файловых дескрипторов.
.TP
.B ENOLCK
Открыто слишком много сегментных блокировок, таблица блокировок полна
или же произошла ошибка при сетевой блокировке (при работе с NFS).
.TP
.B EPERM
Попытка очистить флаг
.B O_APPEND
на файле, имеющем атрибут "только-добавление".
.SH ЗАМЕЧАНИЯ
Ошибки, которые возвращает
.BR dup2 ,
отличаются от тех, что возвращает
.BR F_DUPFD .
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
SVr4, SVID, POSIX, X/OPEN, BSD 4.3.  В POSIX.1 указаны только операции
F_DUPFD, F_GETFD, F_SETFD, F_GETFL, F_SETFL, F_GETLK, F_SETLK и
F_SETLKW.  F_GETOWN и F_SETOWN являются BSD-измами, которые не
поддерживаются в SVr4; F_GETSIG и F_SETSIG специфичны для Linux.
Флаги, допустимые для F_GETFL/F_SETFL -- те, что поддерживаются
системным вызовом
.BR open (2),
и они отличаются на разных системах; O_APPEND, O_NONBLOCK, O_RDONLY, и
O_RDWR указаны в POSIX.1.  SVr4 поддерживает несколько других опций и
флагов, не документированных здесь.
.PP
SVr4 документирует дополнительные коды ошибок EIO, ENOLINK и
EOVERFLOW.
.SH "СМОТРИ ТАКЖЕ"
.BR dup2 (2),
.BR flock (2),
.BR open (2),
.BR socket (2),
.SH ПЕРЕВОД
Copyright (C) Alexey Mahotkin <alexm@hsys.msk.ru> 1999

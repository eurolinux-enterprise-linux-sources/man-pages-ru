.\" Page by b.hubert - may be freely modified and distributed
.\"
.\" Niki A. Rahimi (LTC Security Development, narahimi@us.ibm.com)
.\" added ERRORS section.
.\"
.\" Modified 2004-06-17 mtk
.\" Modified 2004-10-07 aeb, added FUTEX_REQUEUE, FUTEX_CMP_REQUEUE
.\"
.\" FIXME See also https://bugzilla.kernel.org/show_bug.cgi?id=14303
.\" 2.6.14 adds FUTEX_WAKE_OP
.\" 2.6.18 adds (Ingo Molnar) priority inheritance support:
.\" FUTEX_LOCK_PI, FUTEX_UNLOCK_PI, and FUTEX_TRYLOCK_PI.  These need
.\" to be documented in the manual page.  Probably there is sufficient
.\" material in the kernel source file Documentation/pi-futex.txt.
.\" 2.6.25 adds FUTEX_WAKE_BITSET, FUTEX_WAIT_BITSET
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH FUTEX 2 2010\-08\-29 Linux "Руководство программиста Linux"
.SH ИМЯ
futex \- системный вызов быстрых блокировок из пространства пользователя
.SH ОБЗОР
.nf
.sp
\fB#include <linux/futex.h>\fP
\fB#include <sys/time.h>\fP
.sp
\fBint futex(int *\fP\fIuaddr\fP\fB, int \fP\fIop\fP\fB, int \fP\fIval\fP\fB, const struct timespec *\fP\fItimeout\fP\fB,\fP
.br
.\" int *? void *? u32 *?
\fB          int *\fP\fIuaddr2\fP\fB, int \fP\fIval3\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
.PP
Системный вызов \fBfutex\fP() предоставляет программам метод для ожидания
изменения значения по указанному адресу памяти и метод для пробуждения всех
ожидающих на определённом адресе (хотя адреса для одного и того же участка
памяти в разных процессах могут быть не идентичны, ядро отображает их
внутренне так, что один участок памяти, отображённый в разные места, будет
соответствовать одним вызовам \fBfutex\fP()). Обычно этот системный вызов
используется для реализации блокировок в общей памяти, как это описано в
\fBfutex\fP(7).
.PP
Когда операция \fBfutex\fP(7) оканчивается без завершения спора в пространстве
пользователя, должен быть сделан вызов к ядру для выноса решения. Решением
может быть как усыпление вызывающего процесса, так и наоборот \(em
пробуждение ожидающего процесса.
.PP
Вызывающие эту функцию должны твердо придерживаться семантики, описанной в
\fBfutex\fP(7). Так как эта семантика приводит к созданию непереносимых
инструкций ассемблера, то фактически это приведёт к тому, что большинство
использующих их пользователей станут авторами библиотек, а не создателями
программ.
.PP
Аргумент \fIuaddr\fP должен указывать на выровненное целое, хранящее
счетчик. Тип операции для исполнения указывает в параметре \fIop\fP, а её
значение в \fIval\fP.
.PP
В данный момент определены пять операций:
.TP 
\fBFUTEX_WAIT\fP
Эта операция атомарно проверяет, что по адресу \fIuaddr\fP futex все ещё
содержится значение \fIval\fP, и засыпает в ожидании \fBFUTEX_WAKE\fP на этом
адресе futex. Если аргумент \fItimeout\fP не равен NULL, то его содержимое
описывает максимальную задержку ожидания, иначе это время
бесконечно. Аргументы \fIuaddr2\fP и \fIval3\fP игнорируются.

По \fBfutex\fP(7) этот вызов исполняется, если уменьшение счетчика даёт
отрицательное значение (указывая на наличие спора), или будет спать, пока
другой процесс не освободит futex и не выполнит операцию \fBFUTEX_WAKE\fP.
.TP 
\fBFUTEX_WAKE\fP
Эта операция пробуждает не больше \fIval\fP процессов, ожидающих на этом адресе
futex (т.е. внутри \fBFUTEX_WAIT\fP). Аргументы \fItimeout\fP, \fIuaddr2\fP и \fIval3\fP
игнорируются.

По \fBfutex\fP(7) этот вызов исполняется, если увеличение счетчика показало,
что есть ожидающие, как только значение futex стало равным 1 (показывает,
что есть доступные ожидающие).
.TP 
\fBFUTEX_FD\fP (существует до Linux 2.6.25 включительно)
.\" , suitable for .BR poll (2).
Для поддержки асинхронных пробуждений эта операция связывает дескриптор
файла с futex. Если другой процесс выполняет \fBFUTEX_WAKE\fP, то процесс будет
получать номер сигнала, переданный в \fIval\fP. Вызывающий процесс должен
закрыть возвращаемый дескриптор файла после использования. Аргументы
\fItimeout\fP, \fIuaddr2\fP и \fIval3\fP игнорируются.

Для предотвращения состязательности, вызывающий после возврата при
\fBFUTEX_FD\fP должен проверять, не был ли futex увеличен.

Так как по своей природе операция \fBFUTEX_FD\fP приводит к состязательности,
она была удалена из Linux, начиная с версии 2.6.26.
.TP 
\fBFUTEX_REQUEUE\fP (начиная с Linux 2.5.70)
Эта операция была введена для того, чтобы избежать эффекта "громыхающего
стада (thundering herd)", когда используется \fBFUTEX_WAKE\fP и все процессы
просыпаются, чтобы захватить другой futex. Этот вызов пробуждает до \fIval\fP
процессов и повторно ставит в очередь остальных ожидающих futex по адресу
\fIuaddr2\fP. Аргументы \fItimeout\fP и \fIval3\fP игнорируются.
.TP 
\fBFUTEX_CMP_REQUEUE\fP (начиная с Linux 2.6.7)
Чтобы избежать состязательности при \fBFUTEX_REQUEUE\fP, была введена
\fBFUTEX_CMP_REQUEUE\fP. Она похожа на \fBFUTEX_REQUEUE\fP, но сначала проверяет,
что расположенное по адресу \fIuaddr\fP значение всё ещё равно \fIval3\fP. Если
нет, то операция завершается с ошибкой \fBEAGAIN\fP. Аргумент \fItimeout\fP
игнорируется.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
.PP
В зависимости от типа используемой операции при успешном выполнении
возвращаемое значение может иметь разный смысл.
.TP 
\fBFUTEX_WAIT\fP
Если процесс пробуждается по \fBFUTEX_WAKE\fP, то возвращается 0. В случае
истечения срока таймера возвращается с ошибкой \fBETIMEDOUT\fP. Если futex не
был эквивалентен ожидаемому значению, то операция возвращается с ошибкой
\fBEWOULDBLOCK\fP. При сигналах (см. \fBsignal\fP(7)) или других случайных
пробуждениях операция \fBFUTEX_WAIT\fP завершается с ошибкой \fBEINTR\fP.
.TP 
\fBFUTEX_WAKE\fP
Возвращается количество разбуженных процессов.
.TP 
\fBFUTEX_FD\fP
Возвращается новый файловый дескриптор, связанный с futex.
.TP 
\fBFUTEX_REQUEUE\fP
Возвращается количество разбуженных процессов.
.TP 
\fBFUTEX_CMP_REQUEUE\fP
Возвращается количество разбуженных процессов.
.PP
В случае ошибки все операции возвращают \-1, а \fIerrno\fP устанавливается в
соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEACCES\fP
Нет доступа на чтение памяти futex.
.TP 
\fBEAGAIN\fP
При \fBFUTEX_CMP_REQUEUE\fP обнаружено не то значение futex. (Вероятно, это
указывает на состязательность; используйте теперь безопасный \fBFUTEX_WAKE\fP.)
.TP 
\fBEFAULT\fP
Ошибка при получении информации \fItimeout\fP из пользовательского
пространства.
.TP 
\fBEINVAL\fP
Неопределённая операция или ошибка выравнивания страницы.
.TP 
\fBENFILE\fP
Достигнуто максимальное количество открытых файлов в системе.
.TP 
\fBENOSYS\fP
В \fIop\fP задана неверная операция.
.SH ВЕРСИИ
.PP
Начальная поддержка futex была встроена в Linux 2.5.7, но с другой
семантикой, отличающейся от описанной выше. Семантика системного вызова с
четырьмя аргументами, описанная в этой странице, появилась в Linux 2.5.40. В
Linux 2.5.70 был добавлен ещё один аргумент. В Linux 2.6.7 был добавлен
шестой аргумент — захламлено, особенно для архитектуре s390.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данный вызов есть только в Linux.
.SH ЗАМЕЧАНИЯ
.PP
.\" .SH "AUTHORS"
.\" .PP
.\" Futexes were designed and worked on by
.\" Hubertus Franke (IBM Thomas J. Watson Research Center),
.\" Matthew Kirkwood, Ingo Molnar (Red Hat)
.\" and Rusty Russell (IBM Linux Technology Center).
.\" This page written by bert hubert.
Еще раз повторим: в чистом виде futex не являются лёгкой в использовании
абстракцией для конечных пользователей (в glibc нет обёрточных функций для
данного системного вызова). Реализующие их программисты должны иметь хороший
запас знаний об ассемблере и уметь читать исходный код библиотеки futex для
пользовательского пространства, указанной далее.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBfutex\fP(7)
.PP
\fIFuss, Futexes and Furwocks: Fast Userlevel Locking in Linux\fP (доклад на
симпозиума по Linux в Оттаве в 2002 году), доступно как
.br
http://kernel.org/doc/ols/2002/ols2002\-pages\-479\-495.pdf
.PP
Пример библиотеки futex, futex\-*.tar.bz2, доступен на
.br
ftp://ftp.nl.kernel.org/pub/linux/kernel/people/rusty/.

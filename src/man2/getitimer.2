.\" Copyright 7/93 by Darren Senn <sinster@scintilla.santa-clara.ca.us>
.\" Based on a similar page Copyright 1992 by Rick Faith
.\" May be freely distributed
.\" Modified Tue Oct 22 00:22:35 EDT 1996 by Eric S. Raymond <esr@thyrsus.com>
.\" 2005-04-06 mtk, Matthias Lang <matthias@corelatus.se>
.\" 	Noted MAX_SEC_IN_JIFFIES ceiling
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH GETITIMER 2 2009\-03\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
getitimer, setitimer \- считывает или устанавливает значение таймера
интервалов
.SH ОБЗОР
.nf
\fB#include <sys/time.h>\fP
.sp
\fBint getitimer(int \fP\fIwhich\fP\fB, struct itimerval *\fP\fIcurr_value\fP\fB);\fP
.br
\fBint setitimer(int \fP\fIwhich\fP\fB, const struct itimerval *\fP\fInew_value\fP\fB,\fP
\fB              struct itimerval *\fP\fIold_value\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Система предоставляет каждому процессу три таймера интервалов, значение
каждого из которых уменьшается на единицу по истечении установленного
времени. Когда на одном из таймеров истекает время, процессу отправляется
сигнал и таймер (обычно) перезапускается.
.TP  1.5i
\fBITIMER_REAL\fP
уменьшается в режиме реального времени и выдаёт сигнал \fBSIGALRM\fP, когда
значение таймера становится равным 0.
.TP 
\fBITIMER_VIRTUAL\fP
уменьшается только во время работы процесса и выдаёт сигнал \fBSIGVTALRM\fP,
когда значение таймера становится равным 0.
.TP 
\fBITIMER_PROF\fP
уменьшается во время работы процесса и когда система выполняет что\-либо по
заданию процесса. Этот таймер обычно используется вместе с \fBITIMER_VIRTUAL\fP
для профилирования времени работы приложения в пользовательском режиме и
режиме ядра. Когда значение таймера становится равным 0, выдаётся сигнал
\fBSIGPROF\fP.
.LP
Величина, на которую устанавливается таймер, определяется следующими
структурами:
.PD 0
.in +4n
.nf

struct itimerval {
    struct timeval it_interval; /* следующее значение */
    struct timeval it_value;    /* текущее значение */
};

struct timeval {
    long tv_sec;                /* секунды */
    long tv_usec;               /* микросекунды */
};
.fi
.in
.PD
.LP
Функция \fBgetitimer\fP() заполняет структуру, указанную в \fIcurr_value\fP
текущей настройкой таймера, задаваемого \fIwhich\fP (\fBITIMER_REAL\fP,
\fBITIMER_VIRTUAL\fP или \fBITIMER_PROF\fP). Поле \fIit_value\fP устанавливается в
соответствии с тем количеством времени, которое осталось на таймере, или
приравнивается нулю, если таймер выключен. Аналогично устанавливается
\fIit_interval\fP в значение сброса.

Функция \fBsetitimer\fP() устанавливает значение таймера равным величине,
указанной в \fInew_value\fP. Если значение \fIold_value\fP не равно NULL, то в неё
записывается прежнее значение таймера.
.LP
Значения таймеров уменьшаются от величины \fIit_value\fP до нуля, выдаётся
сигнал, и значения вновь устанавливаются равными \fIit_interval\fP. Таймер,
установленный на ноль (его величина \fIit_value\fP равна нулю, или время вышло
и величина \fIit_interval\fP равна нулю), останавливается.
.LP
Величины \fItv_sec\fP и \fItv_usec\fP являются основными при установке таймера.
.LP
Срок на таймерах никогда не заканчивается ранее указанного времени, но может
(чуть\-чуть) опоздать, что зависит от степени разрешения системного таймера и
загрузки системы; смотрите \fBtime\fP(7). (Но смотрите ДЕФЕКТЫ далее.) По
истечении времени будет послан сигнал, а таймер обнулится. Если время
таймера истекает во время работы процесса (всегда, если используется
\fBITIMER_VIRTUAL\fP), то сигнал после создания будет доставлен
немедленно. Иначе отсылка сигнала откладывается на небольшой промежуток
времени, зависящий от степени загруженности системы.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении возвращается 0. В случае ошибки возвращается \-1, а
\fIerrno\fP устанавливается в соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEFAULT\fP
Указатели \fInew_value\fP, \fIold_value\fP или \fIcurr_value\fP являются
некорректными.
.TP 
\fBEINVAL\fP
Значение \fIwhich\fP не равно \fBITIMER_REAL\fP, \fBITIMER_VIRTUAL\fP или
\fBITIMER_PROF\fP; или (начиная с Linux 2.6.22) одно из полей структуры
\fItv_usec\fP, указанной в \fInew_value\fP, содержит значение вне диапазона от 0
до 999999.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
POSIX.1\-2001, SVr4, 4.4BSD (впервые этот вызов появился в 4.2BSD). В
POSIX.1\-2008 вызовы \fBgetitimer\fP() и \fBsetitimer\fP() помечены как устаревшие,
и вместо них рекомендуется использовать программный интерфейс таймеров POSIX
(\fBtimer_gettime\fP(2), \fBtimer_settime\fP(2) и т.д.).
.SH ЗАМЕЧАНИЯ
Потомок, созданный через \fBfork\fP(2), не наследует таймеры интервалов
родителя. При вызове \fBexecve\fP(2) таймеры интервалов сохраняются.

В POSIX.1 не определено взаимодействие между \fBsetitimer\fP() и тремя
интерфейсами: \fBalarm\fP(2), \fBsleep\fP(3) и \fBusleep\fP(3).
.SH ДЕФЕКТЫ
Генерирование и доставка сигнала разделены, и только один экземпляр каждого
сигнала, которые описаны выше, может ожидать передачи в процесс. При очень
большой нагрузке, ожидание таймера \fBITIMER_REAL\fP может завершиться раньше
чем будет доставлен сигнал о предыдущем завершении. Второй сигнал об этом
событии будет потерян.

В ядрах Linux до версии 2.6.16, значения таймеров указывались в мигах. Если
запрашивалась установка таймера в значение, представление в мигах которого
превышало \fBMAX_SEC_IN_JIFFIES\fP (определено в \fIinclude/linux/jiffies.h\fP),
то значение таймера просто урезалось до этого максимального значения. На
Linux/i386 (где, начиная с Linux 2.6.13, по умолчанию миг равен 0.004
секунды), это означало, что максимальное значение таймера приблизительно
равнялось 99.42 дня. Начиная с Linux 2.6.16, в ядрах стали использовать
другое внутреннее представление времени, и этот предел был снят.

.\" 4 Jul 2005: It looks like this bug may remain in 2.4.x.
.\"	http://lkml.org/lkml/2005/7/1/165
В некоторых системах (включая i386), ядра Linux до версии 2.6.12 содержали
дефект, который при определённых условиях приводил к преждевременному
завершению за один миг (jiffy). Этот дефект исправлен в ядре 2.6.12.

.\" Bugzilla report 25 Apr 2006:
.\" http://bugzilla.kernel.org/show_bug.cgi?id=6443
.\" "setitimer() should reject noncanonical arguments"
В POSIX.1\-2001 сказано, что \fBsetitimer\fP() должен завершаться с ошибкой,
если значение \fItv_usec\fP лежит вне диапазона от 0 до 999999. Однако, в ядрах
до версии 2.6.21 включительно, в Linux ошибка не выдаётся, а вместо этого
значение таймера просто подгоняется под соответствующие секунды. Начиная с
ядра 2.6.22, это несоответствие убрано: некорректное значение \fItv_usec\fP
приводит к ошибке \fBEINVAL\fP.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBgettimeofday\fP(2), \fBsigaction\fP(2), \fBsignal\fP(2), \fBtimer_create\fP(2),
\fBtimerfd_create\fP(2), \fBtime\fP(7)

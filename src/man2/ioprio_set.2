.\" This is _*_ nroff _*_ source. Emacs, gimme all those colors :)
.\"
.\" Copyright (c) International Business Machines orp., 2006
.\"
.\" This program is free software; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
.\" the GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program; if not, write to the Free Software
.\" Foundation, Inc., 59 Temple Place, Suite 330, Boston,
.\" MA 02111-1307 USA
.\"
.\" HISTORY:
.\" 2006-04-27, created by Eduardo M. Fleury <efleury@br.ibm.com>
.\" with various additions by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH IOPRIO_SET 2 2008\-07\-09 Linux "Руководство программиста Linux"
.SH ИМЯ
ioprio_get, ioprio_set \- получает/устанавливает класс и приоритет
планирования ввода\-вывода
.SH ОБЗОР
.nf
\fBint ioprio_get(int \fP\fIwhich\fP\fB, int \fP\fIwho\fP\fB);\fP
\fBint ioprio_set(int \fP\fIwhich\fP\fB, int \fP\fIwho\fP\fB, int \fP\fIioprio\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Системные вызовы \fBioprio_get\fP() и \fBioprio_set\fP(), соответственно, получают
и устанавливают класс и приоритет планирования ввода\-вывода одного или более
процессов.

В аргументах \fIwhich\fP и \fIwho\fP задаётся процесс(ы), над которым выполняются
системные вызовы. Аргументом \fIwhich\fP задаётся смысл значения \fIwho\fP; он
может иметь одно из следующих значений:
.TP 
\fBIOPRIO_WHO_PROCESS\fP
В \fIwho\fP указан идентификатор единственного процесса.
.TP 
\fBIOPRIO_WHO_PGRP\fP
В \fIwho\fP указан идентификатор группы процессов, учитываются члены группы
процессов.
.TP 
\fBIOPRIO_WHO_USER\fP
В \fIwho\fP указан идентификатор пользователя, учитываются все процессы,
которые имеют этот реальный идентификатор.
.PP
Если при вызове \fBioprio_get\fP() в \fIwhich\fP указано \fBIOPRIO_WHO_PGRP\fP или
\fBIOPRIO_WHO_USER\fP, и под шаблон \fIwho\fP подходит более одного процесса, то
возвращаемый приоритет будет равен самому высокому значению среди процессов
этой группы. Считается, что один приоритет больше другого, если он
принадлежит более высокому классу процессов (\fBIOPRIO_CLASS_RT\fP является
самым высоким классом приоритетов; \fBIOPRIO_CLASS_IDLE\fP \(em самым низким),
или если оба процесса принадлежат одному классу, то тогда самым высоким
будет приоритет с большим уровнем (меньший номер приоритета, означает более
высокий уровень).

Аргумент \fIioprio\fP, задаваемый в \fBioprio_set\fP(), является битовой маской, в
которой указываются класс планирования и приоритет, назначаемый заданному
процессу(ам). Для компоновки и разделения значений \fIioprio\fP используются
следующие макросы:
.TP 
\fBIOPRIO_PRIO_VALUE(\fP\fIclass\fP\fB, \fP\fIdata\fP\fB)\fP
Этот макрос объединяет заданный класс планирования \fIclass\fP и приоритет
(\fIdata\fP) в значение \fIioprio\fP, которое возвращается как результат макроса.
.TP 
\fBIOPRIO_PRIO_CLASS(\fP\fImask\fP\fB)\fP
Этот макрос из указанной маски \fImask\fP (значение \fIioprio\fP) возвращает
значение класса ввода\-вывода, то есть одно из значений: \fBIOPRIO_CLASS_RT\fP,
\fBIOPRIO_CLASS_BE\fP или \fBIOPRIO_CLASS_IDLE\fP.
.TP 
\fBIOPRIO_PRIO_DATA(\fP\fImask\fP\fB)\fP
Этот макрос из указанной маски \fImask\fP (значение \fIioprio\fP) возвращает
значение приоритета (\fIdata\fP).
.PP
Подробней о классах планирования и приоритетах смотрите в разделе ЗАМЕЧАНИЯ.

Приоритеты ввода\-вывода поддерживаются при операциях чтения и синхронной
(\fBO_DIRECT\fP, \fBO_SYNC\fP) записи. Приоритеты ввода\-вывода не поддерживаются
при асинхронной записи, так как они вызываются вне контекста программы
засоряющей память, и поэтому приоритеты программы не применяются.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении \fBioprio_get\fP() возвращается значение \fIioprio\fP для
процесса с самым высоким приоритетом ввода\-вывода из всех процессов,
подходящих под критерий, указанный в \fIwhich\fP и \fIwho\fP. При ошибке
возвращается \-1, а в \fIerrno\fP содержится код ошибки.
.PP
При успешном выполнении \fBioprio_set\fP() возвращается 0. При ошибке
возвращается \-1, а в \fIerrno\fP содержится код ошибки.
.SH ОШИБКИ
.TP 
\fBEINVAL\fP
Неправильное значение \fIwhich\fP или \fIioprio\fP. Обратитесь к разделу
ЗАМЕЧАНИЯ, в нём приведены доступные классы планировщика и уровни приоритета
\fIioprio\fP.
.TP 
\fBEPERM\fP
У вызывающего процесса нет прав, необходимых для назначения данного
\fIioprio\fP указанному процессу(ам). Более подробную информацию о необходимых
правах \fBioprio_set\fP() можно найти в разделе ЗАМЕЧАНИЯ.
.TP 
\fBESRCH\fP
Не найдено процессов, которые бы соответствовали заданным в \fIwhich\fP и
\fIwho\fP критериям.
.SH ВЕРСИИ
Данные системные вызовы появились в Linux начиная с ядра версии 2.6.13.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данные системные вызовы есть только в Linux.
.SH ЗАМЕЧАНИЯ
В glibc нет обёрточной функции для этих системных вызовов; вызывайте их с
помощью \fBsyscall\fP(2).

Данные системные вызовы действительно работают, если используется
планировщик ввода\-вывода, поддерживающий приоритеты ввода\-вывода. В ядре
2.6.17 такой планировщик только один:  Completely Fair Queuing (CFQ).
.SS "Выбор планировщика ввода\-вывода"
Планировщики ввода\-вывода устанавливаются в каждом устройстве через
специальный файл \fI/sys/block/<устройство>/queue/scheduler\fP.

Используемый в данный момент планировщик ввода\-вывода можно посмотреть через
файловую систему \fI/sys\fP. Например, следующая команда покажет список всех
планировщиков, загруженных в ядро:
.sp
.RS
.nf
$\fB cat /sys/block/hda/queue/scheduler\fP
noop anticipatory deadline [cfq]
.fi
.RE
.sp
Планировщик, работающий на устройстве (в примере \fIhda\fP), указан  в
скобках. Замена планировщика выполняется с помощью записи имени нового
планировщика в этот файл. Например, следующая команда установит планировщик
\fIcfq\fP для устройства \fIhda\fP:
.sp
.RS
.nf
$\fB su\fP
Пароль:
#\fB echo cfq > /sys/block/hda/queue/scheduler\fP
.fi
.RE
.SS "Планировщик ввода\-вывода с полностью справедливой очерёдностью (CFQ)"
Начиная с v3 (т.н. CFQ Time Sliced) в CFQ реализованы уровни nice для
ввода\-вывода, подобно используемым в планировщике ЦП. Эти уровни nice
сгруппированы в три класса планирования, в каждом содержится один и более
уровней приоритета:
.TP 
\fBIOPRIO_CLASS_RT\fP (1)
Класс ввода\-вывода реального времени. Данному классу планирования назначен
самый высокий приоритет по сравнению с другими: процессам с этим классом
всегда предоставляется первоочередной доступ к диску. Поэтому данный класс
следует использовать с осторожностью: одним процессом ввода\-вывода реального
времени можно затормозить все остальные. В классе реального времени есть 8
уровней данных класса (приоритетов), которые уточняют сколько времени нужно
процессу для работы с диском для каждого сервиса. Самый высокий уровень
приоритета реального времени имеет значение 0; самый низкий \(em 7. В
будущем это может измениться и можно будет непосредственно задавать желаемую
скорость обмена данными с диском.
.TP 
\fBIOPRIO_CLASS_BE\fP (2)
Класс лучшего из возможного (best\-effort) планирования, устанавливается по
умолчанию для всех процессов, которым не назначен определённый приоритет
ввода\-вывода. Данными класса (приоритет) определяется пропускная способность
ввода\-вывода процесса. Уровни приоритета данного класса аналогичны значениям
nice для ЦП (см. \fBgetpriority\fP(2)). Уровень приоритета определяет
первоочерёдность относительно других процессов с классом лучшего из
возможного планирования. Уровни приоритета находятся в диапазоне от 0 (самый
высший) до 7 (самый низший).
.TP 
\fBIOPRIO_CLASS_IDLE\fP (3)
Класс свободного (idle) планирования. Процессы, работающие с этим уровнем,
получат время для ввода\-вывода только когда нет обмена с диском процессов с
другими классами. Свободный класс не имеет данных класса. Обратите внимание,
что процесс с этим классом приоритета может испытывать нехватку ресурсов,
если процессы с более высокими приоритетами постоянно обращаются к диску.
.PP
Более подробную информацию о планировщике ввода\-вывода CFQ и пример
программы можно найти в файле \fIDocumentation/block/ioprio.txt\fP.
.SS "Необходимые права для установки приоритетов ввода\-вывода"
Право на изменение приоритета процесса зависит от двух условий:
.TP 
\fBВладелец процесса\fP
Непривилегированный процесс может установить приоритет ввода\-вывода только
для процесса, чей реальный идентификатор совпадает с реальным или
эффективным идентификатором вызывающего процесса. Процесс с мандатом
\fBCAP_SYS_NICE\fP может изменять приоритет любого процесса.
.TP 
\fBТребуемый приоритет\fP
Попытка установить очень высокий приоритет (\fBIOPRIO_CLASS_RT\fP) требует
мандата \fBCAP_SYS_ADMIN\fP. Ядра версий до 2.6.24 также требуют мандата
\fBCAP_SYS_ADMIN\fP для установки очень низкого приоритета
(\fBIOPRIO_CLASS_IDLE\fP), но начиная с Linux 2.6.25 это отменено.
.PP
Вызов \fBioprio_set\fP() должен соблюдать оба правила, или он завершится с
ошибкой \fBEPERM\fP.
.SH ДЕФЕКТЫ
.\" 6 May 07: Bug report raised:
.\" http://sources.redhat.com/bugzilla/show_bug.cgi?id=4464
.\" Ulrich Drepper replied that he wasn't going to add these
.\" to glibc.
В glibc пока нет заголовочного файла, определяющего прототип и макросы,
описанные в этой странице. Нужные определения можно найти в
\fIlinux/ioprio.h\fP.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBgetpriority\fP(2), \fBopen\fP(2), \fBcapabilities\fP(7)
.sp
Файл Documentation/block/ioprio.txt из дерева исходного кода ядра.

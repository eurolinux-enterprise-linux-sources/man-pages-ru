.\" Copyright 2003,2004 Andi Kleen, SuSE Labs.
.\" and Copyright 2007 Lee Schermerhorn, Hewlett Packard
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" 2006-02-03, mtk, substantial wording changes and other improvements
.\" 2007-08-27, Lee Schermerhorn <Lee.Schermerhorn@hp.com>
.\"	more precise specification of behavior.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MBIND 2 2008\-08\-15 Linux "Руководство программиста Linux"
.SH ИМЯ
mbind \- устанавливает политику на область памяти
.SH ОБЗОР
.nf
\fB#include <numaif.h>\fP
.sp
\fBint mbind(void *\fP\fIaddr\fP\fB, unsigned long \fP\fIlen\fP\fB, int \fP\fImode\fP\fB,\fP
\fB          unsigned long *\fP\fInodemask\fP\fB, unsigned long \fP\fImaxnode\fP\fB,\fP
\fB          unsigned \fP\fIflags\fP\fB);\fP
.sp
Компонуется при указании параметра \fI\-lnuma\fP.
.fi
.SH ОПИСАНИЕ
Вызов \fBmbind\fP() устанавливает политику памяти NUMA, состоящую из режима
политики и нуля или более узлов, на область памяти, начинающуюся с \fIaddr\fP и
длиной \fIlen\fP байт. Политикой памяти задаётся на каком узле будет выделяться
память.

Если область памяти, заданная аргументами \fIaddr\fP и \fIlen\fP, включает
«анонимную» область памяти \(em область памяти, созданную с помощью
системного вызова \fBmmap\fP(2) с аргументом \fBMAP_ANONYMOUS\fP \(em или файл,
отображённый в память (с помощью вызова \fBmmap\fP(2) с флагом \fBMAP_PRIVATE\fP),
то страницы будут выделены в соответствии с указанной политикой только когда
приложение выполняет запись (сохранение) страницы. Для анонимных областей
при первоначальном доступе на чтение будет использоваться общая страница
ядра, содержащая только нули. Для отображённого файла с флагом
\fBMAP_PRIVATE\fP, при первоначальном доступе на чтение будут выделены страницы
в соответствии с политикой процесса, для которого происходит выделение
страницы. Это может быть не тот же процесс, который вызвал \fBmbind\fP().

Указанная политика в заданной области памяти будет игнорироваться для всех
отображений \fBMAP_SHARED\fP. Скорее всего, страницы будут выделены согласно
политике процесса, для которого происходит выделение страницы. Но опять
таки, это может быть не тот процесс, который вызвал \fBmbind\fP().

Если заданная область памяти включает общую область памяти, созданную с
помощью системного вызова \fBshmget\fP(2) и подключённую с помощью системного
вызова \fBshmat\fP(2), то страницы, выделяемые для анонимной или общей области
памяти, будут выделены согласно указанной политике, независимо от того какой
процесс подключил сегмент общей памяти, что вызвало выделение. Однако, если
общая область памяти была создана с флагом \fBSHM_HUGETLB\fP, то огромные
страницы будут выделяться согласно указанной политике, только если выделение
страницы происходит из\-за процесса, который вызвал \fBmbind\fP() для этой
области.

По умолчанию, \fBmbind\fP() учитывается только при новых выделениях; если
страницы внутри области уже были использованы до настройки политики, то
политика не применяется. Такое поведение можно изменить с помощью флагов
\fBMPOL_MF_MOVE\fP и \fBMPOL_MF_MOVE_ALL\fP, описанных далее.

В  аргументе \fImode\fP должно быть указано одно из следующих значений:
\fBMPOL_DEFAULT\fP, \fBMPOL_BIND\fP, \fBMPOL_INTERLEAVE\fP или \fBMPOL_PREFERRED\fP. Для
всех режимом политики, за исключением \fBMPOL_DEFAULT\fP требуется, чтобы
вызывающий указывал в аргументе \fInodemask\fP узел или узлы, для которых
применяется режим.

Аргумент \fImode\fP также может содержать необязательный \fIфлаг
режима\fP. Поддерживаемые \fIфлаги режима\fP:
.TP 
\fBMPOL_F_STATIC_NODES\fP (начиная с Linux\-2.6.26)
В аргументе \fInodemask\fP указываются идентификаторы физических узлов. Linux
не пересоставляет \fInodemask\fP, если процесс перемещается в другой контекст
набора процессоров или когда изменяется набор узлов, который доступен
процессу согласно текущему контексту набора процессоров.
.TP 
\fBMPOL_F_RELATIVE_NODES\fP (начиная с Linux\-2.6.26)
В аргументе \fInodemask\fP указываются идентификаторы узлов из набора
идентификаторов узлов, разрешённых процессу текущим контекстом набора
процессоров.
.PP
В \fInodemask\fP содержится битовая маска узлов, в которой содержится до
\fImaxnode\fP бит. Размер битовой маски округляется до следующего кратного
значения \fIsizeof(unsigned long)\fP, но ядром будет использовано только до
\fImaxnode\fP бит. Значением NULL в \fInodemask\fP или значением \fImaxnode\fP равным
0 задаётся пустой набор узлов. Если значение \fImaxnode\fP равно 0, то аргумент
\fInodemask\fP игнорируется. Там, где требуется \fInodemask\fP, его значение
должно содержать, как минимум, один работающий узел, который разрешён
процессу текущим контекстом набора процессоров (если не указан флаг
\fBMPOL_F_STATIC_NODES\fP) и у которого имеется память.

В режиме \fBMPOL_DEFAULT\fP любая политика не по умолчанию удаляется и
восстанавливается поведение по умолчанию. Если он применяется к области
памяти посредством \fBmbind\fP(), то это означает использование политики
процесса, которая могла быть установлена с помощью \fBset_mempolicy\fP(2). Если
режим политики процесса также равен \fBMPOL_DEFAULT\fP, то будет задействована
системная политика по умолчанию. При системной политике по умолчанию
выделяются страницы на том узле ЦП, на котором было запрошено выделение. Для
\fBMPOL_DEFAULT\fP в аргументах \fInodemask\fP и \fImaxnode\fP должен быть указан
пустой набор узлов.

В режиме \fBMPOL_BIND\fP выделение памяти ограничено узлами, заданными в
\fInodemask\fP. Если в \fInodemask\fP указано более одного узла, то выделение
страниц начнётся с узла с меньшим номером идентификатора, и продолжится до
тех пор, пока на нём не кончится свободная память. Затем выделение
продолжится на узле со следующим большим номером идентификатора, указанного
в \fInodemask\fP, и т.д. до тех пор, пока на всех заданных узлах не закончится
свободная память. Страницы не будут выделяться на узлах, не указанных в
\fInodemask\fP.

В режиме \fBMPOL_INTERLEAVE\fP при выделении страниц выполняется чередование
узлов, которые указаны в \fInodemask\fP. Это оптимизирует использование полосы
пропускания, но не задержку, вовлекая при доступ к страницам и памяти
множество узлов. Чтобы это дало эффект, область памяти должна быть
достаточно большой, не менее 1МБ или более, и характер доступа должен быть
достаточно равномерным. Доступ к одной странице области будет по прежнему
ограничен размером полосы пропускания одного узла.

В режиме \fBMPOL_PREFERRED\fP устанавливается предпочтительный узел для
выделения. Ядро сначала будет пытаться выделить страницы на этом узле и
перейдёт на другие узлы, если на предпочтительном узле недостаточно
свободной памяти. Если в \fInodemask\fP задано более одного идентификатора
узла, то в качестве предпочтительного будет выбран первый из маски. Если в
аргументах \fInodemask\fP и \fImaxnode\fP указан пустой набор, то память будет
выделена на узле ЦП, на котором запросили выделение. Это единственный способ
задать «локальное выделение» области памяти через \fBmbind\fP().

.\" According to the kernel code, the following is not true
.\" --Lee Schermerhorn
.\" In 2.6.16 or later the kernel will also try to move pages
.\" to the requested node with this flag.
Если в \fIflags\fP указан \fBMPOL_MF_STRICT\fP и \fImode\fP не равно \fBMPOL_DEFAULT\fP,
то вызов завершится с ошибкой \fBEIO\fP, если существующие страницы в области
памяти не следуют политике.

Если в \fIflags\fP указан \fBMPOL_MF_MOVE\fP, то ядро будет пытаться переместить
все существующие страницы в области памяти так, чтобы они следовали
политике. Страницы, используемые совместно с другими процессами,
перемещаться не будут. Если также указан \fBMPOL_MF_STRICT\fP, что вызов
завершится с ошибкой \fBEIO\fP, если страницы не могут быть перемещены.

.\" ---------------------------------------------------------------
Если в \fIflags\fP указан \fBMPOL_MF_MOVE_ALL\fP, то ядро будет пытаться
переместить все существующие страницы в области памяти независимо от того,
используются ли они другими процессами. Для использования данного флага
вызывающий процесс должен иметь привилегированным (\fBCAP_SYS_NICE\fP). Если
также указан \fBMPOL_MF_STRICT\fP, то вызов завершится с ошибкой \fBEIO\fP, если
некоторые страницы нельзя переместить.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
.\" ---------------------------------------------------------------
При успешном выполнении \fBmbind\fP() возвращается 0. При ошибке возвращается
\-1, а в \fIerrno\fP содержится код ошибки.
.SH ОШИБКИ
.\"  I think I got all of the error returns.  --Lee Schermerhorn
.TP 
\fBEFAULT\fP
Часть или вся область памяти, заданная в \fInodemask\fP и \fImaxnode\fP, указывает
за пределы доступного адресного пространства. Или в указанной области памяти
есть неотображаемая дыра (hole).
.TP 
\fBEINVAL\fP
.\" As at 2.6.23, this limit is "a page worth of bits", e.g.,
.\" 8 * 4096 bits, assuming a 4kB page size.
В \fIflags\fP или \fImode\fP указано неправильное значение; или \fIaddr + len\fP
меньше чем \fIaddr\fP; или \fIaddr\fP не кратен системному размеру страницы. Или
\fImode\fP равен \fBMPOL_DEFAULT\fP и в \fInodemask\fP задан непустой набор; или
\fImode\fP равен \fBMPOL_BIND\fP или \fBMPOL_INTERLEAVE\fP и значение \fInodemask\fP
пусто. Или значение \fImaxnode\fP превышает устанавливаемый ядром предел. Или в
\fInodemask\fP задан один или более идентификаторов узлов, номер которого
больше чем максимально поддерживаемый. Или в \fInodemask\fP не задано ни одного
идентификатора узла, разрешённого процессу текущим контекстом набора
процессоров, или ни один из указанных узлов не содержит память. Или в
аргументе \fImode\fP указаны сразу \fBMPOL_F_STATIC_NODES\fP и
\fBMPOL_F_RELATIVE_NODES\fP.
.TP 
\fBEIO\fP
Был указан \fBMPOL_MF_STRICT\fP и существующая страница была уже на узле, что
не следует политике; или был указан \fBMPOL_MF_MOVE\fP или \fBMPOL_MF_MOVE_ALL\fP
и ядро не смогло переместить все существующие страницы области.
.TP 
\fBENOMEM\fP
Недостаточное количество памяти ядра.
.TP 
\fBEPERM\fP
.\" ---------------------------------------------------------------
Аргумент \fIflags\fP содержит флаг \fBMPOL_MF_MOVE_ALL\fP и вызывающий не имеет
мандата \fBCAP_SYS_NICE\fP.
.SH ВЕРСИИ
Системный вызов \fBmbind\fP() был добавлен в ядро Linux версии 2.6.7.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данный вызов есть только в Linux.
.SH ЗАМЕЧАНИЯ
Информация о библиотеке доступна в \fBnuma\fP(7).

Политика NUMA не поддерживается для области памяти отображения файла,
который отображён с флагом \fBMAP_SHARED\fP.

Режим \fBMPOL_DEFAULT\fP может иметь различные эффекты для \fBmbind\fP() и
\fBset_mempolicy\fP(2). Когда указан \fBMPOL_DEFAULT\fP для \fBset_mempolicy\fP(2),
политика процесса возвращается к политике по умолчанию или локальному
выделению. Когда \fBMPOL_DEFAULT\fP указан для области памяти, используемой
\fBmbind\fP(), все страницы, последовательно выделяемые для этой области, будут
использовать политику процесса, которая задана с помощью
\fBset_mempolicy\fP(2). Это эффективно удаляет явную политику из указанной
области, «откатываясь» к возможной политике не по умолчанию. Для выбора
явного «локального выделения» области памяти, укажите в \fImode\fP значение
\fBMPOL_PREFERRED\fP с пустым набором узлов. Этот метод также сработает и в
вызове \fBset_mempolicy\fP(2).

Поддержка политики для огромных страниц была добавлена в версию 2.6.16. Для
эффективной работы политики чередования на огромных страничных отображениях,
контролируемая память должна измеряться десятками мегабайт или больше.

Режим \fBMPOL_MF_STRICT\fP игнорируется для огромных страничных отображений.

Режимы \fBMPOL_MF_MOVE\fP и \fBMPOL_MF_MOVE_ALL\fP доступны только в Linux 2.6.16
и новее.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBget_mempolicy\fP(2), \fBgetcpu\fP(2), \fBmmap\fP(2), \fBset_mempolicy\fP(2),
\fBshmat\fP(2), \fBshmget\fP(2), \fBnuma\fP(3), \fBcpuset\fP(7), \fBnuma\fP(7),
\fBnumactl\fP(8)

.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) Michael Kerrisk, 2004
.\"	using some material drawn from earlier man pages
.\"	written by Thomas Kuhn, Copyright 1996
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330,
.\" Boston, MA 02111, USA.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MLOCK 2 2011\-09\-14 Linux "Руководство программиста Linux"
.SH ИМЯ
mlock, munlock, mlockall, munlockall \- блокирует и разблокирует память
.SH ОБЗОР
.nf
\fB#include <sys/mman.h>\fP
.sp
\fBint mlock(const void *\fP\fIaddr\fP\fB, size_t \fP\fIlen\fP\fB);\fP
\fBint munlock(const void *\fP\fIaddr\fP\fB, size_t \fP\fIlen\fP\fB);\fP
.sp
\fBint mlockall(int \fP\fIflags\fP\fB);\fP
\fBint munlockall(void);\fP
.fi
.SH ОПИСАНИЕ
Вызовы \fBmlock\fP() и \fBmlockall\fP() блокируют часть или всё виртуальное
адресное пространство процесса в ОЗУ, соответственно, предотвращая выгрузку
страниц в область подкачки. Вызовы \fBmunlock\fP() и \fBmunlockall\fP() выполняют
обратное действие \(em разблокируют часть или всё виртуальное адресное
пространство процесса, позволяя менеджеру памяти ядра при необходимости
выгружать страницы в область подкачки.
.SS "mlock() и munlock()"
Вызов \fBmlock\fP() блокирует страницы в области, начинающейся с адреса \fIaddr\fP
и длиной \fIlen\fP байтов. Все страницы, попадающие, даже частично, в заданную
область, будут гарантировано помещены в ОЗУ, если системный вызов выполнился
успешно; страницы гарантировано останутся в ОЗУ пока не будут
разблокированы.

Вызов \fBmunlock\fP() разблокирует страницы в области, начинающейся с адреса
\fIaddr\fP и длиной \fIlen\fP байтов. После этого вызова все страницы, попадающие,
даже частично, в заданную область, снова могут быть помещены ядром во
внешнее пространство подкачки.
.SS "mlockall() и munlockall()"
Вызов \fBmlockall\fP() блокирует все страницы, отображённые в адресное
пространство вызывающего процесса. Сюда входят страницы сегмента кода,
данных и стека, а также общих библиотек, страницы с данными
пользовательского пространства ядра, общей памяти и файлов, отображённых в
память. Все отображённые страницы гарантировано останутся в ОЗУ, если
системный вызов выполнился успешно; страницы гарантировано останутся в ОЗУ
пока не будут разблокированы.

Аргумент \fIflags\fP создаётся побитовым сложением одной или более следующих
констант:
.TP  1.2i
\fBMCL_CURRENT\fP
Блокировать все страницы, которые в данный момент отображены в адресное
пространство процесса.
.TP 
\fBMCL_FUTURE\fP
Блокировать все страницы, которые будут отображены в адресное пространство
процесса в будущем. Это могут быть, например, новые страницы, затребованные
для увеличения кучи и стека, а также новые отображённые в память файлы или
области общей памяти.
.PP
Если указан флаг \fBMCL_FUTURE\fP, то последующий системный вызов (например,
\fBmmap\fP(2), \fBsbrk\fP(2), \fBmalloc\fP(3)), может завершиться с ошибкой, если бы
его работа приводит к превышению разрешённого максимального числа
блокируемых байт (см. ниже). Также этот флаг может остановить увеличение
стека: ядро будет отказывать в увеличении стека и будет посылать процессу
сигнал \fBSIGSEGV\fP.

Вызов \fBmunlockall\fP() разблокирует все страницы, отображённые в адресное
пространство вызывающего процесса.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении системные вызовы возвращают 0. В случае ошибки
возвращается \-1, а \fIerrno\fP устанавливается в соответствующее значение, и в
адресном пространстве процесса не выполняется никаких блокировок.
.SH ОШИБКИ
.TP 
\fBENOMEM\fP
(Linux 2.6.9 и новее) У вызывающего процесса установлено ненулевое мягкое
ограничение ресурса \fBRLIMIT_MEMLOCK\fP, но он пытается заблокировать больше
памяти, чем это разрешено ограничением. Данное ограничение не учитывается у
привилегированных процессов (\fBCAP_IPC_LOCK\fP).
.TP 
\fBENOMEM\fP
.\" In the case of mlock(), this check is somewhat buggy: it doesn't
.\" take into account whether the to-be-locked range overlaps with
.\" already locked pages.  Thus, suppose we allocate
.\" (num_physpages / 4 + 1) of memory, and lock those pages once using
.\" mlock(), and then lock the *same* page range a second time.
.\" In the case, the second mlock() call will fail, since the check
.\" calculates that the process is trying to lock (num_physpages / 2 + 2)
.\" pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
(Linux 2.4 и в более ранних) Вызывающий процесс пытается заблокировать более
половины ОЗУ.
.TP 
\fBEPERM\fP
.\"SVr4 documents an additional EAGAIN error code.
Вызывающий не имеет прав (\fBCAP_IPC_LOCK\fP) для выполнения запрошенной
операции.
.LP
У \fBmlock\fP() и \fBmunlock\fP():
.TP 
\fBEAGAIN\fP
Невозможно заблокировать некоторую часть или весь диапазон адресов.
.TP 
\fBEINVAL\fP
Результат добавления \fIstart\fP+\fIlen\fP стал меньше чем \fIstart\fP (например,
добавление могло привести к переполнению).
.TP 
\fBEINVAL\fP
(Не в Linux) Значение \fIaddr\fP не кратно размеру страницы.
.TP 
\fBENOMEM\fP
Часть указанного адресного диапазона не соответствует с отображёнными
страницами адресного пространства процесса.
.LP
У \fBmlockall\fP():
.TP 
\fBEINVAL\fP
Указан неизвестный флаг в \fIflags\fP.
.LP
У \fBmunlockall\fP():
.TP 
\fBEPERM\fP
(Linux 2.6.8 и более ранних) Вызывающий процесс не имеет достаточно прав
(\fBCAP_IPC_LOCK\fP).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
POSIX.1\-2001, SVr4.
.SH ДОСТУПНОСТЬ
В POSIX\-системах, в которых доступны \fBmlock\fP() и \fBmunlock\fP(), значение
\fB_POSIX_MEMLOCK_RANGE\fP определено в \fI<unistd.h>\fP, а количество
байт в странице можно определить из константы \fBPAGESIZE\fP (если определена)
в \fI<limits.h>\fP или вызвав \fIsysconf(_SC_PAGESIZE)\fP.

.\" POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
.\" -1: unavailable, 0: ask using sysconf().
.\" glibc defines it to 1.
В POSIX\-системах, в которых доступны \fBmlockall\fP() и \fBmunlockall\fP(),
значение \fB_POSIX_MEMLOCK\fP, определенное в \fI<unistd.h>\fP, больше
нуля (см. также \fBsysconf\fP(3)).
.SH ЗАМЕЧАНИЯ
Блокировка памяти используется, в основном, в двух случаях: в алгоритмах
реального времени и при работе с секретными данными. Программам реального
времени необходима предсказуемость времени выполнения, а страничный обмен
(наряду с системой переключения процессов) может привести к неожиданным
задержкам в работе. Такие приложения часто переключаются в режим реального
времени при помощи вызовы \fBsched_setscheduler\fP(2). Криптографические
системы защиты данных очень часто содержат важные данные, например, пароли
или секретные ключи, в структурах данных. В результате страничного обмена
эти данные могут попасть в область подкачки, находящуюся на устройстве
длительного хранения, где к этим данным после того, как они пропадут из ОЗУ,
может получить доступ практически кто угодно. (Помните, что в режиме
приостановки (suspend) на ноутбуках и некоторых компьютерах на жёсткий диск
сохраняется копия памяти ОЗУ системы, независимо от блокировок памяти).

Процессы реального времени, использующие \fBmlockall\fP() для устранения
задержек при страничных прерываниях (page fault), должны зарезервировать
достаточно заблокированных страниц стека до входа в критический ко времени
участок, для того, чтобы вызов функции не мог привести к страничному
прерыванию. Это можно выполнить с помощью вызова функции, которая выделит
место под достаточно большую автоматическую переменную (массив) и выполнит
запись в память для того, чтобы этот массив занял место в странице
стека. Таким путём будет отображено достаточно страниц для стека, которые
можно заблокировать в ОЗУ. Бесполезная запись нужна для того, чтобы в
критическом участке не возникло страничное прерывание для копирования
страницы при записи.

Блокировка памяти не наследуется дочерними процессами, созданными при помощи
\fBfork\fP(2), и автоматически удаляется (разблокируется) при выполнении
\fBexecve\fP(2) или при завершении работы процесса.

Блокировка памяти адресного диапазона автоматически удаляется, если этот
диапазон становится неотображаемым с помощью вызова \fBmunmap\fP(2).

Блокировки памяти не накапливаются, то есть, если страница была
заблокирована вызовами \fBmlock\fP() или \fBmlockall\fP() несколько раз, то она
будет разблокирована единственным вызовом \fBmunlock\fP() для соответствующего
диапазона или с помощью вызова \fBmunlockall\fP(). Страницы, которые были
отображены в несколько мест или несколькими процессами, останутся
заблокированными в ОЗУ до тех пор, пока они блокируются хотя бы в одном
месте или хотя бы в одном процессе.
.SS "Замечания, касающиеся Linux"
В Linux, \fBmlock\fP() и \fBmunlock\fP() автоматически округляют \fIaddr\fP в меньшую
сторону к размеру границы ближайшей страницы. Однако, в POSIX.1\-2001
реализации разрешено требовать, чтобы значение \fIaddr\fP было выровнено по
размеру страницы, поэтому переносимые приложения должны выполнять
выравнивание.

В поле \fIVmLck\fP в имеющемся только в Linux файле \fI/proc/PID/status\fP
показано сколько килобайт памяти заблокировал процесс с идентификатором
\fIPID\fP с помощью \fBmlock\fP(), \fBmlockall\fP() и \fBmmap\fP(2) с флагом
\fBMAP_LOCKED\fP.
.SS "Ограничения и права доступа"
В Linux версии 2.6.8 и более ранних для блокировки памяти процесс должен
иметь мандат (\fBCAP_IPC_LOCK\fP), а мягкое ограничение ресурса
\fBRLIMIT_MEMLOCK\fP определяет как много памяти можно заблокировать.

Начиная с Linux 2.6.9, привилегированный процесс не имеет ограничения на
ограничиваемое количество памяти, а мягкое ограничение ресурса
\fBRLIMIT_MEMLOCK\fP определяет предел ограничиваемой памяти для
непривилегированных процессов.
.SH ДЕФЕКТЫ
В ветви 2.4 ядер Linux до версии 2.4.17 включительно есть дефект, из\-за
которого флаг \fBMCL_FUTURE\fP у \fBmlockall\fP() наследуется при \fBfork\fP(2). Он
устранён в версии 2.4.18.

.\" See the following LKML thread:
.\" http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
.\" "Rationale for RLIMIT_MEMLOCK"
.\" 23 Jan 2006
Начиная с ядра версии 2.6.9, если привилегированный процесс вызывает
\fImlockall(MCL_FUTURE)\fP и, позднее, отказывается от прав (теряет мандат
\fBCAP_IPC_LOCK\fP, например, устанавливая свой эффективный UID в ненулевое
значение), то последующие выделения памяти (например, с помощью \fBmmap\fP(2),
\fBbrk\fP(2)) будут завершаться с ошибкой при достижении предела ресурса
\fBRLIMIT_MEMLOCK\fP.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBmmap\fP(2), \fBsetrlimit\fP(2), \fBshmctl\fP(2), \fBsysconf\fP(3), \fBproc\fP(5),
\fBcapabilities\fP(7)

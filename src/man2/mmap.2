.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) 1996 Andries Brouwer <aeb@cwi.nl>
.\" and Copyright (C) 2006, 2007 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified 1997-01-31 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 2000-03-25 by Jim Van Zandt <jrv@vanzandt.mv.com>
.\" Modified 2001-10-04 by John Levon <moz@compsoc.man.ac.uk>
.\" Modified 2003-02-02 by Andi Kleen <ak@muc.de>
.\" Modified 2003-05-21 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	MAP_LOCKED works from 2.5.37
.\" Modified 2004-06-17 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified 2004-09-11 by aeb
.\" Modified 2004-12-08, from Eric Estievenart <eric.estievenart@free.fr>
.\" Modified 2004-12-08, mtk, formatting tidy-ups
.\" Modified 2006-12-04, mtk, various parts rewritten
.\" 2007-07-10, mtk, Added an example program.
.\" 2008-11-18, mtk, document MAP_STACK
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MMAP 2 2012\-04\-16 Linux "Руководство программиста Linux"
.SH ИМЯ
mmap, munmap \- отображает файлы или устройства в памяти, или удаляет их
отображение
.SH ОБЗОР
.nf
\fB#include <sys/mman.h>\fP
.sp
\fBvoid *mmap(void *\fP\fIaddr\fP\fB, size_t \fP\fIlength\fP\fB, int \fP\fIprot\fP\fB, int \fP\fIflags\fP\fB,\fP
\fB           int \fP\fIfd\fP\fB, off_t \fP\fIoffset\fP\fB);\fP
\fBint munmap(void *\fP\fIaddr\fP\fB, size_t \fP\fIlength\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Вызов \fBmmap\fP() создаёт новое отображение в виртуальном адресном
пространстве вызывающего процесса. Адрес начала нового отображения
указывается в \fIaddr\fP. В аргументе \fIlength\fP задаётся длина отображения.

.\" Before Linux 2.6.24, the address was rounded up to the next page
.\" boundary; since 2.6.24, it is rounded down!
Если значение \fIaddr\fP равно NULL, то ядро само выбирает адрес, по которому
создаётся отображение; это наиболее переносимый метод создания нового
отображения. Если значение \fIaddr\fP не равно NULL, то ядро учитывает это при
размещении отображения; в Linux отображение будет создано в странице
ближайшей к границе. Адрес нового отображения возвращается как результат
вызова.

Содержимое файлового отображения (в отличие от анонимного отображения;
см. \fBMAP_ANONYMOUS\fP далее) инициализируется данными из файла (или объекта),
на который указывает файловый дескриптор \fIfd\fP, длиной \fIlength\fP байт,
начиная со смещения \fIoffset\fP. Значение \fIoffset\fP должно быть кратно размеру
(возвращается \fIsysconf(_SC_PAGE_SIZE)\fP) страницы.
.LP
В аргументе \fIprot\fP указывается желаемая защита памяти отображения (не
должна конфликтовать с режимом открытого файла). Значением может быть
\fBPROT_NONE\fP или побитово сложенные (OR) следующие флаги:
.TP  1.1i
\fBPROT_EXEC\fP
Страницы доступны для исполнения.
.TP 
\fBPROT_READ\fP
Страницы доступны для чтения.
.TP 
\fBPROT_WRITE\fP
Страницы доступны для записи.
.TP 
\fBPROT_NONE\fP
Страницы недоступны.
.LP
В аргументе \fIflags\fP задаётся будут ли изменения отображения видимы другим
процессам, отображающим ту же область, и будут ли изменения перенесены в
отображённый файл. Данное поведение определяется в \fIflags\fP одним из
следующих значений:
.TP  1.1i
\fBMAP_SHARED\fP
Использовать это отображение совместно с другими процессами. Изменения
отображения видимы другим процессам, которые отображают тот же файл, а также
изменяется содержимое самого файла. Файл может оставаться не обновлённым до
запуска вызова \fBmsync\fP(2) или \fBmunmap\fP().
.TP 
\fBMAP_PRIVATE\fP
Создать закрытое отображение с механизмом копирования при записи. Изменения
отображения невидимы другим процессам, отображающим тот же файл, и сам файл
не изменяется. Не определено, будут ли видимы в отображённой области
изменения в файле, сделанные после вызова \fBmmap\fP().
.LP
Эти флаги описаны в POSIX.1\-2001.

Кроме этого в \fIflags\fP могут быть указаны (побитовым сложением):
.TP 
\fBMAP_32BIT\fP (начиная с Linux 2.4.20, 2.6)
.\" See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
Поместить отображение в первые 2ГБ адресного пространства процесса. Этот
флаг поддерживается только на x86\-64 для 64\-битных программ. Он был добавлен
для размещения стеков нитей в первых 2ГБ памяти, что даёт увеличение
производительности при переключения контекста на некоторых первых 64\-битных
процессорах. В современных процессорах x86\-64 такой проблемы с
производительностью больше нет, поэтому на таких системах данный флаг больше
не требуется. Он игнорируется, если указан флаг \fBMAP_FIXED\fP.
.TP 
\fBMAP_ANON\fP
Синоним \fBMAP_ANONYMOUS\fP. Устарел.
.TP 
\fBMAP_ANONYMOUS\fP
Отображение не связано с каким\-либо файлом; его содержимое инициализируется
нулями. Аргументы \fIfd\fP и \fIoffset\fP игнорируются; однако в некоторых
реализациях при указании \fBMAP_ANONYMOUS\fP (или \fBMAP_ANON\fP) требуется
указывать \fIfd\fP равное \-1, и так нужно поступать для переносимости
приложений. Использование \fBMAP_ANONYMOUS\fP вместе с \fBMAP_SHARED\fP
поддерживается в Linux начиная с ветви 2.4.
.TP 
\fBMAP_DENYWRITE\fP
.\" Introduced in 1.1.36, removed in 1.3.24.
Этот флаг игнорируется. Раньше он обозначал, что попытки записи в
подчинённые файлы должны завершаться с кодом ошибки \fBETXTBUSY\fP. Но это
стало основой для атак типа отказа в обслуживании.
.TP 
\fBMAP_EXECUTABLE\fP
.\" Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
.\" (Long ago, it signaled that the underlying file is an executable.
.\" However, that information was not really used anywhere.)
.\" Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
.\" MAP_DENYWRITE?
Этот флаг игнорируется.
.TP 
\fBMAP_FILE\fP
.\" On some systems, this was required as the opposite of
.\" MAP_ANONYMOUS -- mtk, 1 May 2007
Флаг для совместимости, игнорируется.
.TP 
\fBMAP_FIXED\fP
Не просто учитывать адрес \fIaddr\fP, а помещать отображение точно по этому
адресу. Значение \fIaddr\fP должно быть кратно размеру страницы. Если область
памяти, указанная \fIaddr\fP и \fIlen\fP, перекрывается со страницами существующих
отображений, то перекрывающаяся часть существующих отображений будет
отброшена. Если заданный адрес не может быть использован, то вызов \fBmmap\fP()
завершится с ошибкой. Так как требование постоянного адреса для отображения
менее переносимо, использовать этот флаг не рекомендуется.
.TP 
\fBMAP_GROWSDOWN\fP
Используется для стеков. Для виртуальной системы памяти ядра обозначает, что
отображение должно распространяться вниз по памяти.
.TP 
\fBMAP_HUGETLB\fP (начиная с Linux 2.6.32)
Выделять отображение используя «огромные страницы». Дополнительную
информацию смотрите в файле исходного кода ядра
\fIDocumentation/vm/hugetlbpage.txt\fP.
.TP 
\fBMAP_LOCKED\fP (начиная с Linux 2.5.37)
.\" If set, the mapped pages will not be swapped out.
Блокировать страницы отображённой области в памяти так, как это делает
\fBmlock\fP(2). Этот флаг игнорируется в старых ядрах.
.TP 
\fBMAP_NONBLOCK\fP (начиная с Linux 2.5.46)
Имеет смысл только вместе с \fBMAP_POPULATE\fP. Не выполнять упреждающее
чтение: только создать записи в таблице страниц для страниц, которые уже
есть ОЗУ. Начиная с Linux 2.6.23 этот флаг приводит к тому, что выполнение
работы \fBMAP_POPULATE\fP отменяется. Когда\-нибудь комбинация \fBMAP_POPULATE\fP и
\fBMAP_NONBLOCK\fP может быть реализована заново.
.TP 
\fBMAP_NORESERVE\fP
Не резервировать страницы пространства подкачки для этого отображения. Если
пространство подкачки резервируется, то для отображения гарантируется
возможность изменения. Если оно не резервируется, то можно получить сигнал
\fBSIGSEGV\fP при записи, если физическая память будет недоступна. Смотрите
также описание файла \fI/proc/sys/vm/overcommit_memory\fP в \fBproc\fP(5). В ядрах
до 2.6 этот флаг действовал только для частных доступных на запись
отображений.
.TP 
\fBMAP_POPULATE\fP (начиная с Linux 2.5.46)
Наполнить (до возникновения страничного прерывания, prefault) страничные
таблицы отображения. Для файлового отображения это приводит к опережающему
чтению из файла. Последующий доступ к отображению не будет блокирован в
ожидании обработки страничного прерывания. Флаг \fBMAP_POPULATE\fP
поддерживается только для закрытых отображений начиная с Linux 2.6.23.
.TP 
\fBMAP_STACK\fP (начиная с Linux 2.6.27)
.\" See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
.\" commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
.\" http://thread.gmane.org/gmane.linux.kernel/720412
.\" "pthread_create() slow for many threads; also time to revisit 64b
.\"  context switch optimization?"
Разместить отображение по адресу, пригодному для процесса или для стека
нити. В настоящее время для этого флага не выполняются какие\-либо действия,
но он используется для реализации нитей в glibc; если на какой\-то
архитектуре потребуются специальные действия по выделению стека, то позже их
поддержка может быть прозрачно добавлена в glibc.
.TP 
\fBMAP_UNINITIALIZED\fP (начиная с Linux 2.6.33)
Не очищать анонимные страницы. Этот флаг предназначен для повышения
производительности на встраиваемых устройствах. Он учитывается, только если
ядро было собрано с поддержкой параметра
\fBCONFIG_MMAP_ALLOW_UNINITIALIZED\fP. Так как этот параметр может привести к
нарушению безопасности, обычно он устанавливается только на встраиваемых
устройствах (то есть, устройствах, где только один человек имеет полный
контроль над содержимым пользовательской памяти).
.LP
Из флагов, перечисленных выше, в POSIX.1\-2001 определён только
\fBMAP_FIXED\fP. Однако, большинство систем также поддерживают \fBMAP_ANONYMOUS\fP
(или его синоним \(em \fBMAP_ANON\fP).
.LP
В некоторых системах описаны дополнительные флаги: \fBMAP_AUTOGROW\fP,
\fBMAP_AUTORESRV\fP, \fBMAP_COPY\fP и \fBMAP_LOCAL\fP.
.LP
Память, отображённая с помощью \fBmmap\fP(), сохраняется при \fBfork\fP(2) с теми
же атрибутами.
.LP
Файл отображается по кратному размеру страницы. Для файла, который не кратен
размеру страницы, оставшаяся память при отображении заполняется нулями, и
запись в эту область не приводит к изменению файла. Действия при изменении
размера отображаемого файла на страницы, которые соответствуют добавленным
или удалённым областям файла, не определены.
.SS munmap()
Системный вызов \fBmunmap\fP() удаляет отображение для указанного адресного
диапазона и это приводит к тому, что дальнейшее обращение по адресам внутри
диапазона приводит к генерации неправильных ссылок на память. Также для
диапазона отображение автоматически удаляется при завершении работы
процесса. С другой стороны, закрытие файлового дескриптора не приводит к
удалению отображения диапазона.
.LP
Адрес \fIaddr\fP должен быть кратен размеру страницы. Все страницы, содержащие
часть указанного диапазона, удаляются из отображения и последующие ссылки на
эти страницы приводят к генерации сигнала \fBSIGSEGV\fP. Это не ошибка, если
указанный диапазон не содержит каких\-либо отображённых страниц.
.SS "Изменение временных отметок для отображённых файлов"
У отображённых файлов поле \fIst_atime\fP может измениться в любой момент между
вызовом \fBmmap\fP() и соответствующим удалением отображения; первое обращение
к отображённой странице приведёт к обновлению поля, если это ещё не было
сделано.
.LP
Поля \fIst_ctime\fP и \fIst_mtime\fP у отображённого с помощью флагов
\fBPROT_WRITE\fP и \fBMAP_SHARED\fP файла будут обновлены после записи
отображённой области и перед последующим вызовом \fBmsync\fP(2) с флагом
\fBMS_SYNC\fP или \fBMS_ASYNC\fP, если он будет вызван.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении \fBmmap\fP() возвращается указатель на отображённую
область. При ошибке возвращается значение \fBMAP_FAILED\fP (а именно, \fI(void\ *)\ \-1\fP) и  \fIerrno\fP устанавливается в соответствующее значение. При
успешном выполнении \fBmunmap\fP() возвращается 0; при ошибке возвращается \-1 и
устанавливается \fIerrno\fP (скорее всего, в \fBEINVAL\fP).
.SH ОШИБКИ
.TP 
\fBEACCES\fP
Файловый дескриптор указывает на не обычный файл. Или был указан флаг
\fBMAP_PRIVATE\fP, но \fIfd\fP не открыт на чтение. Или был указан флаг
\fBMAP_SHARED\fP и установлен бит \fBPROT_WRITE\fP, но \fIfd\fP не открыт в режиме
чтения/записи (\fBO_RDWR\fP). Или был указан флаг \fBPROT_WRITE\fP, но файл
доступен только для дополнения.
.TP 
\fBEAGAIN\fP
Файл заблокирован, или блокируется слишком много памяти
(см. \fBsetrlimit\fP(2)).
.TP 
\fBEBADF\fP
Значение \fIfd\fP не является правильным файловым дескриптором (и
\fBMAP_ANONYMOUS\fP не установлен).
.TP 
\fBEINVAL\fP
Неправильное значение \fIaddr\fP, \fIlength\fP или \fIoffset\fP (например, оно либо
слишком велико, либо не выровнено по границе страницы).
.TP 
\fBEINVAL\fP
(начиная с Linux 2.6.12) Значение \fIlength\fP равно 0.
.TP 
\fBEINVAL\fP
Значение \fIflags\fP не содержит \fBMAP_PRIVATE\fP или \fBMAP_SHARED\fP, или содержит
сразу эта эти флага.
.TP 
\fBENFILE\fP
.\" This is for shared anonymous segments
.\" [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
.\" .TP
.\" .B ENOEXEC
.\" A file could not be mapped for reading.
Достигнуто максимальное количество открытых файлов в системе.
.TP 
\fBENODEV\fP
Используемая файловая система для указанного файла не поддерживает
отображение памяти.
.TP 
\fBENOMEM\fP
Недостаточно памяти, или было превышено максимальное число отображений
процесса.
.TP 
\fBEPERM\fP
.\" (Since 2.4.25 / 2.6.0.)
Аргументом \fIprot\fP запрашивается \fBPROT_EXEC\fP, но отображённая область
принадлежит файлу на файловой системе, которая смонтирована с флагом
no\-exec.
.TP 
\fBETXTBSY\fP
Был задан флаг \fBMAP_DENYWRITE\fP, но объект, указываемый \fIfd\fP, открыт на
запись.
.LP
При использовании отображаемой области памяти могут возникать следующие
сигналы:
.TP 
\fBSIGSEGV\fP
Попытка записи в область, отображённую только для чтения.
.TP 
\fBSIGBUS\fP
Попытка доступа к части буфера, которая не совпадает файлом (например, она
может находиться за пределами файла. Подобной является ситуация, когда
другой процесс уменьшил длину файла).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
.\" SVr4 documents additional error codes ENXIO and ENODEV.
.\" SUSv2 documents additional error codes EMFILE and EOVERFLOW.
SVr4, 4.4BSD, POSIX.1\-2001.
.SH ДОСТУПНОСТЬ
.\" POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
.\" -1: unavailable, 0: ask using sysconf().
.\" glibc defines it to 1.
В системах POSIX, в которых есть вызовы \fBmmap\fP(), \fBmsync\fP(2) и
\fBmunmap\fP(), значение \fB_POSIX_MAPPED_FILES\fP, определённое в
\fI<unistd.h>\fP, больше 0 (смотрите также \fBsysconf\fP(3)).
.SH ЗАМЕЧАНИЯ
.\" Since around glibc 2.1/2.2, depending on the platform.
В данной странице описывается интерфейс, предоставляемый обёрточной функцией
glibc \fBmmap\fP(). Раньше, эта функция обращалась к системному вызову с тем же
именем. Начиная с ядра 2.4, данный системный вызов был заменён на
\fBmmap2\fP(2). В настоящее время обёрточная функция glibc, \fBmmap\fP(), вызывает
\fBmmap2\fP(2) с подходящим подкорректированным значением \fIoffset\fP.

На некоторых архитектурах (например, i386), флаг \fBPROT_WRITE\fP подразумевает
флаг \fBPROT_READ\fP. Также от архитектуры зависит подразумевает ли
\fBPROT_READ\fP флаг \fBPROT_EXEC\fP или нет. Переносимые программы должны всегда
устанавливать \fBPROT_EXEC\fP, если они собираются выполнять код, находящийся в
отображении.

Переносимый способ создания отображения: указать в \fIaddr\fP значение 0 (NULL)
и убрать \fBMAP_FIXED\fP из \fIflags\fP. В этом случае, система сама выберет адрес
для отображения; адрес, выбранный таким образом, не будет будет
конфликтовать с существующими отображениями и не будет равен 0. Если указан
флаг \fBMAP_FIXED\fP и значение \fIaddr\fP равно 0 (NULL), то адрес отображения
будет равен 0 (NULL).
.SH ДЕФЕКТЫ
В Linux не гарантируется результат, описанный выше у флага
\fBMAP_NORESERVE\fP. По умолчанию, любой процесс может быть принудительно
завершён в любой момент, если в системе закончилась память.

В ядрах до версии 2.6.7 флаг \fBMAP_POPULATE\fP учитывается только, если
указано значение \fIprot\fP равное \fBPROT_NONE\fP.

В SUSv3 указано, что \fBmmap\fP() должен завершаться с ошибкой, если \fIlength\fP
равно 0. Однако в ядрах до версии 2.6.12 вызов \fBmmap\fP() в этом случае
выполняется успешно: отображение не создаётся и вызов возвращает
\fIaddr\fP. Начиная с ядра версии 2.6.12, в этом случае вызов \fBmmap\fP()
завершается с ошибкой \fBEINVAL\fP.
.SH ПРИМЕР
.\" FIXME . Add an example here that uses an anonymous shared region for
.\" IPC between parent and child.
.PP
Следующая программа выводит часть файла, указанного в первом аргументе
командной строки, в стандартный вывод. Диапазон выдаваемых байт задаётся
смещением и длиной во втором и третьем аргументах командной
строки. Программа создаёт отображение требуемых страниц файла и затем
использует \fBwrite\fP(2) для вывода запрошенных байт.
.nf

#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define handle_error(msg) \e
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
    char *addr;
    int fd;
    struct stat sb;
    off_t offset, pa_offset;
    size_t length;
    ssize_t s;

    if (argc < 3 || argc > 4) {
        fprintf(stderr, "%s файл смещение [длина]\en", argv[0]);
        exit(EXIT_FAILURE);
    }

    fd = open(argv[1], O_RDONLY);
    if (fd == \-1)
        handle_error("open");

    if (fstat(fd, &sb) == \-1)           /* получение размера файла */
        handle_error("fstat");

    offset = atoi(argv[2]);
    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) \- 1);
        /* для mmap() нужно выронить смещение */

    if (offset >= sb.st_size) {
        fprintf(stderr, "указанное смещение находится за концом файла\en");
        exit(EXIT_FAILURE);
    }

    if (argc == 4) {
        length = atoi(argv[3]);
        if (offset + length > sb.st_size)
            length = sb.st_size \- offset;
                /* Нельзя показать байты за концом файла */

    } else {    /* Не указана длина ==> показать всё до конца файла */
        length = sb.st_size \- offset;
    }

    addr = mmap(NULL, length + offset \- pa_offset, PROT_READ,
                MAP_PRIVATE, fd, pa_offset);
    if (addr == MAP_FAILED)
        handle_error("mmap");

    s = write(STDOUT_FILENO, addr + offset \- pa_offset, length);
    if (s != length) {
        if (s == \-1)
            handle_error("write");

        fprintf(stderr, "частичная запись");
        exit(EXIT_FAILURE);
    }

    exit(EXIT_SUCCESS);
}
.fi
.SH "СМОТРИТЕ ТАКЖЕ"
\fBgetpagesize\fP(2), \fBmincore\fP(2), \fBmlock\fP(2), \fBmmap2\fP(2), \fBmprotect\fP(2),
\fBmremap\fP(2), \fBmsync\fP(2), \fBremap_file_pages\fP(2), \fBsetrlimit\fP(2),
\fBshmat\fP(2), \fBshm_open\fP(3), \fBshm_overview\fP(7)
.br
B.O. Gallmeister, POSIX.4, O'Reilly, стр. 128\-129 и 389\-391.
.\"
.\" Repeat after me: private read-only mappings are 100% equivalent to
.\" shared read-only mappings. No ifs, buts, or maybes. -- Linus

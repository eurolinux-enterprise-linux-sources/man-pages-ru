.\" -*- nroff -*-
.\" Copyright (C) 2007 Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (C) 1995 Michael Shields <shields@tembel.org>.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and author of this work.
.\"
.\" Modified 1996-10-22 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 1997-05-31 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 2003-08-24 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 2004-08-16 by Andi Kleen <ak@muc.de>
.\" 2007-06-02, mtk: Fairly substantial rewrites and additions, and
.\" a much improved example program.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MPROTECT 2 2011\-09\-08 Linux "Руководство программиста Linux"
.SH ИМЯ
mprotect \- контролирует доступ к области памяти
.SH ОБЗОР
.nf
\fB#include <sys/mman.h>\fP
.sp
\fBint mprotect(const void *\fP\fIaddr\fP\fB, size_t \fP\fIlen\fP\fB, int \fP\fIprot\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Вызов \fBmprotect\fP() изменяет параметры защиты страниц памяти вызывающего
процесса, которые содержатся, даже частично, в адресном диапазоне [\fIaddr\fP,\ \fIaddr\fP+\fIlen\fP\-1]. Значение \fIaddr\fP должно быть выровнено на границу
страницы.

Если вызывающий процесс производит запрещённый доступ к памяти, то ядро
посылает процессу сигнал \fBSIGSEGV\fP.
.PP
Значением \fIprot\fP может быть или \fBPROT_NONE\fP, или побитово сложенные
значения из следующего списка:
.TP  1.1i
\fBPROT_NONE\fP
Доступ к памяти запрещён.
.TP 
\fBPROT_READ\fP
Память можно читать.
.TP 
\fBPROT_WRITE\fP
Память можно изменять.
.TP 
\fBPROT_EXEC\fP
.\" FIXME
.\" Document PROT_GROWSUP and PROT_GROWSDOWN
Память можно выполнять.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При нормальном завершении работы \fBmprotect\fP()  возвращает ноль. При ошибках
возвращается \-1, а переменной \fIerrno\fP присваивается соответствующее
значение.
.SH ОШИБКИ
.TP 
\fBEACCES\fP
Нельзя задать этот вид доступа. Например, это может случиться, если при
вызове \fBmmap\fP(2) файл доступен только на чтение, а запрос \fBmprotect\fP() был
\fBPROT_WRITE\fP.
.TP 
\fBEINVAL\fP
.\" Or: both PROT_GROWSUP and PROT_GROWSDOWN were specified in 'prot'.
Значение \fIaddr\fP не является правильным указателем или не кратен размеру
системной страницы.
.TP 
\fBENOMEM\fP
Не удалось выделить место под внутренние структуры ядра.
.TP 
\fBENOMEM\fP
Адреса в диапазоне [\fIaddr\fP, \fIaddr\fP+\fIlen\fP\-1] некорректны для адресного
пространства процесса, или одна или более указанных страниц не отображена
(до ядра версии 2.4.19 в этих случаях некорректно возвращалась ошибка
\fBEFAULT\fP).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
.\" SVr4 defines an additional error
.\" code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
SVr4, POSIX.1\-2001. В POSIX указано, что поведение \fBmprotect\fP() не
определено, если задаётся область памяти, которая не получена через
\fBmmap\fP(2).
.SH ЗАМЕЧАНИЯ
В Linux всегда можно вызвать \fBmprotect\fP() с любым адресом из адресного
пространства процесса (за исключением области ядра vsyscall). В частности,
это можно использовать для изменения отображений существующего кода на
записываемые.

Отличия в работе между \fBPROT_EXEC\fP и \fBPROT_READ\fP зависят от архитектуры и
версии ядра. На некоторых аппаратных архитектурах (например, i386)
\fBPROT_WRITE\fP подразумевает \fBPROT_READ\fP.

В POSIX.1\-2001 сказано, что реализация может разрешить доступ отличный от
указанного в \fIprot\fP, но для доступа на запись должен быть обязательно
установлен флаг \fBPROT_WRITE\fP, и любой доступ должен быть запрещён, если
установлен флаг \fBPROT_NONE\fP.
.SH ПРИМЕР
.\" sigaction.2 refers to this example
.PP
Программа, представленная далее, выделяет четыре страницы памяти, делает
третью доступной только на чтение, а затем запускает цикл, который проходит
по выделенной области, меняя байты.

Результат работы программы:

.in +4n
.nf
$\fB ./a.out\fP
Начало области:             0x804c000
Получен SIGSEGV при адресе: 0x804e000
.fi
.in
.SS "Исходный код программы"
\&
.nf
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/mman.h>

#define handle_error(msg) \e
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

char *buffer;

static void
handler(int sig, siginfo_t *si, void *unused)
{
    printf("Получен SIGSEGV при адресе: 0x%lx\en",
            (long) si\->si_addr);
    exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
    char *p;
    int pagesize;
    struct sigaction sa;

    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    sa.sa_sigaction = handler;
    if (sigaction(SIGSEGV, &sa, NULL) == \-1)
        handle_error("sigaction");

    pagesize = sysconf(_SC_PAGE_SIZE);
    if (pagesize == \-1)
        handle_error("sysconf");

    /* выделить буфер с выравниванием на границу страницы;
       начальная защита: PROT_READ | PROT_WRITE */

    buffer = memalign(pagesize, 4 * pagesize);
    if (buffer == NULL)
        handle_error("memalign");

    printf("Начало области:             0x%lx\en", (long) buffer);

    if (mprotect(buffer + pagesize * 2, pagesize,
                PROT_READ) == \-1)
        handle_error("mprotect");

    for (p = buffer ; ; )
        *(p++) = \(aqa\(aq;

    printf("Цикл завершён\en");     /* никогда не должно случиться */
    exit(EXIT_SUCCESS);
}
.fi
.SH "СМОТРИТЕ ТАКЖЕ"
\fBmmap\fP(2), \fBsysconf\fP(3)

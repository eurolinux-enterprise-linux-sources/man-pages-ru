.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1996 Tom Bjorkholm <tomb@mydata.se>
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" 1996-04-11 Tom Bjorkholm <tomb@mydata.se>
.\"            First version written (1.3.86)
.\" 1996-04-12 Tom Bjorkholm <tomb@mydata.se>
.\"            Update for Linux 1.3.87 and later
.\" 2005-10-11 mtk: Added NOTES for MREMAP_FIXED; revised EINVAL text.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH MREMAP 2 2010\-06\-10 Linux "Руководство программиста Linux"
.SH ИМЯ
mremap \- изменяет отображение адреса виртуальной памяти
.SH ОБЗОР
.nf
\fB#define _GNU_SOURCE\fP         /* см. feature_test_macros(7) */
.br
\fB#include <sys/mman.h>\fP
.sp
\fBvoid *mremap(void *\fP\fIold_address\fP\fB, size_t \fP\fIold_size\fP\fB,\fP
\fB             size_t \fP\fInew_size\fP\fB, int \fP\fIflags\fP\fB, ... /* void *\fP\fInew_address\fP\fB */);\fP
.fi
.SH ОПИСАНИЕ
Вызов \fBmremap\fP() увеличивает (или уменьшает) размер существующего
отображения памяти, при необходимости, перемещая его (это контролируется
аргументом \fIflags\fP и доступным виртуальным адресным пространством).

В \fIold_address\fP указывается старый адрес блока виртуальной памяти, который
вы хотите изменить. Заметим, что \fIold_address\fP должен быть выровнен по
границе страницы. В \fIold_size\fP задаётся старый размер блока виртуальной
памяти. В \fInew_size\fP задаётся запрашиваемый размер блока виртуальной памяти
после изменения. Описание необязательного пятого аргумента \fInew_address\fP
смотрите далее в параграфе о \fBMREMAP_FIXED\fP.

В Linux память делится на страницы. Пользовательскому процессу выделяется
один или несколько непрерывных сегментов виртуальной памяти. Каждый из этих
сегментов имеет одно или несколько отображений в реальных страницах памяти
(в таблице страниц). У каждого виртуального сегмента памяти есть своя защита
(права доступа), которые можно нарушить, если произвести попытку
некорректного доступа (например, записать информацию в сегмент, который
доступен только для чтения). Доступ к виртуальной памяти за пределами
сегментов также приводит к ошибке сегментации.

Вызов \fBmremap\fP() использует схему табличных страниц Linux. \fBmremap\fP()
изменяет отображение между виртуальными адресами и страницами памяти. Это
можно использовать при реализации очень эффективной функции \fBrealloc\fP(3).

Аргумент битовой маски \fIflags\fP может быть равен 0 или содержать следующие
флаги:
.TP 
\fBMREMAP_MAYMOVE\fP
По умолчанию, если для расширения отображения недостаточно пространства в
текущем расположении, то вызов \fBmremap\fP() завершается с ошибкой. Если
указан флаг, то, если нужно, ядру разрешается переместить отображение на
новый виртуальный адрес. Если отображение перемещено, то абсолютные
указатели в старом расположении отображения становятся недействительными
(должно быть выполнено смещение относительно начального адреса отображения).
.TP 
\fBMREMAP_FIXED\fP (начиная с Linux 2.3.31)
Этот флаг играет ту же роль, что и \fBMAP_FIXED\fP для \fBmmap\fP(2). Если указан
этот флаг, то \fBmremap\fP() учитывает пятый аргумент \fIvoid *new_address\fP, в
котором задан выровненный на страницу адрес, куда должно быть перемещено
отображение. Все предыдущие отображения в адресном диапазоне, задаваемом
\fInew_address\fP и \fInew_size\fP, удаляются. При указании \fBMREMAP_FIXED\fP также
должен быть указан \fBMREMAP_MAYMOVE\fP.
.PP
Если сегмент памяти, указанный \fIold_address\fP и \fIold_size\fP, заблокирован (с
помощью \fBmlock\fP(2) или подобного вызова), то эта блокировка останется при
изменении/перемещении сегмента. Следовательно, количество заблокированной
процессом памяти может измениться.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении \fBmremap\fP() возвращается указатель на новую
виртуальную область памяти. При ошибке, возвращается значение \fBMAP_FAILED\fP
(то есть \fI(void\ *)\ \-1\fP), а \fIerrno\fP устанавливается в соответствующее
значение.
.SH ОШИБКИ
.TP 
\fBEAGAIN\fP
Вызывающий пытается расширить заблокированный сегмент памяти, но это
невозможно без превышения предела ресурса \fBRLIMIT_MEMLOCK\fP.
.TP 
\fBEFAULT\fP
«Ошибка сегментации (Segmentation fault).» Один из адресов в диапазоне от
\fIold_address\fP до \fIold_address\fP+\fIold_size\fP является некорректным адресом
виртуальной памяти для этого процесса. Также вы можете получить \fBEFAULT\fP
даже если существующие отображения покрывают всё запрошенное адресное
пространство, но имеют различные типы.
.TP 
\fBEINVAL\fP
Задан неправильный параметр. Возможные случаи: \fIold_address\fP не выровнен по
размеру страницы; в \fIflags\fP указано значение, отличное от \fBMREMAP_MAYMOVE\fP
или \fBMREMAP_FIXED\fP; значение \fInew_size\fP равно нулю; некорректное значение
\fInew_size\fP или \fInew_address\fP; новый адресный диапазон, заданный
\fInew_address\fP и \fInew_size\fP, перекрывается со старым адресным диапазоном,
задаваемым \fIold_address\fP и \fIold_size\fP; указан флаг \fBMREMAP_FIXED\fP без
флага \fBMREMAP_MAYMOVE\fP.
.TP 
\fBENOMEM\fP
Область памяти не может быть расширена от текущего виртуального адреса и в
\fIflags\fP не указано значение \fBMREMAP_MAYMOVE\fP. Или недостаточно свободной
(виртуальной) памяти.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
.\" 4.2BSD had a (never actually implemented)
.\" .BR mremap (2)
.\" call with completely different semantics.
Данный вызов существует только в Linux и не должен использоваться в
программах, которые должны быть переносимыми.
.SH ЗАМЕЧАНИЯ
До версии 2.4, в glibc не был определён флаг \fBMREMAP_FIXED\fP, а прототип
\fBmremap\fP() не позволял указывать аргумент \fInew_address\fP.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBbrk\fP(2), \fBgetpagesize\fP(2), \fBgetrlimit\fP(2), \fBmlock\fP(2), \fBmmap\fP(2),
\fBsbrk\fP(2), \fBmalloc\fP(3), \fBrealloc\fP(3)
.P
Описание страничной памяти в вашей любимой книге по операционным системам.
(\fIСовременные операционные системы\fP Эндрю С. Таненбаума, \fIВнутри Linux\fP
Рэндольфа Бентсона, \fIАрхитектура операционной системы UNIX \fP Мориса
Дж. Баха.)

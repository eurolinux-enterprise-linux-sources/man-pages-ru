.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" This manpage is Copyright (C) 1992 Drew Eckhardt;
.\"                               1993 Michael Haardt, Ian Jackson.
.\"                               2008 Greg Banks
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified 1993-07-21 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1994-08-21 by Michael Haardt
.\" Modified 1996-04-13 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 1996-05-13 by Thomas Koenig
.\" Modified 1996-12-20 by Michael Haardt
.\" Modified 1999-02-19 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 1998-11-28 by Joseph S. Myers <jsm28@hermes.cam.ac.uk>
.\" Modified 1999-06-03 by Michael Haardt
.\" Modified 2002-05-07 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified 2004-06-23 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" 2004-12-08, mtk, reordered flags list alphabetically
.\" 2004-12-08, Martin Pool <mbp@sourcefrog.net> (& mtk), added O_NOATIME
.\" 2007-09-18, mtk, Added description of O_CLOEXEC + other minor edits
.\" 2008-01-03, mtk, with input from Trond Myklebust
.\"     <trond.myklebust@fys.uio.no> and Timo Sirainen <tss@iki.fi>
.\"     Rewrite description of O_EXCL.
.\" 2008-01-11, Greg Banks <gnb@melbourne.sgi.com>: add more detail
.\"     on O_DIRECT.
.\" 2008-02-26, Michael Haardt: Reorganized text for O_CREAT and mode
.\"
.\" FIXME . Apr 08: The next POSIX revision has O_EXEC, O_SEARCH, and
.\" O_TTYINIT.  Eventually these may need to be documented.  --mtk
.\" FIXME Linux 2.6.33 has O_DSYNC, and a hidden __O_SYNC.
.\" FIXME: Linux 2.6.39 added O_PATH
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH OPEN 2 2012\-05\-01 Linux "Руководство программиста Linux"
.SH ИМЯ
open, creat \- открывает и, возможно, создаёт файл или устройство
.SH ОБЗОР
.nf
\fB#include <sys/types.h>\fP
\fB#include <sys/stat.h>\fP
\fB#include <fcntl.h>\fP
.sp
\fBint open(const char *\fP\fIpathname\fP\fB, int \fP\fIflags\fP\fB);\fP
\fBint open(const char *\fP\fIpathname\fP\fB, int \fP\fIflags\fP\fB, mode_t \fP\fImode\fP\fB);\fP

\fBint creat(const char *\fP\fIpathname\fP\fB, mode_t \fP\fImode\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Получив в \fIpathname\fP имя файла, \fBopen\fP() возвращает файловый дескриптор
\(em небольшое, неотрицательное значение \(em для использования в
последующих системных вызовах (\fBread\fP(2), \fBwrite\fP(2), \fBlseek\fP(2),
\fBfcntl\fP(2) и т.д.). Файловый дескриптор, возвращаемый при успешном
выполнении вызова, будет самым маленьким числом из файловых дескрипторов,
которые ещё не открыты процессом.
.PP
По умолчанию, новый файловый дескриптор остаётся открытым при вызове
\fBexecve\fP(2) (т.е., флаг \fBFD_CLOEXEC\fP файлового дескриптора, описанный в
\fBfcntl\fP(2), изначально сброшен; для изменения поведения по умолчанию можно
использовать флаг \fBO_CLOEXEC\fP, он описан далее). Файловое смещение
устанавливается на начало файла (см. \fBlseek\fP(2)).
.PP
Вызов \fBopen\fP() создаёт новое \fIоткрытое файловое описание\fP \(em запись в
системной таблице открытых файлов. В этой записи хранится смещение и флаги
состояния файла (изменяются через \fBfcntl\fP(2), операция
\fBF_SETFL\fP). Файловый дескриптор является ссылкой на одну из таких записей;
с этой ссылкой ничего не происходит при последующем удалении \fIимени файла\fP
или переуказании имени на другой файл. Изначально, новое открытое файловое
описание не используется разными процессами совместно, но такого общего
использования можно достичь, вызвав \fBfork\fP(2).
.PP
Параметр \fIflags\fP должен содержать один из следующих \fIрежимов доступа\fP:
\fBO_RDONLY\fP (только для чтения), \fBO_WRONLY\fP (только для записи) или
\fBO_RDWR\fP (для чтения и записи).

.\" FIXME . Actually is it true that the "file status flags" are all of the
.\" remaining flags listed below?  SUSv4 divides the flags into:
.\" * Access mode
.\" * File creation
.\" * File status
.\" * Other (O_CLOEXEC, O_DIRECTORY, O_NOFOLLOW)
.\" though it's not clear what the difference between "other" and
.\" "File creation" flags is.  (I've raised an Aardvark to see if this
.\" can be clarified in SUSv4; 10 Oct 2008.)
Кроме них в \fIflags\fP можно указывать флаги создания и состояния файла,
объединяя их битовой операцией \fIИЛИ\fP. \fIФлаги создания файла\fP: \fBO_CREAT\fP,
\fBO_EXCL\fP, \fBO_NOCTTY\fP и \fBO_TRUNC\fP. \fIФлаги состояния файла\fP \(em все
оставшиеся из перечисленных ниже. Различие между двумя этими группами в том,
что флаги состояния можно запросить и (в некоторых случаях) изменить с
помощью \fBfcntl\fP(2). Вот полный список флагов создания и состояния файла:
.TP 
\fBO_APPEND\fP
.\" For more background, see
.\" http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
.\" http://nfs.sourceforge.net/
Файл открывается в режиме добавления. Перед каждым вызовом \fBwrite\fP(2)
файловое смещение устанавливается в конец файла, как если бы это делалось с
помощью \fBlseek\fP(2). Флаг \fBO_APPEND\fP может приводить к повреждению файлов в
файловой системе NFS, если одновременно добавляют данные в файл несколько
процессов. Это происходит из\-за того, что NFS не поддерживает добавление в
файл, поэтому клиентское ядро имитирует такое поведение, но при этом нельзя
избежать состязательности процессов.
.TP 
\fBO_ASYNC\fP
Включает ввод\-вывод, управляемый сигналом: генерирует сигнал (по умолчанию
\fBSIGIO\fP, но можно изменить с помощью \fBfcntl\fP(2)), когда становится
возможным ввод или вывод для этого файлового дескриптора. Эта возможность
доступна только для терминалов, псевдо\-терминалов, сокетов, каналов (начиная
с Linux 2.6) и FIFO. Подробней см. \fBfcntl\fP(2).
.TP 
\fBO_CLOEXEC\fP (начиная с Linux 2.6.23)
.\" This flag fixes only one form of the race condition;
.\" The race can also occur with, for example, descriptors
.\" returned by accept(), pipe(), etc.
Устанавливает флаг close\-on\-exec на новом файловом дескрипторе. Указание
данного флага позволяет программе избежать дополнительных операций
\fBfcntl\fP(2) \fBF_SETFD\fP для установки флага \fBFD_CLOEXEC\fP. Также,
использование этого флага обязательно для некоторых многонитиевых программ,
так как использование отдельной операции \fBfcntl\fP(2) \fBF_SETFD\fP для
установки флага \fBFD_CLOEXEC\fP недостаточно для избежания состязательности,
когда одна нить открывает файловый дескриптор, а в тоже время другая нить
может выполнять \fBfork\fP(2) и \fBexecve\fP(2).
.TP 
\fBO_CREAT\fP
.\" As at 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
.\" XFS (since 2.6.14).
Если файл не существует, то он будет создан. Владелец (идентификатор
пользователя) файла устанавливается в значение эффективного идентификатора
пользователя процесса. Группа (идентификатор группы) устанавливается либо в
значение эффективного идентификатора группы процесса, либо в значение
идентификатора группы родительского каталога (зависит от типа файловой
системы, параметров монтирования и режима родительского каталога,
см. например, параметры монтирования \fIbsdgroups\fP и \fIsysvgroups\fP, описанные
в \fBmount\fP(8)).
.RS
.PP
В аргументе \fImode\fP указываются права использования, которые используются
при создании нового файла. Этот параметр должен указываться, если в \fIflags\fP
устанавливается \fBO_CREAT\fP; если \fBO_CREAT\fP не задан, то \fImode\fP
игнорируется. Эффективные права изменяются согласно \fIumask\fP процесса как
обычно: права созданного файла будут установлены согласно \fI(mode\ &\ ~umask)\fP. Заметим, что этот режим будет учтён только при последующих
обращениях к созданному файлу; вызов \fBopen\fP(), создающий файл только для
чтения, может вернуть файловый дескриптор доступный на чтение и запись.
.PP
Символьные константы, используемые в \fImode\fP:
.TP  9
\fBS_IRWXU\fP
00700 пользователь (владелец файла) имеет права на чтение, запись и
выполнение файла
.TP 
\fBS_IRUSR\fP
00400 пользователь имеет права на чтение файла
.TP 
\fBS_IWUSR\fP
00200 пользователь имеет права на запись в файл
.TP 
\fBS_IXUSR\fP
00100 пользователь имеет права на выполнение файла
.TP 
\fBS_IRWXG\fP
00070 группа имеет права на чтение, запись и выполнение файла
.TP 
\fBS_IRGRP\fP
00040 группа имеет права на чтение файла
.TP 
\fBS_IWGRP\fP
00020 группа имеет права на запись в файл
.TP 
\fBS_IXGRP\fP
00010 группа имеет права на выполнение файла
.TP 
\fBS_IRWXO\fP
00007 все остальные имеют права на чтение, запись и выполнение файла
.TP 
\fBS_IROTH\fP
00004 все остальные имеют права на чтение файла
.TP 
\fBS_IWOTH\fP
00002 все остальные имеют права на запись в файл
.TP 
\fBS_IXOTH\fP
00001 все остальные имеют права на выполнение файла
.RE
.TP 
\fBO_DIRECT\fP (начиная с Linux 2.4.10)
Попытаться минимизировать влияние кэширования ввода\-вывода при чтении и
записи в файл. Обычно, это ухудшает производительность, но полезно для
особых случаев, например, когда приложение выполняет кэширование
самостоятельно. Файловый ввод\-вывод выполняется непосредственно в/из буферов
пространства пользователя. При флаге \fBO_DIRECT\fP предпринимаются все усилия
для синхронной передачи данных, но это не гарантирует, как с флагом
\fBO_SYNC\fP, передачу данных и необходимых метаданных. Чтобы гарантировать
синхронный ввод\-вывод вместе с \fBO_DIRECT\fP нужно использовать
\fBO_SYNC\fP. Дальнейшее описание смотрите далее в разделе ЗАМЕЧАНИЯ.
.sp
Семантически похожий интерфейс (но устаревший) для блочных устройств описан
в \fBraw\fP(8).
.TP 
\fBO_DIRECTORY\fP
.\" But see the following and its replies:
.\" http://marc.theaimsgroup.com/?t=112748702800001&r=1&w=2
.\" [PATCH] open: O_DIRECTORY and O_CREAT together should fail
.\" O_DIRECTORY | O_CREAT causes O_DIRECTORY to be ignored.
Если \fIpathname\fP не является каталогом, то завершить вызов с ошибкой. Этот
флаг используется только в Linux и был добавлен в ядро версии 2.1.126, чтобы
избежать проблем с «отказом в обслуживании», если \fBopendir\fP(3) был вызван
для канала FIFO или ленточного устройства. Этот флаг не следует использовать
вне реализации \fBopendir\fP(3).
.TP 
\fBO_EXCL\fP
Гарантирует, что вызов создаст файл: если этот флаг указан вместе с
\fBO_CREAT\fP и \fIpathname\fP уже существует, то \fBopen\fP() завершится с ошибкой.

.\" POSIX.1-2001 explicitly requires this behavior.
При использовании обоих флагов символьные ссылки не поддерживаются: если
\fIpathname\fP является символьной ссылкой, то \fBopen\fP() завершается с ошибкой
независимо от того, куда указывает ссылка.

Вообще говоря, поведение с \fBO_EXCL\fP не определено, если этот флаг
используется без \fBO_CREAT\fP. Есть одно исключение: в Linux 2.6 и более новых
\fBO_EXCL\fP можно использовать без \fBO_CREAT\fP, если \fIpathname\fP указывает на
блочное устройство. Если блочное устройство используется в системе
(например, смонтировано), то \fBopen\fP() завершится с ошибкой \fBEBUSY\fP.

Флаг \fBO_EXCL\fP поддерживается для NFS только, если используется NFSv3 или
новее с ядром 2.6 или новее. В средах, где в NFS нет поддержки \fBO_EXCL\fP,
программы, которые полагаются на это для выполнения задач блокировок, будут
создавать состязательность процессов. Переносимым программам, которым нужно
произвести атомарную блокировку файла с помощь файла блокировки, необходимо
избегать зависимости от поддержки в NFS флага \fBO_EXCL\fP. В качестве решения
можно создать уникальный файл в той же файловой системе (например, добавив
имя узла и PID в название), чтобы создать ссылку на файл блокировки с
помощью \fBlink\fP(2). Если \fBlink\fP(2) возвращает 0, то блокировка выполнена. В
противном случае используйте \fBstat\fP(2), чтобы убедиться, что количество
ссылок на уникальный файл возросло до двух. Это также означает, что
блокировка была успешной.
.TP 
\fBO_LARGEFILE\fP
(LFS) Позволяет открывать файлы, чей размер нельзя представить типом
\fIoff_t\fP (но можно представить типом \fIoff64_t\fP). Для получения этого
определения должен быть указан макрос \fB_LARGEFILE64_SOURCE\fP (до включения
\fIкакого\-либо\fP заголовочного файла). Установка макроса тестирования
возможностей \fB_FILE_OFFSET_BITS\fP в значение 64 (вместо использования
\fBO_LARGEFILE\fP) является предпочтительным методом доступа к большим файлам
на 32\-битных системах (см. \fBfeature_test_macros\fP(7)).
.TP 
\fBO_NOATIME\fP (начиная с Linux 2.6.8)
.\" The O_NOATIME flag also affects the treatment of st_atime
.\" by mmap() and readdir(2), MTK, Dec 04.
Не обновлять время последнего доступа к файлу (st_atime в inode) при его
чтении \fBread\fP(2). Этот флаг предназначен для использования в программах
индексирования и резервного копирования; он позволяет значительно сократить
количество обращений к диску. Флаг может быть не эффективен на некоторых
файловых системах. Например, на NFS, где запись времени доступа выполняется
сервером.
.TP 
\fBO_NOCTTY\fP
Если \fIpathname\fP указывает на терминальное устройство (см. \fBtty\fP(4)), то
оно не станет управляющим терминалом процесса, даже если процесс такового не
имеет.
.TP 
\fBO_NOFOLLOW\fP
.\" The headers from glibc 2.0.100 and later include a
.\" definition of this flag; \fIkernels before 2.1.126 will ignore it if
.\" used\fP.
Если \fIpathname\fP является символьной ссылкой, то открытие завершится
неудачно. Это расширение FreeBSD, которое было добавлено в Linux версии
2.1.126. Все прочие символьные ссылки в имени будут обработаны как обычно.
.TP 
\fBO_NONBLOCK\fP или \fBO_NDELAY\fP
Если возможно, файл открывается в неблокирующем режиме. Ни \fBopen\fP(), ни
другие последующие операции над возвращаемым дескриптором файла не заставят
вызывающий процесс ждать. Для работы с каналами FIFO также смотрите
\fBfifo\fP(7). Обсуждение влияния \fBO_NONBLOCK\fP в сочетании с обязательной
файловой блокировкой или арендой (lease) смотрите в \fBfcntl\fP(2).
.TP 
\fBO_SYNC\fP
Файл открывается в режиме синхронного ввода\-вывода. Все вызовы \fBwrite\fP(2)
для соответствующего дескриптора файла блокируют вызывающий процесс до тех
пор, пока данные не будут физически записаны. \fIОднако, прочитайте раздел
ЗАМЕЧАНИЯ\fP.
.TP 
\fBO_TRUNC\fP
Если файл уже существует и является обычным файлом и режим открытия
позволяет записывать в этот файл (т.е. установлен флаг \fBO_RDWR\fP или
\fBO_WRONLY\fP), то его длина будет урезана до нуля. Если файл является FIFO
или терминальным устройством, то этот флаг игнорируется. В других случаях
действие флага \fBO_TRUNC\fP не определено.
.PP
Некоторые из этих необязательных флагов могут быть изменены с помощью
\fBfcntl\fP(2) после открытия файла.

Вызов \fBcreat\fP() эквивалентен \fBopen\fP() с \fIflags\fP, имеющим значение
\fBO_CREAT|O_WRONLY|O_TRUNC\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
Вызовы \fBopen\fP() и \fBcreat\fP() возвращают новый дескриптор файла или \-1 в
случае ошибки (в этом случае \fIerrno\fP устанавливается в соответствующее
значение).
.SH ОШИБКИ
.TP 
\fBEACCES\fP
Запрошенный доступ к файлу не разрешён, или один из каталогов в \fIpathname\fP
не позволяет поиск, файл ещё не существует, или доступ для записи в
родительский каталог не разрешён (см. также \fBpath_resolution\fP(7)).
.TP 
\fBEEXIST\fP
\fIpathname\fP уже существует, то были указаны \fBO_CREAT\fP и \fBO_EXCL\fP.
.TP 
\fBEFAULT\fP
Аргумент \fIpathname\fP указывает за пределы доступного адресного пространства.
.TP 
\fBEFBIG\fP
Смотрите \fBEOVERFLOW\fP.
.TP 
\fBEINTR\fP
При блокирующем ожидании завершения открытия медленного устройства
(например, FIFO; см. \fBfifo\fP(7)), вызов был прерван обработчиком сигнала;
смотрите \fBsignal\fP(7).
.TP 
\fBEISDIR\fP
\fIpathname\fP указывает на каталог и тип доступа подразумевает запись ( то
есть установлен флаг \fBO_WRONLY\fP или \fBO_RDWR\fP).
.TP 
\fBELOOP\fP
Слишком много символьных ссылок пройдено при разрешении \fIpathname\fP, или
задан \fBO_NOFOLLOW\fP, но \fIpathname\fP является символьной ссылкой.
.TP 
\fBEMFILE\fP
Процесс уже открыл максимально допустимое количество файлов.
.TP 
\fBENAMETOOLONG\fP
\fIpathname\fP слишком длинен.
.TP 
\fBENFILE\fP
Достигнуто максимальное количество открытых файлов в системе.
.TP 
\fBENODEV\fP
\fIpathname\fP ссылается на специальный файл устройства, но соответствующего
устройства не существует (это ошибка в ядре Linux: должно возвращаться
\fBENXIO\fP).
.TP 
\fBENOENT\fP
Флаг \fBO_CREAT\fP не задан и файл с таким именем не существует, или же не
существует один из каталогов в \fIpathname\fP, или имеется повисшая символьная
ссылка.
.TP 
\fBENOMEM\fP
Недостаточное количество памяти ядра.
.TP 
\fBENOSPC\fP
Файл \fIpathname\fP должен быть создан, но на устройстве его содержащем нет
места для нового файла.
.TP 
\fBENOTDIR\fP
Компонент, который обозначен как каталог в \fIpathname\fP, таковым не является,
или был указан флаг \fBO_DIRECTORY\fP, но \fIpathname\fP не является каталогом.
.TP 
\fBENXIO\fP
Указаны флаги \fBO_NONBLOCK\fP | \fBO_WRONLY\fP, файл является каналом FIFO, но
нет процесса, который открыл этот канал для чтения. Возможно также, что файл
является специальным файлом устройства, но соответствующее устройство не
существует.
.TP 
\fBEOVERFLOW\fP
.\" See http://bugzilla.kernel.org/show_bug.cgi?id=7253
.\" "Open of a large file on 32-bit fails with EFBIG, should be EOVERFLOW"
.\" Reported 2006-10-03
\fIpathname\fP ссылается на обычный файл, который слишком велик для
открытия. Обычно, это случается когда приложение, скомпилированное на
32\-битной платформе без \fI\-D_FILE_OFFSET_BITS=64\fP, пытается открыть файл
размером более \fI(2<<31)\-1\fP бит; смотрите также описание
\fBO_LARGEFILE\fP ранее. Эта ошибка определена в POSIX.1\-2001; в ядрах до
версии 2.6.24 Linux в этом случае выдавал ошибку \fBEFBIG\fP.
.TP 
\fBEPERM\fP
.\" Strictly speaking, it's the file system UID... (MTK)
Задан флаг \fBO_NOATIME\fP, но эффективный ID пользователя вызывающего процесса
не совпадает с владельцем файла и вызывающий не имеет прав (\fBCAP_FOWNER\fP).
.TP 
\fBEROFS\fP
\fIpathname\fP указывает на файл на файловой системе, доступной только на
чтение, но запрашивается доступ на запись.
.TP 
\fBETXTBSY\fP
\fIpathname\fP указывает на исполняемый файл, который запущен в данный момент,
но запрашивается доступ на запись.
.TP 
\fBEWOULDBLOCK\fP
Указан флаг \fBO_NONBLOCK\fP, но несовместимая аренда (lease) удерживает файл
(смотрите \fBfcntl\fP(2)).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
SVr4, 4.3BSD, POSIX.1\-2001. Флаги \fBO_DIRECTORY\fP, \fBO_NOATIME\fP и
\fBO_NOFOLLOW\fP есть только в Linux, и для их определения может потребоваться
задать \fB_GNU_SOURCE\fP (до включения \fIкакого\-либо\fP заголовочного файла).

Флаг \fBO_CLOEXEC\fP не определён в POSIX.1\-2001, но есть в POSIX.1\-2008.

Флаг \fBO_DIRECT\fP не определён в POSIX; для его определения задайте
\fB_GNU_SOURCE\fP (до включения \fIкакого\-либо\fP заголовочного файла).
.SH ЗАМЕЧАНИЯ
В Linux флаг \fBO_NONBLOCK\fP указывает, что файл нужно открыть, но не
обязательно будет производиться чтение или запись. Обычно это указывается
для открытия устройства, чтобы получить его файловый дескриптор для
использования в \fBioctl\fP(2).

.\" See for example util-linux's disk-utils/setfdprm.c
.\" For some background on access mode 3, see
.\" http://thread.gmane.org/gmane.linux.kernel/653123
.\" "[RFC] correct flags to f_mode conversion in __dentry_open"
.\" LKML, 12 Mar 2008
В отличие от других значений, указываемых в \fIflags\fP, значения \fIрежима
доступа\fP \fBO_RDONLY\fP, \fBO_WRONLY\fP и \fBO_RDWR\fP, не определяются отдельными
битами. Точнее, они задаются двумя первыми битами \fIflags\fP, и имеют значения
0, 1 и 2, соответственно. Другими словами, комбинация \fBO_RDONLY | O_WRONLY\fP
приводит к логической ошибке и точно не работает как \fBO_RDWR\fP. В Linux
зарезервирован специальный нестандартный режим доступа 3 (11 двоичное) в
\fIflags\fP, при котором: проверяются права на чтение и запись к файлу и
возвращается дескриптор, который не может использоваться для чтения или
записи. Данный нестандартный режим доступа используется некоторыми
драйверами Linux для получения дескриптора, который будет использоваться в
\fBioctl\fP(2) только для специальных операций с устройством.
.LP
.\" Linux 2.0, 2.5: truncate
.\" Solaris 5.7, 5.8: truncate
.\" Irix 6.5: truncate
.\" Tru64 5.1B: truncate
.\" HP-UX 11.22: truncate
.\" FreeBSD 4.7: truncate
Результат работы комбинации флагов \fBO_RDONLY | O_TRUNC\fP в разных
реализациях разный (нигде не определён). Во многих системах файл усекается.
.PP
В протоколе, по которому работает NFS, существует множество недоработок,
оказывающих влияние на многое, в том числе на работу с \fBO_SYNC\fP и
\fBO_NDELAY\fP.

В POSIX представлено три различных варианта синхронизированного
ввода\-вывода, соответствующих флагам \fBO_SYNC\fP, \fBO_DSYNC\fP и \fBO_RSYNC\fP. На
данный момент (2.6.31) в Linux реализован только \fBO_SYNC\fP, но glibc
проецирует \fBO_DSYNC\fP и \fBO_RSYNC\fP в то же числовое значение что и
\fBO_SYNC\fP. В большинстве файловых систем Linux, на самом деле, не
реализована семантика POSIX \fBO_SYNC\fP, которая требует записи всех
обновлённых метаданных на диск до возврата в пространство пользователя, а
только семантика \fBO_DSYNC\fP, по которой до возврата из вызова должны быть
реально записаны только данные файла и метаданные, необходимые для их
получения.

Заметим, что \fBopen\fP() может открывать специальные файлы устройств, но
\fBcreat\fP() не может их создавать; вместо этого используйте \fBmknod\fP(2).
.LP
В файловых системах NFS с включённым проецированием UID, \fBopen\fP() может
вернуть файловый дескриптор, но, например, запросы \fBread\fP(2) будут
отклонены с ошибкой \fBEACCES\fP. Это происходит из\-за того, что клиент
выполняет \fBopen\fP() проверяя одни права, но сервер выполняет проецирование
UID только при запросах чтения и записи.

Если файл только что был создан, его поля \fIst_atime\fP, \fIst_ctime\fP,
\fIst_mtime\fP (время последнего доступа, последней смены состояния и
последнего изменения, соответственно; см. \fBstat\fP(2)) устанавливаются в
значение текущего времени, и оно совпадает с полями \fIst_ctime\fP и
\fIst_mtime\fP родительского каталога. Или же, если файл изменяется из\-за
установленного флага \fBO_TRUNC\fP, то его поля st_ctime и st_mtime
устанавливаются в значение текущего времени.
.SS O_DIRECT
.LP
Флаг \fBO_DIRECT\fP может накладывать ограничения по выравниванию на длину и
адрес буфера пользовательского пространства и смещения файла при
вводе\-выводе. В Linux ограничения по выравниванию различны у разных файловых
систем и версий ядра, и даже могут отсутствовать. Однако сейчас не
существует независимого от файловой системы интерфейса приложения для
выявления этих ограничений на определённый файл или файловую
систему. Некоторые файловые системы предоставляют свои собственные
интерфейсы для этого, например, операция \fBXFS_IOC_DIOINFO\fP в \fBxfsctl\fP(3).
.LP
В Linux 2.4 размеры передачи, выравнивание пользовательского буфера и
файлового смещения должны быть кратны размеру логического блока файловой
системы. В Linux 2.6 достаточно выравнивания по 512\-байтовой границе.
.LP
Ввод\-вывод с \fBO_DIRECT\fP никогда не должен запускаться одновременно с
системным вызовом \fBfork\fP(2), если буфер памяти является закрытым
отображением (т. е., любым отображениям, созданным с помощью \fBmmap\fP(2) с
флагом \fBMAP_PRIVATE\fP; к ним относится память, выделенная под кучу и
статически выделенные буферы). Любой подобный ввод\-вывод, предоставленный
через асинхронный интерфейс или из другой нити процесса, должен выполниться
полностью до вызова \fBfork\fP(2). В противном случае, может произойти
повреждение данных и непредсказуемое поведение в процессе родителя и
потомка.Данное ограничение не действует, если буфер памяти для ввода\-вывода
с \fBO_DIRECT\fP был создан с помощью \fBshmat\fP(2) или \fBmmap\fP(2) с флагом
\fBMAP_SHARED\fP. И при этом это ограничение не действует, когда буфер памяти
был помечен (advised) как \fBMADV_DONTFORK\fP с помощью \fBmadvise\fP(2), если
точно известно, что он не будет доступен потомку после \fBfork\fP(2).
.LP
Флаг \fBO_DIRECT\fP появился в SGI IRIX, где ограничения на выравнивание
подобны Linux 2.4. В IRIX также есть вызов \fBfcntl\fP(2) для запроса значений
соответствующего выравнивания и размеров. В FreeBSD 4.x появился флаг с
таким же именем, но без ограничений на выравнивание.
.LP
Поддержка \fBO_DIRECT\fP добавлена в ядро Linux версии 2.4.10. Более старые
ядра Linux просто игнорируют этот флаг. В некоторых файловых системах этот
флаг может быть не реализован и \fBopen\fP() завершится с ошибкой \fBEINVAL\fP при
его использовании.
.LP
Приложения должны избегать смешивания \fBO_DIRECT\fP и обычных операций
ввода\-вывода в один файл и особенно перекрывать байтовые области. Даже когда
файловая система правильно обрабатывает проблемы с когерентностью в такой
ситуации, общая пропускная способность ввода\-вывода, вероятно, будет
медленнее чем при использовании какого\-то одного из этих режимов
отдельно. Аналогично приложения должны избегать смешивания \fBmmap\fP(2) и
прямого ввода\-вывода для одинаковых файлов.
.LP
Поведение \fBO_DIRECT\fP на NFS отличается от локальных файловых систем. Старые
ядра и ядра, настроенные определёнными способами, могут не поддерживать
такую комбинацию. Протокол NFS не поддерживает передачу флага на сервер,
поэтому ввод\-вывод с \fBO_DIRECT\fP будет пропускать кэширование страниц только
на клиенте; сервер всё равно может выполнить кэширование
ввода\-вывода. Клиент просит сервер выполнять операции ввода\-вывода синхронно
для сохранения синхронной семантики \fBO_DIRECT\fP. Некоторые серверы будут
выполнять это плохо при определённых условиях, особенно если размер данных
ввода\-вывод невелик. Некоторые серверы также могут быть настроены на
отправку ложного ответа клиентам о том, что ввод\-вывод произведён на
носитель; это позволяет избежать потери производительности, но есть риск
потери целостности данных в случае проблем с электропитанием сервера. В
Linux клиент NFS не устанавливает ограничений по выравниванию при
вводе\-выводе с \fBO_DIRECT\fP.
.PP
Флаг \fBO_DIRECT\fP является потенциально мощным инструментом, который нужно
использовать с осторожностью. Рекомендуется, чтобы приложения считали
использование \fBO_DIRECT\fP как параметр производительности, который по
умолчанию выключен.
.PP
.RS
«The thing that has always disturbed me about O_DIRECT is that the whole
interface is just stupid, and was probably designed by a deranged monkey on
some serious mind\-controlling substances.» — Linus (Меня всегда беспокоило
кое\-что относительно O_DIRECT — то, что вообще в целом этот интерфейс просто
идиотичен. Создаётся впечатление, что он как\-бы был создан сумасшедшей
обезьяной под веществами.)
.RE
.SH ДЕФЕКТЫ
.\" FIXME . Check bugzilla report on open(O_ASYNC)
.\" See http://bugzilla.kernel.org/show_bug.cgi?id=5993
На данный момент невозможно включить сигнальное управление вводом\-выводом,
указав \fBO_ASYNC\fP при вызове \fBopen\fP(); чтобы установить этот флаг
используйте \fBfcntl\fP(2).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBchmod\fP(2), \fBchown\fP(2), \fBclose\fP(2), \fBdup\fP(2), \fBfcntl\fP(2), \fBlink\fP(2),
\fBlseek\fP(2), \fBmknod\fP(2), \fBmmap\fP(2), \fBmount\fP(2), \fBopenat\fP(2), \fBread\fP(2),
\fBsocket\fP(2), \fBstat\fP(2), \fBumask\fP(2), \fBunlink\fP(2), \fBwrite\fP(2),
\fBfopen\fP(3), \fBfifo\fP(7), \fBpath_resolution\fP(7), \fBsymlink\fP(7)

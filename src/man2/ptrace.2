.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1993 Michael Haardt <michael@moria.de>
.\" Fri Apr  2 11:32:09 MET DST 1993
.\"
.\" and changes Copyright (C) 1999 Mike Coleman (mkc@acm.org)
.\" -- major revision to fully document ptrace semantics per recent Linux
.\"    kernel (2.2.10) and glibc (2.1.2)
.\" Sun Nov  7 03:18:35 CST 1999
.\"
.\" and Copyright (c) 2011, Denys Vlasenko <vda.linux@googlemail.com>
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" Modified Fri Jul 23 23:47:18 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified Fri Jan 31 16:46:30 1997 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified Thu Oct  7 17:28:49 1999 by Andries Brouwer <aeb@cwi.nl>
.\" Modified, 27 May 2004, Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added notes on capability requirements
.\"
.\" 2006-03-24, Chuck Ebbert <76306.1226@compuserve.com>
.\"    Added    PTRACE_SETOPTIONS, PTRACE_GETEVENTMSG, PTRACE_GETSIGINFO,
.\"        PTRACE_SETSIGINFO, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP
.\"    (Thanks to Blaisorblade, Daniel Jacobowitz and others who helped.)
.\" 2011-09, major update by Denys Vlasenko <vda.linux@googlemail.com>
.\"
.\" FIXME Linux 2.6.34 adds PTRACE_GETREGSET/PTRACE_SETREGSET
.\" FIXME Linux 3.1 adds PTRACE_SEIZE, PTRACE_INTERRUPT,
.\"                and PTRACE_LISTEN.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH PTRACE 2 2012\-04\-26 Linux "Руководство программиста Linux"
.SH ИМЯ
ptrace \- трассировка процесса
.SH ОБЗОР
.nf
\fB#include <sys/ptrace.h>\fP
.sp
\fBlong ptrace(enum __ptrace_request \fP\fIrequest\fP\fB, pid_t \fP\fIpid\fP\fB, \fP
\fB            void *\fP\fIaddr\fP\fB, void *\fP\fIdata\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Системный вызов \fBptrace\fP() позволяет указать какому процессу
(«трассировщику») можно наблюдать и контролировать выполнение другого
процесса («трассироемого»), просматривать и изменять его память и
регистры. Обычно, он используется для реализации отладочных точек прерывания
и для отслеживания системных вызовов.
.LP
Сначала, трассировщик должен присоединиться к трассируемой
нити. Присоединение и последующие команды выполняются для нитей: в
многонитиевом процессе трассировщик может подключаться как к каждой нити
(трассировщики могут быть у разных нитей разными), так и не подключаться к
некоторым нитям вовсе. Поэтому на самом деле «трассируемая нить»  всегда
означает «(одну) нить», а не «процесс в целом (возможно
многонитиевый)». Команды ptrace всегда посылаются определённой трассируемой
нити с помощью вызова

    ptrace(PTRACE_foo, pid, …)

где \fIpid\fP — идентификатор соответствующей нити Linux.
.LP
Заметим, что в этой странице «многонитиевый процесс» означает группу нитей,
состоящую из нитей, созданных с помощью \fBclone\fP(2) с флагом
\fBCLONE_THREAD\fP.
.LP
Процесс может начать трассировку с вызова \fBfork\fP(2), в получившемся
дочернем процессе выполнить действие \fBPTRACE_TRACEME\fP, после чего (обычно)
выполнить \fBexecve\fP(2). Или же один процесс может начать отладку другого
процесса при помощи \fBPTRACE_ATTACH\fP.
.LP
При трассировке трассируемая нить останавливается каждый раз при получении
сигнала, даже если этот сигнал игнорируется (исключением является
\fBSIGKILL\fP, работающий обычным образом). Трассировщик будет уведомлён об
этом при следующем вызове \fBwaitpid\fP(2) (или подобном «ожидающем» системном
вызове); этот вызов вернёт значение \fIstatus\fP, в котором содержится
информация, указывающая на причину остановки трассируемой нити. Так как
трассируемая нить остановлена, трассировщик может использовать различные
запросы ptrace для обследования и изменения трассируемой нити. По окончании
трассировщик разрешает трассируемой нити продолжить работу, возможно
подавляя посылаемый ему сигнал (или даже отправляя вместо него другой
сигнал).
.LP
Если флаг \fBPTRACE_O_TRACEEXEC\fP не действует, то все успешные вызовы
\fBexecve\fP(2) трассируемой нитью будут приводить к отправки сигнала
\fBSIGTRAP\fP, давая таким образом родителю шанс перехватить управление до
того, как начнёт выполняться новая программа.
.LP
По окончании трассировки трассировщик может заставить трассируемую нить
продолжить свою работу в обычном нетрассируемом режиме с помощью
\fBPTRACE_DETACH\fP.
.LP
Значение аргумента \fIrequest\fP определяет выполняемое действие:
.TP 
\fBPTRACE_TRACEME\fP
Указывает, что этот процесс будет трассирован своим родительским
процессом. Вероятно, процессу не следует посылать этот запрос, если
родительский процесс не готов к трассировке (аргументы \fIpid\fP, \fIaddr\fP и
\fIdata\fP игнорируются).
.LP
Действие \fBPTRACE_TRACEME\fP используется только в трассируемой нити;
остальные действия предназначены только для трассировщика. Для значений,
описанных ниже, в параметре \fIpid\fP задаётся идентификатор трассируемой нити,
над которой будет производиться действие. Перед выполнением действий (кроме
\fBPTRACE_ATTACH\fP и \fBPTRACE_KILL\fP) трассируемая нить должна быть
остановлена.
.TP 
\fBPTRACE_PEEKTEXT\fP, \fBPTRACE_PEEKDATA\fP
Читает слово по адресу \fIaddr\fP, находящееся в памяти трассируемой нити,
возвращая это слово как результат вызова \fBptrace\fP(). Linux не разделяет
адресные пространства текста и данных, поэтому оба вызова абсолютно
идентичны (значение \fIdata\fP игнорируется).
.TP 
\fBPTRACE_PEEKUSER\fP
.\" PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
.\" and that is the name that seems common on other systems.
Читает слово по смещению \fIaddr\fP из области USER трассируемой нити, которая
содержит информацию о регистрах и процессе (смотрите
\fI<sys/user.h>\fP). Слово возвращается в качестве результата вызова
\fBptrace\fP(). Обычно, смещение должно быть выровнено по границе слова, хотя
это может зависеть от архитектуры системы. Смотрите ЗАМЕЧАНИЯ (значение
\fIdata\fP игнорируется).
.TP 
\fBPTRACE_POKETEXT\fP, \fBPTRACE_POKEDATA\fP
Копирует слово \fIdata\fP в память трассируемой нити по адресу \fIaddr\fP. В
настоящее время, как и для \fBPTRACE_PEEKTEXT\fP и \fBPTRACE_PEEKDATA\fP, эти два
действия одинаковы.
.TP 
\fBPTRACE_POKEUSER\fP
.\" PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
.\" and that is the name that seems common on other systems.
.\" FIXME In the preceding sentence, which modifications are disallowed,
.\" and when they are disallowed, how does userspace discover that fact?
Копирует слово \fIdata\fP по смещению \fIaddr\fP в область USER трассирумой
нити. Как и для \fBPTRACE_PEEKUSER\fP, смещение должно быть выровнено по
границе слова. Для того, чтобы сохранить целостность ядра, некоторые
изменения в область USER вносить запрещено.
.TP 
\fBPTRACE_GETREGS\fP, \fBPTRACE_GETFPREGS\fP
Копирует, соответственно, регистры общего назначения или регистры
сопроцессора трассируемой нити в память трассировщика по адресу
\fIdata\fP. Формат передаваемой структуры описан в файле
\fI<sys/user.h>\fP (значение \fIaddr\fP игнорируется). Заметим, что в
системах SPARC предназначение \fIdata\fP и \fIaddr\fP поменяны местами; то есть
\fIdata\fP игнорируется, а регистры копируются по адресу \fIaddr\fP.
.TP 
\fBPTRACE_GETSIGINFO\fP (начиная с Linux 2.3.99\-pre6)
Получает информацию о сигнале, который вызвал остановку. Копирует структуру
\fIsiginfo_t\fP (смотрите \fBsigaction\fP(2)) из трассируемой нити в память
трассировщика по адресу \fIdata\fP (значение \fIaddr\fP игнорируется).
.TP 
\fBPTRACE_SETREGS\fP, \fBPTRACE_SETFPREGS\fP
.\" FIXME In the preceding sentence, which modifications are disallowed,
.\" and when they are disallowed, how does userspace discover that fact?
Копирует, соответственно, регистры общего назначения или регистры
сопроцессора трассируемой нити из памяти трассировщика по адресу
\fIdata\fP. Как и в случае c \fBPTRACE_POKEUSER\fP, изменения некоторых регистров
общего назначения запрещены (значение \fIaddr\fP игнорируется). Заметим, что в
системах SPARC предназначение \fIdata\fP и \fIaddr\fP переставлены местами; то
есть \fIdata\fP игнорируется, а регистры копируются из памяти, на которую
указывает адрес \fIaddr\fP.
.TP 
\fBPTRACE_SETSIGINFO\fP (начиная с Linux 2.3.99\-pre6)
Устанавливает информацию о сигнале. Копирует структуру \fIsiginfo_t\fP,
расположенную по адресу \fIdata\fP трассировщика, в память трассируемой
нити. Влияет только на сигналы, которые обычно были бы доставлены
трассируемой нити и были пойманы трассировщиком. Затруднительно отличить
обычные сигналы от созданных самим \fBptrace\fP() (значение \fIaddr\fP
игнорируется).
.TP 
\fBPTRACE_SETOPTIONS\fP (начиная с Linux 2.4.6; см. предостережения в разделе ДЕФЕКТЫ)
Устанавливает флаги ptrace из \fIdata\fP (значение \fIaddr\fP
игнорируется). Значение \fIdata\fP воспринимается как битовая маска, в которой
задаются следующие флаги:
.RS
.TP 
\fBPTRACE_O_TRACESYSGOOD\fP (начиная с Linux 2.4.6)
При доставке сигналов ловушек системных вызовов, устанавливать бит 7 в
номере сигнала (т. е., доставляется \fISIGTRAP|0x80\fP). Это позволяет
трассировщику легко отличить обычные ловушки от тех, которые были вызваны
системным вызовом (\fBPTRACE_O_TRACESYSGOOD\fP может не работать на некоторых
архитектурах).
.TP 
\fBPTRACE_O_TRACEFORK\fP (начиная с Linux 2.5.46)
Останавливать трассируемую нить при следующем вызове \fBfork\fP(2) и
автоматически запускать трассировку только что созданного с помощью fork
процесса, который начнёт выполнение с обработки сигнала \fBSIGSTOP\fP. Вызов
\fBwaitpid\fP(2) вернёт трассировщику значение \fIstatus\fP, которое равно

.nf
  status>>8 == (SIGTRAP | (PTRACE_EVENT_FORK<<8))
.fi

Значение PID нового процесса можно получить с помощью \fBPTRACE_GETEVENTMSG\fP.
.TP 
\fBPTRACE_O_TRACEVFORK\fP (начиная с Linux 2.5.46)
Останавливать трассируемую нить при следующем вызове \fBvfork\fP(2) и
автоматически запускать трассировку только что созданного с помощью vfork
процесса, который начнёт выполнение с обработки сигнала \fBSIGSTOP\fP. Вызов
\fBwaitpid\fP(2) вернёт трассировщику значение \fIstatus\fP, которое равно

.nf
  status>>8 == (SIGTRAP | (PTRACE_EVENT_VFORK<<8))
.fi

Значение PID нового процесса можно получить с помощью \fBPTRACE_GETEVENTMSG\fP.
.TP 
\fBPTRACE_O_TRACECLONE\fP (начиная с Linux 2.5.46)
Останавливать трассируемую нить при следующем вызове \fBclone\fP(2) и
автоматически запускать трассировку только что созданного с помощью clone
процесса, который начнёт выполнение с обработки сигнала \fBSIGSTOP\fP. Вызов
\fBwaitpid\fP(2) вернёт трассировщику значение \fIstatus\fP, которое равно

.nf
  status>>8 == (SIGTRAP | (PTRACE_EVENT_CLONE<<8))
.fi

Значение PID нового процесса можно получить с помощью \fBPTRACE_GETEVENTMSG\fP.
.IP
В некоторых случаях вызовы \fBclone\fP(2) могут быть не пойманы. Если
трассируемая нить вызывает \fBclone\fP(2) с флагом \fBCLONE_VFORK\fP, то будет
доставлен \fBPTRACE_EVENT_VFORK\fP, если установлен \fBPTRACE_O_TRACEVFORK\fP; в
противном случае, если трассируемая нить вызывает \fBclone\fP(2) с
установленным сигналом выхода равным \fBSIGCHLD\fP, то будет доставлен
\fBPTRACE_EVENT_FORK\fP, если установлен \fBPTRACE_O_TRACEFORK\fP.
.TP 
\fBPTRACE_O_TRACEEXEC\fP (начиная с Linux 2.5.46)
Останавливать трассируемую нить при следующем вызове \fBexecve\fP(). Вызов
\fBwaitpid\fP(2) вернёт трассировщику значение \fIstatus\fP, которое равно

.nf
  status>>8 == (SIGTRAP | (PTRACE_EVENT_EXEC<<8))
.fi

Если исполняемая нить не является лидером группы нитей, то идентификатор
нити сбрасывается в значение идентификатора лидера группы нитей перед его
остановкой. Начиная с Linux 3.0, предыдущий идентификатор нити может быть
получен с помощью \fBPTRACE_GETEVENTMSG\fP.
.TP 
\fBPTRACE_O_TRACEVFORKDONE\fP (начиная с Linux 2.5.60)
Останавливать трассируемую нить при следующем вызове \fBvfork\fP(2). Вызов
\fBwaitpid\fP(2) вернёт трассировщику значение \fIstatus\fP, которое равно

.nf
  status>>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONE<<8))
.fi

Значение PID нового процесса можно получить (начиная с Linux 2.6.18) с
помощью \fBPTRACE_GETEVENTMSG\fP.
.TP 
\fBPTRACE_O_TRACEEXIT\fP (начиная с Linux 2.5.60)
Останавливать трассируемую нить при его завершении (exit). Вызов
\fBwaitpid\fP() вернёт трассировщику значение \fIstatus\fP, которое равно

.nf
  status>>8 == (SIGTRAP | (PTRACE_EVENT_EXIT<<8))
.fi

Значение кода завершения трассируемой нити можно получить с помощью
\fBPTRACE_GETEVENTMSG\fP.
.IP
Остановка трассируемой нити будет выполнена в начальный момент завершения,
когда ещё доступны регистры, что позволяет трассировщику увидеть откуда
выполнялось завершение (обычное уведомление о завершении выполняется после
того как процесс уже завершил работу). Хотя в этот момент ещё доступен
контекст, трассировщик уже не может предотвратить завершение.
.RE
.TP 
\fBPTRACE_GETEVENTMSG\fP (начиная с Linux 2.5.46)
Включает получение сообщения (с типом \fIunsigned long\fP) о событии ptrace,
которое только что произошло, помещая его по адресу \fIdata\fP в памяти
трассировщика. Для \fBPTRACE_EVENT_EXIT\fP это код завершения трассируемой
нити. Для \fBPTRACE_EVENT_FORK\fP, \fBPTRACE_EVENT_VFORK\fP и
\fBPTRACE_EVENT_CLONE\fP это PID нового процесса (значение \fIaddr\fP
игнорируется).
.TP 
\fBPTRACE_CONT\fP
Возобновляет работу остановленной трассируемой нити. Если значение \fIdata\fP
не равно нулю, то оно считается номером сигнала, который надо доставить
трассируемой нити; в противном случае сигнал не передаётся. Таким образом,
например, трассировщик может контролировать передачу сигнала трассируемой
нити (значение \fIaddr\fP игнорируется).
.TP 
\fBPTRACE_SYSCALL\fP, \fBPTRACE_SINGLESTEP\fP
Аналогично \fBPTRACE_CONT\fP они перезапускают остановленную трассируемую нить,
но указывают, что процесс должен быть остановлен перед входом/выходом из
системного вызова, или после исполнения одной инструкции, соответственно
(трассируемая нить также, как обычно, будет остановлена при получении
сигнала). С точки зрения трассировщика кажется, что трассируемая нить
остановлена из\-за получения сигнала \fBSIGTRAP\fP. Так, \fBPTRACE_SYSCALL\fP
например, позволяет изучить содержимое аргументов перед системным вызовом, а
при следующем \fBPTRACE_SYSCALL\fP можно просмотреть результат исполнения
системного вызова. Аргумент \fIdata\fP используется как в \fBPTRACE_CONT\fP
(значение \fIaddr\fP игнорируется).
.TP 
\fBPTRACE_SYSEMU\fP, \fBPTRACE_SYSEMU_SINGLESTEP\fP (начиная с Linux 2.6.14)
Действие \fBPTRACE_SYSEMU\fP приводит к продолжению и остановке на входе в
следующий системный вызов, который не будет выполнен. Действие
\fBPTRACE_SYSEMU_SINGLESTEP\fP выполняет тоже самое, но для одиночной
инструкции, если это не системный вызов. Это действие используется
программами, подобными User Mode Linux, которым нужно эмулировать все
системные вызовы трассируемых нитей. Аргумент \fIdata\fP используется также как
у \fBPTRACE_CONT\fP (значение \fIaddr\fP игнорируется; поддерживается не на всех
архитектурах).
.TP 
\fBPTRACE_KILL\fP
Посылает трассируемой нити сигнал \fBSIGKILL\fP для его уничтожения (значения
\fIaddr\fP и \fIdata\fP игнорируются).
.IP
.\" [Note from Denys Vlasenko:
.\"     deprecation suggested by Oleg Nesterov. He prefers to deprecate it
.\"     instead of describing (and needing to support) PTRACE_KILL's quirks.]
\fIЭто действие устарело; не используйте его!\fP Вместо него отправляйте
\fBSIGKILL\fP напрямую с помощью \fBkill\fP(2) или \fBtgkill\fP(2). Проблема с
действием \fBPTRACE_KILL\fP в том, что оно требует, чтобы трассируемая нить
была режиме signal\-delivery\-stop, в противном случае оно может не сработать
(т. е., может завершиться без ошибок, но трассируемая нить не будет
уничтожена). В отличие от него, отправка \fBSIGKILL\fP напрямую не имеет
данного ограничения.
.TP 
\fBPTRACE_ATTACH\fP
.\" No longer true (removed by Denys Vlasenko, 2011, who remarks:
.\"        "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
.\"         Basically, it's not true for any Linux in practical use.
.\" ; the behavior of the tracee is as if it had done a
.\" .BR PTRACE_TRACEME .
.\" The calling process actually becomes the parent of the tracee
.\" process for most purposes (e.g., it will receive
.\" notification of tracee events and appears in
.\" .BR ps (1)
.\" output as the tracee's parent), but a
.\" .BR getppid (2)
.\" by the tracee will still return the PID of the original parent.
Выполняет присоединение к процессу с указанным \fIpid\fP, делая его
трассируемым для вызывающего процесса. Трассируемой нити посылается
\fBSIGSTOP\fP, но нет жёсткого правила, что она будет остановлен по завершению
этого вызова; используйте \fBwaitpid\fP(2) для ожидания остановки трассируемой
нити. Дополнительную информацию смотрите в подразделе «Присоединение и
отсоединение» (значения \fIaddr\fP и \fIdata\fP игнорируются).
.TP 
\fBPTRACE_DETACH\fP
Возобновляет работу остановленной трассируемой нити, аналогично
\fBPTRACE_CONT\fP, но сначала отсоединяется от него. В Linux при помощи этого
вызова трассируемая нить может быть отсоединёна независимо от того, каким
методом была запущена трассировка (значение \fIaddr\fP игнорируется).
.SS "Смерть в момент ptrace"
Когда (возможно, многонитиевой) процесс получает уничтожающий сигнал (из\-за
того, что обработчик равен \fBSIG_DFL\fP и что действием по умолчанию является
уничтожение процесса), все нити завершают работу (exit). Трассируемые нити
сообщают о своей смерти своим трассировщикам. Уведомления об этом событии
доставляется с помощью \fBwaitpid\fP(2).
.LP
Заметим, что уничтожающий сигнал сначала вызовет вхождение в режим
signal\-delivery\-stop (только для одной трассируемой нити), и только после
этого будет внедрён трассировщиком (или после того, как был отослан нити,
которая не является трассируемой), затем \fIвсе\fP трассируемые нити в
многонитиевом процессе завершаются по сигналу (термин «signal\-delivery\-stop»
объяснён далее).
.LP
Сигнал \fBSIGKILL\fP работает схожим образом, с некоторыми исключениями. Для
него не выполняется режим signal\-delivery\-stop и поэтому трассировщик не
может подавить его. Сигнал \fBSIGKILL\fP уничтожает даже внутри системных
вызовов (syscall\-exit\-stop не генерируется перед уничтожением по
\fBSIGKILL\fP). Конечным результатом \fBSIGKILL\fP всегда является уничтожение
процесса (всех его нитей), даже если для некоторых нитей процесса
выполняется\ трассировка.
.LP
Когда трассируемая нить вызывает \fB_exit\fP(2), он сообщает о своём
уничтожении своему трассировщику. На оставшиеся нити ни какого влияния не
оказывается.
.LP
Если какая\-нибудь нить вызывает \fBexit_group\fP(2), то каждая трассируемая
нить в этой группе нитей сообщает о своём уничтожении своему трассировщику.
.LP
Если установлен флаг \fBPTRACE_O_TRACEEXIT\fP, то перед непосредственным
уничтожением возникает \fBPTRACE_EVENT_EXIT\fP. Это случается при выходе
посредством \fBexit\fP(2), \fBexit_group\fP(2) и из\-за уничтожения по сигналу (за
исключением \fBSIGKILL\fP), и когда нити многонитиевого процесса разрушаются
при \fBexecve\fP(2).
.LP
Трассировщик не может предполагать, что трассируемая нить, остановленная по
ptrace, существует. Если много случаев, когда трассируемая нить может быть
уничтожена будучи в остановленном состоянии (например, по
\fBSIGKILL\fP). Поэтому, трассировщик должен быть готов обработать ошибку
\fBESRCH\fP при любом действии ptrace. К сожалению, эта же ошибка возвращается,
если трассируемая нить существует, но не остановлена по ptrace (для
действий, которые требуют остановленной трассируемой нити), или если она не
трассируется процессом, который вызвал ptrace. Трассировщику необходимо
отслеживать состояние остановки/работы трассируемой нити и воспринимать
\fBESRCH\fP как «трассируемая нить была неожиданно уничтожена» только, если он
знает, что трассируемая нить была в состоянии ptrace\-stop. Заметим, что нет
гарантии того, что \fIwaitpid(WNOHANG)\fP всегда сообщит о состоянии
уничтожения трассируемой нити, если действие ptrace вернуло \fBESRCH\fP. Вызов
\fIwaitpid(WNOHANG)\fP вместо этого может вернуть 0. Другими словами,
трассируемая нить может быть «ещё не полностью уничтожена», но уже отклонять
действия ptrace.
.LP
Трассировщик не может предполагать, что \fIвсегда\fP поймает завершение
существования трассируемой нити с помощью \fIWIFEXITED(status)\fP или
\fIWIFSIGNALED(status)\fP; есть несколько случаев, когда этого не
происходит. Например, если нить — не лидер группы нитей — вызывает
\fBexecve\fP(2) и исчезает; её PID больше не появится снова, и все последующие
остановки по ptrace будут приходить от PID лидера группы нитей.
.SS "Состояния останова"
Трассируемая нить может быть в двух состояниях: выполнения и останова.
.LP
Есть много разновидностей останова, и в обсуждении ptrace они часто
объединены. Поэтому очень важно использовать точную терминологию.
.LP
В этой справочной странице любое состояние останова, в котором трассируемая
нить готова выполнить действия ptrace трассировщика, называется
\fIptrace\-stop\fP. В свою очередь, ptrace\-stop можно разделить на
\fIsignal\-delivery\-stop\fP, \fIgroup\-stop\fP, \fIsyscall\-stop\fP и так далее. Далее
эти состояния останова будут описаны подробней.
.LP
Когда выполняющаяся трассируемая нить входит в ptrace\-stop, это видит
трассировщик с помощью \fBwaitpid\fP(2) (или через другой системный вызов
«wait»). В большей части текста данной справочной страницы предполагается,
что трассировщик ждёт с помощью:
.LP
    pid = waitpid(pid_или_минус_1, &состояние, __WALL);
.LP
.\" Denys Vlasenko:
.\"     Do we require __WALL usage, or will just using 0 be ok? (With 0,
.\"     I am not 100% sure there aren't ugly corner cases.) Are the
.\"     rules different if user wants to use waitid? Will waitid require
.\"     WEXITED?
.\"
О трассируемой нити в состоянии ptrace\-stop сообщается возвратом \fIpid\fP
большим 0 и значением истины по \fIWIFSTOPPED(status)\fP.
.LP
Флаг \fB__WALL\fP не содержит флагов \fBWSTOPPED\fP и \fBWEXITED\fP, но подразумевает
их назначение.
.LP
Устанавливать флаг \fBWCONTINUED\fP при вызове \fBwaitpid\fP(2) не рекомендуется:
состояние «continued» относится к определённому процессу и его поглощение
может запутать реального родителя трассируемой нити.
.LP
Использование флага \fBWNOHANG\fP может привести к тому, что \fBwaitpid\fP(2)
вернёт 0 («не ждать результатов, если они не готовы»), даже если
трассировщик знает, что должно быть уведомление. Пример:
.nf

    kill(трассируемая_нить, SIGKILL);
    waitpid(трассируемая_нить, &status, __WALL | WNOHANG);
.fi
.\" FIXME:
.\"     waitid usage? WNOWAIT?
.\"     describe how wait notifications queue (or not queue)
.LP
Существуют следующие разновидности ptrace\-stop: signal\-delivery\-stop,
group\-stop, остановки \fBPTRACE_EVENT\fP, syscall\-stop. Все они могут быть
получены по \fBwaitpid\fP(2) с значением истинным по \fIWIFSTOPPED(status)\fP. Их
можно различить, если проверить значение \fIstatus>>8\fP, и, если есть
неоднозначность этого значения, то запросив \fBPTRACE_GETSIGINFO\fP (замечание:
для выполнения этой проверки не может использоваться макрос
\fIWSTOPSIG(status)\fP, так как он возвращает значение \fI(status>>8)\ &\ 0xff\fP).
.SS Signal\-delivery\-stop
Когда процесс (возможно, многонитиевой) принимает какой\-либо сигнал кроме
\fBSIGKILL\fP, ядро выбирает произвольную нить для его обработки (если сигнал
генерируется с помощью \fBtgkill\fP(2), то назначаемая нить может быть явно
выбрана вызывающим). Если над выбранной нитью выполняется трассировка, то
она попадает в режим signal\-delivery\-stop. В этот момент сигнал ещё не
доставлен процессу и может быть отменён трассировщиком. Если трассировщик не
отменил сигнал, то он передаётся трассируемой нитипри следующем запросе
перезапуска ptrace. Этот второй этап доставки сигнала называется в этой
справочной странице \fIвнедрением сигнала\fP. Заметим, что если сигнал
блокируется, то signal\-delivery\-stop не происходит пока сигнал не будет
разблокирован (исключением, как обычно, является \fBSIGSTOP\fP, который нельзя
заблокировать).
.LP
Signal\-delivery\-stop наблюдается трассировщиком посредством \fBwaitpid\fP(2),
возвращающим истинное значения для \fIWIFSTOPPED(status)\fP с сигналом, который
возвращается по \fIWSTOPSIG(status)\fP. Если возвращается сигнал \fBSIGTRAP\fP, то
он может быть разновидностью ptrace\-stop; смотрите разделы «Syscall\-stops» и
«execve» далее. Если \fIWSTOPSIG(status)\fP возвращает останавливающий сигнал,
то это может быть group\-stop, смотрите далее.
.SS "Внедрение и подавление сигнала"
После обнаружения трассировщиком signal\-delivery\-stop, он должен
перезапустить трассируемую нить вызовом
.LP
    ptrace(PTRACE_restart, pid, 0, sig)
.LP
где \fBPTRACE_restart\fP — одно из перезапускающих действий ptrace. Если
значение \fIsig\fP равно 0, то сигнал не доставляется. В противном случае,
доставляется сигнал \fIsig\fP. Данная операция в справочной странице называется
\fIвнедрением сигнала\fP для того, чтобы можно отличить её от
signal\-delivery\-stop.
.LP
Значение \fIsig\fP может отличаться от значения \fIWSTOPSIG(status)\fP:
трассировщик может поменять внедряемый сигнал.
.LP
Заметим, что подавленный сигнал всё равно заставит системные вызовы
завершиться как можно скорее. В этом случае системные вызовы будут
перезапущены: если трассировщик использует \fBPTRACE_SYSCALL\fP, то обнаружит,
когда трассируемая нить повторно выполнила прерванный системный вызов (или
системный вызов \fBrestart_syscall\fP(2) для некоторых системных вызовов,
которые используют другой механизм перезапуска). Даже системные вызовы
(такие как \fBpoll\fP(2)), которые не перезапускаются по сигналу, будут
перезапущены после подавления сигнала; однако, в ядре существуют дефекты,
из\-за которых некоторые системные вызовы завершаются с ошибкой \fBEINTR\fP,
даже если наблюдаемый сигнал не был внедрён в трассируемую нить.
.LP
Перезапускающие действия ptrace, выдаваемые в ptrace\-stops, отличные от
signal\-delivery\-stop, не гарантируют внедрения сигнала, даже если значение
\fIsig\fP не равно нулю. Об ошибках не сообщается; ненулевое значение \fIsig\fP
может быть просто проигнорировано. Пользователи ptrace не должны пытаться
«создать новый сигнал» таким способом — используйте вместо этого
\fBtgkill\fP(2).
.LP
Тот факт, что запросы внедрения сигнала могут игнорироваться при перезапуске
трассируемой нити после остановок ptrace не из signal\-delivery\-stops,
вызывает путаницу у пользователей ptrace. Типичный сценарий: трассировщик
обнаруживает group\-stop, принимает его за signal\-delivery\-stop,
перезапускает трассируемую нить с помощью

    ptrace(PTRACE_rest, pid, 0, stopsig)

пытаясь внедрить \fIstopsig\fP, но \fIstopsig\fP игнорируется и трассируемая нить
продолжает выполняться.
.LP
Сигнал \fBSIGCONT\fP имеет побочный эффект — пробуждает (все нити) процесс,
находящийся в group\-stop. Это случается перед
signal\-delivery\-stop. Трассировщик не может повлиять на это побочное
действие (он может только подавить внедрение сигнала, что приводит к тому,
что обработчик \fBSIGCONT\fP не будет выполнен в трассируемой нити, если он
установлен). Фактически, пробуждение из group\-stop может следовать после
signal\-delivery\-stop для сигнала(ов) \fIотличных от\fP \fBSIGCONT\fP, если они
ожидают момента доставки \fBSIGCONT\fP. Другими словами, \fBSIGCONT\fP может быть
не первым сигналом, который обнаруживает трассируемую нить после её посылки.
.LP
Останавливающие сигналы заставляют процесс (все его нити) войти в
group\-stop. Данный побочный эффект возникает после внедрения сигнала, и
поэтому может быть отменён трассировщиком.
.LP
.\" In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
.\" there is:
.\"
.\"             /* The debugger continued.  Ignore SIGSTOP.  */
.\"             if (signr == SIGSTOP)
.\"                     continue;
В Linux 2.4 и более ранних версиях, сигнал \fBSIGSTOP\fP не может быть внедрён.
.LP
Действие \fBPTRACE_GETSIGINFO\fP может использоваться для получения структуры
\fIsiginfo_t\fP, которая соответствует доставленному сигналу. Для её изменения
можно использовать \fBPTRACE_SETSIGINFO\fP. Если \fBPTRACE_SETSIGINFO\fP
использовалась для изменения \fIsiginfo_t\fP, то поле \fIsi_signo\fP и параметр
\fIsig\fP в перезапускающем действии должны совпадать, иначе результат
непредсказуем.
.SS Group\-stop
Когда (возможно многонитиевой) процесс получает останавливающий сигнал, все
нити останавливаются. Если для какой\-то нити выполняется трассировка, то она
входит в режим group\-stop. Заметим, что останавливающий сигнал сначала
приведёт к signal\-delivery\-stop (только в одной трассируемой нити) и только
затем будет внедрён трассировщиком (или после того, как будет отправлен
нити, над которой не выполняется трассировка), будет начат group\-stop в
\fIвсех\fP трассируемых нитях многонитиевого процесса. Как обычно, каждая
трассируемая нить сообщает о group\-stop соответствующему трассировщику.
.LP
Group\-stop обнаруживается трассировщиком с помощью \fBwaitpid\fP(2), который
возвращается с истинным значением \fIWIFSTOPPED(status)\fP и останавливающим
сигналом из \fIWSTOPSIG(status)\fP. Тот же результат возвращается другими
классами ptrace\-stops, поэтому рекомендуется выполнять вызов
.LP
    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)
.LP
Вызова можно избежать, если сигнал не равен \fBSIGSTOP\fP, \fBSIGTSTP\fP,
\fBSIGTTIN\fP или \fBSIGTTOU\fP; только эти четыре сигнала являются
останавливающими. Если трассировщик видит что\-то другое, то это не может
быть group\-stop. В противном случае, трассировщику нужно вызвать
\fBPTRACE_GETSIGINFO\fP. Если \fBPTRACE_GETSIGINFO\fP завершается с ошибкой
\fBEINVAL\fP, то это определённо group\-stop (возможны другие коды ошибок,
например, \fBESRCH\fP («нет такого процесса»), если трассируемая нить
уничтожена по \fBSIGKILL\fP).
.LP
Начиная с ядра версии 2.6.38, после того как трассировщик увидит ptrace\-stop
трассируемой нити и пока он не перезапустит или завершит её, трассируемая
нить не будет выполняться, и не будет посылать уведомления (за исключением
уничтожения по \fBSIGKILL\fP) трассировщику, даже если трассировщик войдёт в
другой вызов \fBwaitpid\fP(2).
.LP
Поведение ядра, описанное в предыдущем параграфе, вызывает проблемы с
прозрачностью обработки останавливающих сигналов. Если трассировщик
перезапускает трассируемую нить после group\-stop, то останавливающий сигнал
просто игнорируется — трассируемая нить продолжает выполняться. Если
трассировщик не перезапускает трассируемую нить перед входом в следующий
\fBwaitpid\fP(2), то о будущих сигналах \fBSIGCONT\fP не будет сообщено
трассировщику; это привело бы к тому, что сигналы \fBSIGCONT\fP не повлияли бы
на трассируемую нить.
.SS "Остановки PTRACE_EVENT"
Если трассировщик устанавливает флаги \fBPTRACE_O_TRACE_*\fP, то трассируемая
нить будет входить в ptrace\-stop\-ы, называемые остановками \fBPTRACE_EVENT\fP.
.LP
Остановки \fBPTRACE_EVENT\fP обнаруживаются трассировщиком когда \fBwaitpid\fP(2)
возвращается с \fIWIFSTOPPED(status)\fP и \fIWSTOPSIG(status)\fP возвращает
\fBSIGTRAP\fP. В старшем байте слова состояния устанавливается дополнительный
бит: значение \fIstatus>>8\fP будет равно

    (SIGTRAP | PTRACE_EVENT_foo << 8).

Могут происходить следующие события:
.TP 
\fBPTRACE_EVENT_VFORK\fP
Остановка перед возвратом из \fBvfork\fP(2) или \fBclone\fP(2) с флагом
\fBCLONE_VFORK\fP. Когда трассируемая нить продолжает выполняться после этой
остановки, она будет ждать выхода/exec потомка перед продолжением своего
исполнения (другими словами, обычное поведение при \fBvfork\fP(2)).
.TP 
\fBPTRACE_EVENT_FORK\fP
Остановка перед возвратом из \fBfork\fP(2) или \fBclone\fP(2) с установленным
сигналом выхода \fBSIGCHLD\fP.
.TP 
\fBPTRACE_EVENT_CLONE\fP
Остановка перед возвратом из \fBclone\fP(2).
.TP 
\fBPTRACE_EVENT_VFORK_DONE\fP
Остановка перед возвратом из \fBvfork\fP(2) или \fBclone\fP(2) с установленным
флагом \fBCLONE_VFORK\fP, но после того, как потомок разблокирует эту
трассируемую нить, завершив работу или выполнив exec.
.LP
Для всех четырёх остановок, описанных выше, остановка происходит в родителе
(т. е., трассируемой нити), а не в только что созданной нити. Для получения
ID новой нити может использовать \fBPTRACE_GETEVENTMSG\fP.
.TP 
\fBPTRACE_EVENT_EXEC\fP
Остановка перед возвратом из \fBexecve\fP(2). Начиная с Linux 3.0,
\fBPTRACE_GETEVENTMSG\fP возвращает ID бывшей нити.
.TP 
\fBPTRACE_EVENT_EXIT\fP
Остановка перед выходом (включая уничтожение из \fBexit_group\fP(2)),
уничтожение от сигнала или выход, вызванный \fBexecve\fP(2) в многонитиевом
процессе. \fBPTRACE_GETEVENTMSG\fP возвращает код выхода. Можно прочитать
значения регистров (в отличие от случая, когда происходит «реальный»
выход). Трассируемая нить всё ещё существует; для завершения выхода
должнобыть выполнено отсоединение с помощью \fBPTRACE_CONT\fP или
\fBPTRACE_DETACH\fP.
.LP
\fBPTRACE_GETSIGINFO\fP при остановке \fBPTRACE_EVENT\fP возвращает \fBSIGTRAP\fP в
\fIsi_signo\fP, а значение \fIsi_code\fP устанавливается в \fI(event<<8)\ |\ SIGTRAP\fP.
.SS Syscall\-stop
Если трассируемая нить была перезапущена по \fBPTRACE_SYSCALL\fP, то она входит
в режим syscall\-enter\-stop сразу перед тем как войти в какой\-либо системный
вызов. Если трассировщик перезапускает трассируемую нить с помощью
\fBPTRACE_SYSCALL\fP, то трассируемая нить входит в syscall\-exit\-stop при
окончании системного вызова, или если она прерывается сигналом (то есть,
signal\-delivery\-stop никогда не возникает между syscall\-enter\-stop и
syscall\-exit\-stop; он возникает \fIпосле\fP syscall\-exit\-stop).
.LP
Также, трассируемая нить может остановиться в остановке \fBPTRACE_EVENT\fP, при
выходе (если он вошёл в \fB_exit\fP(2) или \fBexit_group\fP(2)), уничтожении по
сигналу \fBSIGKILL\fP, или тихом уничтожении (если он является лидером группы
нитей, возникает \fBexecve\fP(2) в другой нити, и эта нить не трассируется тем
же трассировщиком; эта ситуация описана далее).
.LP
Syscall\-enter\-stop и syscall\-exit\-stop обнаруживаются трассировщиком из
\fBwaitpid\fP(2), возвращающем истинное значение \fIWIFSTOPPED(status)\fP и
\fIWSTOPSIG(status)\fP выдающем \fBSIGTRAP\fP. Если трассировщиком был установлен
флаг \fBPTRACE_O_TRACESYSGOOD\fP, то \fIWSTOPSIG(status)\fP выдаст значение
\fI(SIGTRAP\ |\ 0x80)\fP.
.LP
Syscall\-stop можно отличить от signal\-delivery\-stop по \fBSIGTRAP\fP, запросив
\fBPTRACE_GETSIGINFO\fP в следующих случаях:
.TP 
\fIsi_code\fP <= 0
\fBSIGTRAP\fP был доставлен в результате действия из пространства пользователя,
например, системного вызова (\fBtgkill\fP(2), \fBkill\fP(2), \fBsigqueue\fP(3) и
т. д.), истечении таймера POSIX, изменении состояния очереди сообщений POSIX
или выполнении асинхронного запроса ввода/вывода.
.TP 
\fIsi_code\fP == SI_KERNEL (0x80)
\fBSIGTRAP\fP был послан ядром.
.TP 
\fIsi_code\fP == SIGTRAP или \fIsi_code\fP == (SIGTRAP|0x80)
Это syscall\-stop.
.LP
Однако, syscall\-stop происходят очень часто (дважды за системный вызов), и
выполнение \fBPTRACE_GETSIGINFO\fP для каждого syscall\-stop может быть отчасти
накладно.
.LP
Некоторые архитектуры позволяют отличать эти случаи по значениям
регистров. Например, на x86, при syscall\-enter\-stop \fIrax\fP ==
\-\fBENOSYS\fP. Так как \fBSIGTRAP\fP (как и любой сигнал) всегда возникает
\fIпосле\fP syscall\-exit\-stop, и в этот момент \fIrax\fP почти никогда не содержит
\fBENOSYS\fP, \fBSIGTRAP\fP выглядит как «syscall\-stop, который не
syscall\-enter\-stop»; другими словами, это выглядит как «блуждающий
syscall\-exit\-stop» и таким способом может быть обнаружен. Но определение
этим способом очень ненадёжно и лучше его не использовать.
.LP
Использование флага \fBPTRACE_O_TRACESYSGOOD\fP — рекомендуемый метод
различения syscall\-stop от похожих на них других ptrace\-stop, так как это
надёжно и не приводит к ухудшению производительности.
.LP
Syscall\-enter\-stop и syscall\-exit\-stop неотличимы друг от друга
трассировщиком. Трассировщику требуется отслеживать последовательность
ptrace\-stop, чтобы правильно истолковать syscall\-enter\-stop как
syscall\-exit\-stop или наоборот. Правило: за syscall\-enter\-stop всегда
следует syscall\-exit\-stop, \fBPTRACE_EVENT\fP остановка или уничтожение
процесса; никаких других ptrace\-stop не может возникнуть между ними.
.LP
Если после syscall\-enter\-stop трассировщик использует перезапускающее
действие, отличное от \fBPTRACE_SYSCALL\fP, то syscall\-exit\-stop не
генерируется.
.LP
\fBPTRACE_GETSIGINFO\fP при syscall\-stop возвращает \fBSIGTRAP\fP в \fIsi_signo\fP,
значение \fIsi_code\fP устанавливается в \fBSIGTRAP\fP или \fI(SIGTRAP|0x80)\fP.
.SS "Остановки PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP"
.\"
.\" FIXME
.\" document stops occurring with PTRACE_SINGLESTEP, PTRACE_SYSEMU,
.\" PTRACE_SYSEMU_SINGLESTEP
[Пока не описаны.]
.SS "Информационные и перезапускающие действия ptrace"
Для большинства действий ptrace (все, за исключением \fBPTRACE_ATTACH\fP,
\fBPTRACE_TRACEME\fP и \fBPTRACE_KILL\fP) требуются, чтобы трассируемая нить была
в режиме ptrace\-stop, в противном случае завершаются с ошибкой \fBESRCH\fP.
.LP
Когда трассируемая нить в ptrace\-stop, трассировщик может читать и
записывать данные в трассируемую нить с помощью информационных действий. Эти
действия оставляют трассируемую нить в состоянии ptrace\-stop:
.LP
.nf
    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);
    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);
    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);
    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);
    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);
    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);
    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);
    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);
.fi
.LP
Заметим, что о некоторых ошибках не сообщается. Например, установка
информации о сигнале (\fIsiginfo\fP) может никак не отразиться в некоторых
ptrace\-stop, при этом вызов может завершиться без ошибок (возвращается 0 и
значение \fIerrno\fP не устанавливается); действие \fBPTRACE_GETEVENTMSG\fP может
выполниться без ошибок и вернуть произвольное значение, если текущий
ptrace\-stop не описан как возвращающий какое\-то осмысленное сообщение о
событии.
.LP
Вызов

    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);

затрагивает одну трассируемую нить. Текущие флаги трассируемой нити
заменяются. Флаги, наследуемые новой трассируемой нитью, создаются и
«автоматически присоединяются» через активные флаги \fBPTRACE_O_TRACEFORK\fP,
\fBPTRACE_O_TRACEVFORK\fP или \fBPTRACE_O_TRACECLONE\fP.
.LP
Другая группа действий заставляет трассируемую нить, находящуюся в
ptrace\-stop, выполняться. Они могут иметь вид:
.LP
    ptrace(cmd, pid, 0, sig);
.LP
где значение \fIcmd\fP равно \fBPTRACE_CONT\fP, \fBPTRACE_DETACH\fP,
\fBPTRACE_SYSCALL\fP, \fBPTRACE_SINGLESTEP\fP, \fBPTRACE_SYSEMU\fP или
\fBPTRACE_SYSEMU_SINGLESTEP\fP. Если трассируемая нить в signal\-delivery\-stop,
то в \fIsig\fP указывается сигнал, который будет внедрён (если не равен
нулю). В противном случае, \fIsig\fP может игнорироваться (при перезапуске
трассируемой нити из ptrace\-stop в отличный от signal\-delivery\-stop,
рекомендуется передавать в \fIsig\fP значение 0).
.SS "Присоединение и отсоединение"
Нить можно присоединить к трассировщику с помощью вызова

    ptrace(PTRACE_ATTACH, pid, 0, 0);

.\"
.\" FIXME: Describe how to attach to a thread which is already
.\"        group-stopped.
Он также посылает в нить \fBSIGSTOP\fP. Если трассировщик хочет отменить
действие \fBSIGSTOP\fP, ему нужно его подавить. Заметим, что если при
присоединении в эту нить в тоже время посылаются другие сигналы, то
трассировщик может увидеть, что трассируемая нить сначала вошла в
signal\-delivery\-stop из этих сигналов! Обычной практикой является повторное
внедрение этих сигналов до тех пор, пока не будет обнаружен \fBSIGSTOP\fP, а
затем подавление внедрения \fBSIGSTOP\fP. Здесь есть ошибка в проектировании в
том, что присоединение ptrace и одновременно доставляемый \fBSIGSTOP\fP могут
состязаться и одновременный \fBSIGSTOP\fP может быть утерян.
.LP
Так как при присоединении посылается \fBSIGSTOP\fP и трассировщик обычно
подавляет его, то это может привести к блуждающему возврату \fBEINTR\fP из в
данный момент выполняемого системного вызова в трассируемой нити, как
описано в разделе «Внедрение и отмена сигнала».
.LP
Запрос

    ptrace(PTRACE_TRACEME, 0, 0, 0);

включает трассировку вызвавшей нити. Нить продолжает выполняться (не входит
в ptrace\-stop). Обычно, за \fBPTRACE_TRACEME\fP следует

    raise(SIGSTOP);

и это позволяет родителю (который теперь трассировщик) отследить
signal\-delivery\-stop.
.LP
Если включены флаги \fBPTRACE_O_TRACEFORK\fP, \fBPTRACE_O_TRACEVFORK\fP или
\fBPTRACE_O_TRACECLONE\fP, то потомок, создаваемый, соответственно, \fBvfork\fP(2)
или \fBclone\fP(2) с флагом \fBCLONE_VFORK\fP, \fBfork\fP(2) или \fBclone\fP(2) с
установленным выходным сигналом равным \fBSIGCHLD\fP, и другими видами
\fBclone\fP(2), автоматически присоединяется к тому же трассировщику, которой
трассирует их родителя. Сигнал \fBSIGSTOP\fP доставляется потомку, заставляя
его войти в signal\-delivery\-stop после завершения системного вызова, который
его создал.
.LP
Отсоединение от трассируемой нити выполняется с помощью:

    ptrace(PTRACE_DETACH, pid, 0, sig);

\fBPTRACE_DETACH\fP является перезапускающей операцией, поэтому она требует,
чтобы трассируемая нить была в ptrace\-stop. Если трассируемая нить в
signal\-delivery\-stop, то может быть внедрён сигнал. В противном случае
параметр \fIsig\fP может быть проигнорирован.
.LP
.\" FIXME: Describe how to detach from a group-stopped tracee so that it
.\"        doesn't run, but continues to wait for SIGCONT.
Если трассировщик хочет отсоединиться,а трассируемая нить выполняется, то
решением является посылка сигнала \fBSIGSTOP\fP (с помощью \fBtgkill\fP(2), чтобы
точно достичь текущей нити), ожидание пока трассируемая нить не войдёт в
signal\-delivery\-stop для доставки \fBSIGSTOP\fP и затем отсоединение от неё
(подавив внедрение \fBSIGSTOP\fP). Ошибкой проектирования является возможность
гонок с параллельно отправленными \fBSIGSTOP\fP. Другая трудность в том, что
трассируемая нить может войти в другой ptrace\-stop и потребуется его
перезапуск и повторное ожидание появления \fBSIGSTOP\fP. Ещё одной сложностью
является в проверки, что трассируемая нить уже не в ptrace\-stop, так как в
этом случае доставки сигнала не происходит — даже \fBSIGSTOP\fP.
.LP
Если трассировщик завершает работу, то все трассируемые нити автоматически
отсоединяются и перезапускаются, если они не в group\-stop. Выполнение
перезапуска из group\-stop в настоящее время содержит ошибки, но «плановым»
поведением считается оставить трассируемую нить остановленной и подождать
\fBSIGCONT\fP. Если трассируемая нить перезапускается из signal\-delivery\-stop,
то внедряется ожидающий сигнал.
.SS "Выполнение execve(2) во время ptrace"
.\" clone(2) THREAD_CLONE says:
.\"     If  any  of the threads in a thread group performs an execve(2),
.\"     then all threads other than the thread group leader are terminated,
.\"     and the new program is executed in the thread group leader.
.\"
.\" In kernel 3.1 sources, see fs/exec.c::de_thread()
Когда одна нить многонитиевого процесса вызывает \fBexecve\fP(2), то ядро
уничтожает все остальные нити процесса и сбрасывает ID выполняющейся нити в
значение ID группы нитей (ID процесса. Или, говоря иначе, когда
многонитиевой процесс выполняет \fBexecve\fP(2), то по завершению вызова это
выглядит как если бы \fBexecve\fP(2) произошёл в лидере группе нитей,
независимо от того, какая нить вызвала \fBexecve\fP(2)). Такой сброс ID нити
запутывает трассировщиков:
.IP * 3
Все остальные нити останавливаются в останове \fBPTRACE_EVENT_EXIT\fP, если
включён флаг \fBPTRACE_O_TRACEEXIT\fP. Затем все остальные нити, за исключением
лидера группы нитей, сообщают о завершении, как если бы они кончили работу с
помощью \fB_exit\fP(2) с кодом выхода 0.
.IP *
У исполняемой трассируемой нити изменяется ID, так как она выполняет
\fBexecve\fP(2) (помните, что в ptrace «pid», возвращаемый из \fBwaitpid\fP(2) или
подаваемый в вызовы ptrace, это ID трассируемой нити). То есть ID
трассируемой нити сбрасывается в значение ID своего процесса, который равен
ID лидера группы нитей.
.IP *
Затем происходит остановка \fBPTRACE_EVENT_EXEC\fP, если включён флаг
\fBPTRACE_O_TRACEEXEC\fP.
.IP *
Если в это время лидер группы нитей сообщил о своей остановке
\fBPTRACE_EVENT_EXIT\fP в это время, то трассировщику кажется, что
завершившийся лидер группы «возник из ниоткуда» (замечание: лидер группы
нитей не сообщает о завершении через \fIWIFEXITED(status)\fP до тех пор, пока
есть одна работающая нить. Это не даёт возможности трассировщику увидеть его
завершение и повторное появление). Если лидер группы нитей всё ещё
выполнялся, то для трассировщика может казаться, что лидер группы нитей
вернулся из другого системного вызова в который входил, или даже «вернулся
из системного вызова, хотя не был ни в каком системном вызове». Если лидер
группы нитей не трассируется (или трассируется другим трассировщиком), то во
время \fBexecve\fP(2) он выглядит так, как если бы стал трассируемым
трассировщиком выполняющейся трассируемой нити.
.LP
Все перечисленные выше эффекты происходят из\-за смены ID трассируемой нити.
.LP
В этой ситуации рекомендуется использовать флаг
\fBPTRACE_O_TRACEEXEC\fP. Во\-первых, он включает остановку
\fBPTRACE_EVENT_EXEC\fP, которая происходит перед возвратом из \fBexecve\fP(2). В
этой остановке трассировщик может использовать \fBPTRACE_GETEVENTMSG\fP для
получения предыдущего ID трассируемой нити (эта возможность появилась в
Linux 3.0). Во\-вторых, флаг \fBPTRACE_O_TRACEEXEC\fP отключает устаревшую
генерацию \fBSIGTRAP\fP при \fBexecve\fP(2).
.LP
Когда трассировщик получает уведомление об остановке \fBPTRACE_EVENT_EXEC\fP,
гарантируется, что за исключением этой трассируемой нити и лидера группы
нитей, больше живых нитей в этом процессе нет.
.LP
По получению уведомления об остановке \fBPTRACE_EVENT_EXEC\fP трассировщик
должен очистить все свои внутренние структуры данных, описывающие нити этого
процесса, и оставить только одну структуру данных, которая описывает одну
ещё выполняющуюся трассируемую нить, у которой

    ID нити == ID группы нитей == ID процесса.
.LP
Пример: две нити вызывают \fBexecve\fP(2) одновременно:
.LP
.nf
*** мы получаем syscall\-enter\-stop в нити 1: **
PID1 execve("/bin/foo", "foo" <unfinished ...>
*** мы выдаём PTRACE_SYSCALL для нити 1 **
*** мы получаем syscall\-enter\-stop в нити 2: **
PID2 execve("/bin/bar", "bar" <unfinished ...>
*** мы выдаём PTRACE_SYSCALL для нити 2 **
*** мы получаем PTRACE_EVENT_EXEC for PID0, мы выдаём PTRACE_SYSCALL **
*** мы получаем syscall\-exit\-stop для PID0: **
PID0 <... execve resumed> )             = 0
.fi
.LP
Если флаг \fBPTRACE_O_TRACEEXEC\fP \fIне\fP действует на выполняющуюся
трассируемую нить, то ядро доставляет ей дополнительный \fBSIGTRAP\fP после
возврата из \fBexecve\fP(2). Это обычный сигнал (похожий на тот, который
генерируется с помощью \fIkill \-TRAP\fP), а не какая\-то специальная
разновидность ptrace\-stop. Выдача \fBPTRACE_GETSIGINFO\fP для этого сигнала
возвращает \fIsi_code\fP равный 0 (\fISI_USER\fP). Этот сигнал может быть
блокирован маской сигналов и поэтому может быть доставлен (намного) позже.
.LP
Обычно, трассировщик (например, \fBstrace\fP(1)) не хотел бы показывать этот
дополнительный пост\-execve \fBSIGTRAP\fP сигнал пользователю, и хотел бы
подавить его доставку в трассируемую нить (если обработчик \fBSIGTRAP\fP равен
\fBSIG_DFL\fP, то это уничтожающий сигнал). Однако, определить \fIкакой\fP
\fBSIGTRAP\fP подавлять, нелегко. Рекомендуется установить флаг
\fBPTRACE_O_TRACEEXEC\fP и затем подавить этот дополнительный \fBSIGTRAP\fP.
.SS "Настоящий родитель"
Программный интерфейс ptrace использует стандартный обмен сигналами UNIX
между родителем и потомком через \fBwaitpid\fP(2). Это приводит к тому, что
настоящий родитель процесса перестаёт получать некоторые виды уведомлений
\fBwaitpid\fP(2), когда дочерний процесс трассируется другим процессом.
.LP
Многие из этих дефектов были исправлены, но на момент версии Linux 2.6.38
некоторые из них всё ещё существуют; смотрите ДЕФЕКТЫ далее.
.LP
На момент версии Linux 2.6.38 работает правильно:
.IP * 3
при выходе/уничтожении по сигналу об этом сначала сообщается трассировщику,
а затем,когда трассировщик подтвердит результат \fBwaitpid\fP(2), настоящему
родителю (настоящему родителю только когда завершается многонитиевой процесс
целиком). Если трассировщик и реальный родитель — один и тот же процесс, то
сообщение приходит лишь однажды.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении действий \fBPTRACE_PEEK*\fP возвращаются запрашиваемые
данные, а для остальных действий возвращается нулевое значение. При ошибке
для всех действий возвращается \-1, а переменной \fIerrno\fP присваивается номер
ошибки. Так как значение, возвращаемое при удачном выполнении
\fBPTRACE_PEEK*\fP, может равняться \-1, перед вызовом вызывающий должен
очистить содержимое \fIerrno\fP, чтобы узнать, возникала ошибка или нет.
.SH ОШИБКИ
.TP 
\fBEBUSY\fP
(только для i386) Произошла ошибка при размещении или освобождении
отладочного регистра.
.TP 
\fBEFAULT\fP
Была сделана попытка чтения или записи информации в область памяти
трассируемой нити или трассировщика, но, скорее всего, эта память не
отображена или недоступна. К сожалению, в Linux в разных ситуациях в
результате этой ошибки возвращаются значения \fBEIO\fP или \fBEFAULT\fP, что не
всегда поддается объяснению.
.TP 
\fBEINVAL\fP
Попытка установить недопустимое значение.
.TP 
\fBEIO\fP
Задано неверное значение \fIrequest\fP, или была попытка чтения или записи
информации в неподходящую область памяти трассируемой нити или
трассировщика; ошибка выравнивания слов по границе, или при запросе
возобновления работы дочернего процесса был задан неверно номер сигнала.
.TP 
\fBEPERM\fP
Указанный процесс не может быть трассирован. Это может произойти потому, что
трассировщик не имеет прав на трассировку (требуется мандат
\fBCAP_SYS_PTRACE\fP); непривилегированные процессы не могут трассировать
процессы, так как они не могут посылать сигналы, или если у них установлен
set\-user\-ID/set\-group\-ID бит. Также, процесс может уже трассироваться или
(на ядрах до версии 2.6.26) быть \fBinit\fP(8) (PID 1).
.TP 
\fBESRCH\fP
Указанный процесс не существует, в данный момент не трассируется вызывающим
процессом, или не остановлен (для выполнения действий, которые требуют
остановки трассируемой нити).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
SVr4, 4.3BSD.
.SH ЗАМЕЧАНИЯ
Несмотря на то, что аргументы \fBptrace\fP() обрабатываются в соответствии с
описанным выше прототипом, в glibc, на данный момент, функция \fBptrace\fP()
определена как вариативная функция с одним обязательным параметром
\fIrequest\fP. Это означает, что ненужные параметры могут быть проигнорированы,
что приведёт в действие неописанный здесь механизм \fBgcc\fP(1).
.LP
.\" See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
В ядрах Linux до версии 2.6.26, процесс \fBinit\fP(8) с PID 1 не может быть
трассирован.
.LP
.\" See http://lkml.org/lkml/2008/5/8/375
Структура памяти и области USER зависят от ОС и архитектуры
системы. Указываемое смещение и возвращаемые данные могут не полностью
соответствовать определению \fIstruct user\fP.
.LP
Размер «слова» определяется вариантом ОС (например, для 32\-битного варианта
Linux слово будет 32\-битным).
.LP
Эта страница описывает работу системного вызова \fBptrace\fP() в Linux. Его
работа значительно отличается от поведения в других системах UNIX. В любом
случае, использование \fBptrace\fP() очень сильно зависит от ОС и архитектуры.
.SH ДЕФЕКТЫ
На машинах с заголовочными файлами ядра 2.6 значение \fBPTRACE_SETOPTIONS\fP
отличается от использованного в версии 2.4. Это приводит к тому, что
приложения, скомпилированные с такими заголовочными файлами, не работают при
использовании ядер 2.4. Этого можно избежать сделав \fBPTRACE_SETOPTIONS\fP
равным \fBPTRACE_OLDSETOPTIONS\fP, если данная константа определена.
.LP
Уведомления group\-stop посылаются трассировщику, но не реальному
родителю. Последнее подтверждение в версии 2.6.38.6.
.LP
.\" Note from Denys Vlasenko:
.\"     Here "exits" means any kind of death - _exit, exit_group,
.\"     signal death. Signal death and exit_group cases are trivial,
.\"     though: since signal death and exit_group kill all other threads
.\"     too, "until all other threads exit" thing happens rather soon
.\"     in these cases. Therefore, only _exit presents observably
.\"     puzzling behavior to ptrace users: thread leader _exit's,
.\"     but WIFEXITED isn't reported! We are trying to explain here
.\"     why it is so.
.\"  FIXME: ^^^ need to test/verify this scenario
Если трассируется лидер группы нитей и завершается с помощью вызова
\fB_exit\fP(2), то происходит его останов \fBPTRACE_EVENT_EXIT\fP (если это
запрашивалось), но последующее уведомление \fBWIFEXITED\fP не будет доставлено
пока все остальные нити не завершат работу. Как объяснялось выше, если одна
из остальных нитей вызывает \fBexecve\fP(2), то о завершении лидера группы
\fIнигда\fP не будет сообщено. Если исполняемая нить не трассируется этим
трассировщиком, то трассировщик никогда не узнает, что происходил
\fBexecve\fP(2). Одним из обходных вариантов решения  в этом случае является
выполнение \fBPTRACE_DETACH\fP для лидера группы вместо перезапуска. Последнее
подтверждение в версии 2.6.38.6.
.LP
Сигнал \fBSIGKILL\fP всё ещё может вызвать остановку \fBPTRACE_EVENT_EXIT\fP перед
настоящем завершении процесса. Это поведение может измениться в будущем;
\fBSIGKILL\fP всегда подразумевает немедленное завершение задач даже под
ptrace. Последнее подтверждение в версии 2.6.38.6.
.LP
Некоторые системные вызовы возвращаются с \fBEINTR\fP, если сигнал был послан
трассируемой нити, но доставка была подавлена трассировщиком (это очень
распространённая операция: она обычно выполняется отладчиками при каждом
присоединении, чтобы не вызывать ненужный \fBSIGSTOP\fP). Начиная с Linux
3.2.9, подвержены следующие системные вызовы (вероятно, это не полный
список): \fBepoll_wait\fP(2) и \fBread\fP(2) из файлового дескриптора
\fBinotify\fP(7).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBgdb\fP(1), \fBstrace\fP(1), \fBclone\fP(2), \fBexecve\fP(2), \fBfork\fP(2),
\fBgettid\fP(2), \fBsigaction\fP(2), \fBtgkill\fP(2), \fBvfork\fP(2), \fBwaitpid\fP(2),
\fBexec\fP(3), \fBcapabilities\fP(7), \fBsignal\fP(7)

.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) Tom Bjorkholm, Markus Kuhn & David A. Wheeler 1996-1999
.\" and Copyright (C) 2007 Carsten Emde <Carsten.Emde@osadl.org>
.\" and Copyright (C) 2008 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" 1996-04-01 Tom Bjorkholm <tomb@mydata.se>
.\"            First version written
.\" 1996-04-10 Markus Kuhn <mskuhn@cip.informatik.uni-erlangen.de>
.\"            revision
.\" 1999-08-18 David A. Wheeler <dwheeler@ida.org> added Note.
.\" Modified, 25 Jun 2002, Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Corrected description of queue placement by sched_setparam() and
.\"		sched_setscheduler()
.\"	A couple of grammar clean-ups
.\" Modified 2004-05-27 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" 2005-03-23, mtk, Added description of SCHED_BATCH.
.\" 2007-07-10, Carsten Emde <Carsten.Emde@osadl.org>
.\"     Add text on real-time features that are currently being
.\"     added to the mainline kernel.
.\" 2008-05-07, mtk; Rewrote and restructured various parts of the page to
.\"     improve readability.
.\" 2010-06-19, mtk, documented SCHED_RESET_ON_FORK
.\"
.\" Worth looking at: http://rt.wiki.kernel.org/index.php
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SCHED_SETSCHEDULER 2 2011\-09\-19 Linux "Руководство программиста Linux"
.SH ИМЯ
sched_setscheduler, sched_getscheduler \- устанавливает или получает алгоритм
планирования (и его параметры)
.SH ОБЗОР
.nf
\fB#include <sched.h>\fP
.sp
\fBint sched_setscheduler(pid_t \fP\fIpid\fP\fB, int \fP\fIpolicy\fP\fB,\fP
.br
\fB                       const struct sched_param *\fP\fIparam\fP\fB);\fP
.sp
\fBint sched_getscheduler(pid_t \fP\fIpid\fP\fB);\fP
.sp
\fBstruct sched_param {
    ...
    int \fP\fIsched_priority\fP\fB;
    ...
};\fP
.fi
.SH ОПИСАНИЕ
Вызов \fBsched_setscheduler\fP() задаёт алгоритм и параметры планирования
выполнения процесса с идентификатором \fIpid\fP. Если \fIpid\fP равен нулю, то
будет изменён алгоритм вызывающего процесса. Тип и значение аргумента
\fIparam\fPp зависят от выбранного алгоритма. В настоящее время в Linux
поддерживаются следующие «обычные» (не реального времени) алгоритмы
планирования:
.TP  14
\fBSCHED_OTHER\fP
.\" In the 2.6 kernel sources, SCHED_OTHER is actually called
.\" SCHED_NORMAL.
алгоритм циклического обслуживания с разделением времени;
.TP 
\fBSCHED_BATCH\fP
«пакетный» стиль выполнения процессов;
.TP 
\fBSCHED_IDLE\fP
для выполнения фоновых заданий с \fIочень\fP низким приоритетом.
.PP
Для приложений, критичных к задержкам, которым требуется точный контроль над
выполнением, также поддерживаются следующие алгоритмы «реального времени»:
.TP  14
\fBSCHED_FIFO\fP
алгоритм «первым вошёл — первым вышел»;
.TP 
\fBSCHED_RR\fP
алгоритм циклического обслуживания.
.PP
Семантика каждого алгоритма описана далее.

.\"
Вызов \fBsched_getscheduler\fP() возвращает алгоритм планирования, которая
применена  к процессу с идентификатором \fIpid\fP. Если значение \fIpid\fP равно
нулю, то будет выдан алгоритм вызывающего процесса.
.SS "Алгоритмы планирования"
Планировщик — это часть ядра, которая решает какой запущенный процесс будет
выполняться процессором следующим. Каждому процессу назначается алгоритм
планирования и \fIстатический\fP приоритет планирования, \fIsched_priority\fP; эти
параметры изменяются вызовом \fBsched_setscheduler\fP(). Планировщик принимает
решение на основе данных об алгоритме планирования и статическом приоритете
всех процессов системы.

Для процессов, которые планируются одним из обычных алгоритмом планирования
(\fBSCHED_OTHER\fP, \fBSCHED_IDLE\fP, \fBSCHED_BATCH\fP), значение \fIsched_priority\fP
при принятии решения не используется (должен быть указан 0).

Для процессов, которые планируются одним из алгоритмов реального времени
(\fBSCHED_FIFO\fP, \fBSCHED_RR\fP), значение приоритета \fIsched_priority\fP лежит в
диапазоне от 1 (низкий) до 99 (высокий). Как и числовые значения, процессы
реального времени всегда имеют более высокий приоритет чем обычные
процессы. Но заметим: согласно POSIX.1\-2001 от реализации для алгоритмов
реального времени требуется поддержка минимум 32 различных уровней
приоритета, и в некоторых системах обеспечивается только этот минимум. В
переносимых программах нужно использовать вызовы
\fBsched_get_priority_min\fP(2) и \fBsched_get_priority_max\fP(2) для для
определения диапазона приоритетов, поддерживаемых определённым алгоритмом.

По существу, планировщик хранит в памяти списки всех работающих процессов
для каждого возможного значения \fIsched_priority\fP. Чтобы определить какой
процесс выполнять следующим, планировщик ищет непустой список с самым
высоким статическим приоритетом и выбирает процесс из начала списка.

Алгоритм планирования определяет, в какое место списка будет добавлен
процесс с тем же статическим приоритетом и как он будет перемещаться внутри
этого списка.

Всё планирование основано на вытеснении: если процесс с высшим статическим
приоритетом готов к выполнению, текущий выполняющийся процесс будет вытеснен
и возвращён в список ожидания согласно своему уровню статического
приоритета. Алгоритм выполнения только определяет порядок внутри списка
готовых к выполнению процессов с одинаковым статическим приоритетом.
.SS "SCHED_FIFO: планировщик «первым вошёл — первым вышел»"
Алгоритм \fBSCHED_FIFO\fP можно использовать только со значениями статического
приоритета большими нуля. Это означает, что если процесс с \fBSCHED_FIFO\fP
готов к работе, то он сразу запустится, а все обычные процессы с
\fBSCHED_OTHER\fP, \fBSCHED_BATCH\fP или \fBSCHED_IDLE\fP будут
приостановлены. \fBSCHED_FIFO\fP — это простой алгоритм планирования без
квантования времени. Процессы, работающие согласно алгоритму \fBSCHED_FIFO\fP,
подчиняются следующим правилам:
.IP * 3
Процесс с алгоритмом \fBSCHED_FIFO\fP, приостановленный другим процессом с
большим приоритетом, останется в начале списка процессов с равным
приоритетом, и его исполнение будет продолжено сразу после того, как
закончатся процессы с большими приоритетами.
.IP *
Когда процесс с алгоритмом \fBSCHED_FIFO\fP готов к работе, он помещается в
конец списка процессов с тем же приоритетом.
.IP *
.\" In 2.2.x and 2.4.x, the process is placed at the front of the queue
.\" In 2.0.x, the Right Thing happened: the process went to the back -- MTK
Вызов \fBsched_setscheduler\fP() или \fBsched_setparam\fP(2), поместит процесс с
номером \fIpid\fP и алгоритмом \fBSCHED_FIFO\fP (или \fBSCHED_RR\fP) в начало списка
процессов, если он запускаем. Как следствие, он может вытеснить
выполняющийся в данный момент процесс, если он имеет такой же приоритет. (В
POSIX 1003.1 указано, что процесс должен перейти в конец списка).
.IP *
Процесс, вызывающий \fBsched_yield\fP(2), будет помещён в конец списка.
.PP
Других событий для перемещения процесса с алгоритмом \fBSCHED_FIFO\fP в списке
ожидания запускаемых процессов с одинаковым статическим приоритетом не
существует.

Процесс с алгоритмом \fBSCHED_FIFO\fP выполняется до тех пор, пока не будет
заблокирован запросом ввода/вывода, вытеснен процессом с большим приоритетом
или пока не вызовет \fBsched_yield\fP(2).
.SS "SCHED_RR: планирование выполнения по циклу"
.\" On Linux 2.4, the length of the RR interval is influenced
.\" by the process nice value -- MTK
.\"
\fBSCHED_RR\fP — это просто улучшение SCHED_FIFO. Всё, относящееся к
\fBSCHED_FIFO\fP, справедливо и для \fBSCHED_RR\fP за исключением того, что
каждому процессу разрешено работать непрерывно не дольше максимального
кванта времени. Если процесс с алгоритмом \fBSCHED_RR\fP работал столько же или
дольше, чем квант, то он помещается в конец списка с тем же
приоритетом. Процесс с алгоритмом \fBSCHED_RR\fP, вытесненный процессом с
большим приоритетом, возобновляя работу, использует остаток своего кванта из
старого цикла. Длину этого кванта можно узнать, вызвав
\fBsched_rr_get_interval\fP(2).
.SS "SCHED_OTHER: планирование с разделение времени (по умолчанию в Linux)"
.\"
\fBSCHED_OTHER\fP можно использовать только с статическим приоритетом равным
нулю. \fBSCHED_OTHER\fP — это стандартный планировщик Linux с разделением
времени, предназначенный для всех процессов, не требующих специальных
механизмов реального времени. Для выполнения выбирается процесс из списка со
статическим приоритетом 0 на основе \fIдинамического\fP приоритета,
существующего только внутри этого списка. Динамический приоритет основан на
значении nice (установленном при помощи \fBnice\fP(2) или \fBsetpriority\fP(2)) и
увеличивается с каждым квантом времени, при котором процесс был готов к
работе, но ему было отказано в этом планировщиком. Таким образом время
равномерно распределяется между всеми процессами с алгоритмом
\fBSCHED_OTHER\fP.
.SS "SCHED_BATCH: планирование для пакетных процессов"
(начиная с Linux 2.6.16) \fBSCHED_BATCH\fP можно использовать только с
статическим приоритетом равным нулю. Этот алгоритм похож на \fBSCHED_OTHER\fP в
том, что он планирует выполнение процесса на основе его динамического
приоритета (на основе значения nice). Различие в том, что в этом алгоритме
планировщик всегда предполагает, что процесс в основном использует
ЦП. Следовательно, планировщик немного понизит вероятность его следующего
пробуждения для того, чтобы этот процесс уступал другим при планировании.

.\" The following paragraph is drawn largely from the text that
.\" accompanied Ingo Molnar's patch for the implementation of
.\" SCHED_BATCH.
.\"
Этот алгоритм полезен при нагрузках неинтерактивными задачами, но когда
нежелательно понижать их значение nice и для задач, которым требуется
предсказуемый алгоритм планирования без интерактивности, который приводит к
дополнительным вытеснениям (между задачами нагрузки).
.SS "SCHED_IDLE: планирование заданий с очень низким приоритетом"
(начиная с Linux 2.6.23)  \fBSCHED_IDLE\fP можно использовать только с
статическим приоритетом равным нулю; значение nice не учитывает в этом
алгоритме.

.\"
Данный алгоритм предназначен для выполнения заданий с чрезвычайно низким
приоритетом (даже ниже чем значение nice +19 в алгоритме \fBSCHED_OTHER\fP или
\fBSCHED_BATCH\fP).
.SS "Сброс алгоритма планирования у дочерних процессов"
Начиная с Linux 2.6.32, при вызове \fBsched_setscheduler\fP() к \fIpolicy\fP может
быть добавлен флаг \fBSCHED_RESET_ON_FORK\fP (с помощью OR). В результате
потомки, созданные с помощью \fBfork\fP(2), не будут наследовать
привилегированные алгоритмы планирования. Эта возможность предназначена для
приложений, проигрывающих медиа\-файлы, и может использоваться для обхождения
ограничения ресурса \fBRLIMIT_RTTIME\fP (см. \fBgetrlimit\fP(2)), посредством
создания нескольких дочерних процессов.

Точнее говоря, если указан флаг \fBSCHED_RESET_ON_FORK\fP, то к новым потомкам
применяются следующие правила:
.IP * 3
Если вызывающий процесс имеет алгоритм планирования \fBSCHED_FIFO\fP или
\fBSCHED_RR\fP, то у потомков алгоритм сбрасывается в \fBSCHED_OTHER\fP.
.IP *
Если у вызывающего процесса значение nice отрицательно, то у потомков
значение nice сбрасывается в ноль.
.PP
После установки флага \fBSCHED_RESET_ON_FORK\fP его можно сбросить только, если
процесс имеет мандат \fBCAP_SYS_NICE\fP. Этот флаг выключается у потомков,
созданных через \fBfork\fP(2).

.\"
Флаг \fBSCHED_RESET_ON_FORK\fP видим в значении алгоритма, которое возвращается
\fBsched_getscheduler\fP().
.SS "Привилегии и ограничения по ресурсам"
В ядрах Linux до версии 2.6.12, только привилегированные процессы
(\fBCAP_SYS_NICE\fP) могли устанавливать ненулевое значение статического
приоритета (т.е. алгоритм планирования реального
времени). Непривилегированные процессы могли только установить алгоритм
\fBSCHED_OTHER\fP, и это могло быть сделано только если эффективный
пользовательский идентификатор вызывающего \fBsched_setscheduler\fP() совпадал
с реальным или эффективным пользовательским идентификатором задаваемого
процесса (т.е., процесса, указываемого в \fIpid\fP).

Начиная с Linux 2.6.12, ограничитель ресурса \fBRLIMIT_RTPRIO\fP определяет
максимум статического приоритета непривилегированного процесса для
алгоритмов \fBSCHED_RR\fP и \fBSCHED_FIFO\fP. Правила для изменения алгоритма
планирования и приоритета:
.IP * 3
Если непривилегированный процесс имеет ненулевое значение мягкого
ограничения \fBRLIMIT_RTPRIO\fP, то он может изменять свой алгоритм
планирования и приоритет, но при этом значение приоритета не может быть
больше чем максимальное значение его текущего приоритета и его мягкого
ограничения \fBRLIMIT_RTPRIO\fP.
.IP *
Если мягкое ограничение \fBRLIMIT_RTPRIO\fP равно 0, то разрешается только
снижать приоритет или переключиться на алгоритм выполнения не реального
времени.
.IP *
Согласно тем же самым правилам другой непривилегированный процесс может
также сделать эти изменения, пока эффективный идентификатор пользователя
процесса, производящего изменение, совпадает с реальным или эффективным
идентификатором пользователя изменяемого процесса.
.IP *
.\" commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
Для \fBSCHED_IDLE\fP применяются специальные правила. В ядрах Linux до версии
2.6.39, сменить политику работы непривилегированного процесса нельзя,
независимо от значения его ограничителя ресурсов \fBRLIMIT_RTPRIO\fP. В ядрах
Linux начиная с версии 2.6.39, непривилегированный процесс может
переключиться на политику \fBSCHED_BATCH\fP или \fBSCHED_NORMAL\fP, если его
значение уступчивости находится в диапазоне, разрешённом ему ограничителем
ресурсов \fBRLIMIT_NICE\fP (смотрите \fBgetrlimit\fP(2)).
.PP
Для привилегированных (\fBCAP_SYS_NICE\fP) процессов ограничение
\fBRLIMIT_RTPRIO\fP игнорируется; как в старых ядрах, они могут произвольно
менять алгоритм планирования и приоритет. Подробней смотрите в
\fBgetrlimit\fP(2) про \fBRLIMIT_RTPRIO\fP.
.SS "Время ответа"
.\" as described in
.\" .BR request_irq (9).
Блокированный процесс с высоким приоритетом, ожидающий ввода/вывода,
освобождает достаточно много процессорного времени до того, как снова начнёт
работать. Авторы драйверов устройств могут более эффективно использовать это
время, если воспользуются «медленным» обработчиком прерываний.
.SS Разное
Дочерние процессы наследуют алгоритм планирования и его параметры после
\fBfork\fP(2). Алгоритм планирования и параметры сохраняются при вызове
\fBexecve\fP(2).

Обычно, процессам реального времени необходимо блокировать память для того,
чтобы избежать задержек при страничном обмене. Это можно сделать при помощи
вызова \fBmlock\fP(2) или \fBmlockall\fP(2).

Так как неблокирующий бесконечный цикл в процессе, работающем по алгоритму
\fBSCHED_FIFO\fP или \fBSCHED_RR\fP,  может навсегда заблокировать все процессы с
меньшим приоритетом, разработчик таких программ должен всегда оставлять на
одном из терминалов консоли оболочку, имеющую больший статический приоритет,
чем приоритет тестируемой программы. Это позволит прекратить работу
отлаживаемого приложения реального времени, которое работает не так, как
ожидается. Также смотрите описание ресурса \fBRLIMIT_RTTIME\fP в
\fBgetrlimit\fP(2).

В системах POSIX, в которых доступны \fBsched_setscheduler\fP() и
\fBsched_getscheduler\fP(), в \fI<unistd.h>\fP определён макрос
\fB_POSIX_PRIORITY_SCHEDULING\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении \fBsched_setscheduler\fP()  возвращается ноль. При
успешном выполнении \fBsched_getscheduler\fP()  возвращается алгоритм процесса
(неотрицательное целое). При ошибках возвращается \-1, а переменной \fIerrno\fP
присваивается соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEINVAL\fP
Неизвестное значение \fIpolicy\fP, значение \fIparam\fP равно NULL, или \fIparam\fP
не имеет смысла для \fIpolicy\fP.
.TP 
\fBEPERM\fP
Вызывающий процесс не имеет достаточно привилегий.
.TP 
\fBESRCH\fP
Процесс с идентификатором \fIpid\fP не найден.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
POSIX.1\-2001 (но смотрите ДЕФЕКТЫ далее). Алгоритмы \fBSCHED_BATCH\fP и
\fBSCHED_IDLE\fP есть только в Linux.
.SH ЗАМЕЧАНИЯ
В POSIX.1 не описаны права, которые требуются привилегированному процессу
для вызова \fBsched_setscheduler\fP(), и в разных системах используются разные
права. Например, в справочной странице Solaris 7 сказано, что реальный и
эффективный пользовательский идентификатор вызывающего процесса должен
совпадать с реальным пользовательским идентификатором или сохранённым
set\-user\-ID изменяемого процесса.
.PP
Изначально стандартный Linux представлял собой операционную систему общего
назначения для выполнения как фоновых процессов, так и интерактивных
приложений, а также нетребовательных приложений реального времени
(приложений, которым желательно, чтобы задержки и интервалы времени
выдерживались). Хотя ядро Linux 2.6 позволяет вытеснение и новый планировщик
O(1) обеспечивает необходимое постоянство планирования и предсказуемое
независимое количество активных задач, настоящая работа в реальном времени
стала доступна начиная с версии ядра 2.6.17.
.SS "Возможности выполнения в реальном времени из оригинальной версии Linux"
.\" FIXME . Probably this text will need some minor tweaking
.\" by about the time of 2.6.30; ask Carsten Emde about this then.
Начиная с версии 2.6.18 Linux постепенно обрастает возможностями выполнения
в реальном времени, большая часть которых взята из ранних заплаток
\fIrealtime\-preempt\fP, разработанных Ingo Molnar, Thomas Gleixner, Steven
Rostedt и другими. Пока заплатки полностью не вошли в оригинальное ядро
(ожидается к версии 2.6.30), они должны быть установлены отдельно. Файлы
заплаток называются
.in +4n
.nf

patch\-\fIверсия_ядра\fP\-rt\fIверсия_заплатки\fP
.fi
.in
.PP
и могут быть скачаны с
\fIhttp://www.kernel.org/pub/linux/kernel/projects/rt/\fP.

Без заплаток и до их полного включения в оригинальное ядро, через параметры
ядра предлагается только три класса вытеснения: \fBCONFIG_PREEMPT_NONE\fP,
\fBCONFIG_PREEMPT_VOLUNTARY\fP и \fBCONFIG_PREEMPT_DESKTOP\fP, которые,
соответственно, не сокращают, частично сокращают и значительно сокращают
задержку планирования при наихудшем случае.

С заплатками и после их полного включения в оригинальное ядро, в параметрах
ядра появится новый пункт \fBCONFIG_PREEMPT_RT\fP. Если он будет выбран, то
Linux преобразуется в обычную операционную систему реального
времени. Алгоритмы планирования FIFO и RR, которые можно выбрать с помощью
\fBsched_setscheduler\fP(), используются для выполнения процесса с настоящим
приоритетом реального времени и минимальной задержкой планирования в
наихудшем случае.
.SH ДЕФЕКТЫ
В POSIX указано, что при успешном выполнении \fBsched_setscheduler\fP() должно
возвращаться предыдущее значение алгоритма планирования. В Linux вызов
\fBsched_setscheduler\fP() не выполняет это требование, так как при успешном
выполнении всегда возвращает 0.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBgetpriority\fP(2), \fBmlock\fP(2), \fBmlockall\fP(2), \fBmunlock\fP(2),
\fBmunlockall\fP(2), \fBnice\fP(2), \fBsched_get_priority_max\fP(2),
\fBsched_get_priority_min\fP(2), \fBsched_getaffinity\fP(2), \fBsched_getparam\fP(2),
\fBsched_rr_get_interval\fP(2), \fBsched_setaffinity\fP(2), \fBsched_setparam\fP(2),
\fBsched_yield\fP(2), \fBsetpriority\fP(2), \fBcapabilities\fP(7), \fBcpuset\fP(7)
.PP
\fIProgramming for the real world \- POSIX.4\fP by Bill O. Gallmeister, O'Reilly
& Associates, Inc., ISBN 1\-56592\-074\-0
.PP
Файл из дерева исходного кода ядра
\fIDocumentation/scheduler/sched\-rt\-group.txt\fP (начиная с версии 2.6.25).

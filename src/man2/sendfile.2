.\" This man page is Copyright (C) 1998 Pawel Krawczyk.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: sendfile.2,v 1.5 1999/05/18 11:54:11 freitag Exp $
.\" 2000-11-19 bert hubert <ahu@ds9a.nl>: in_fd cannot be socket
.\"
.\" 2004-12-17, mtk
.\"	updated description of in_fd and out_fd for 2.6
.\"	Various wording and formatting changes
.\"
.\" 2005-03-31 Martin Pool <mbp@sourcefrog.net> mmap() improvements
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SENDFILE 2 2011\-09\-14 Linux "Руководство программиста Linux"
.SH ИМЯ
sendfile \- производит обмен данными между дескрипторами файлов
.SH ОБЗОР
\fB#include <sys/sendfile.h>\fP
.sp
.\" The below is too ugly. Comments about glibc versions belong
.\" in the notes, not in the header.
.\"
.\" .B #include <features.h>
.\" .br
.\" .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
.\" .br
.\" .B #include <sys/sendfile.h>
.\" .br
.\" #else
.\" .br
.\" .B #include <sys/types.h>
.\" .br
.\" .B /* No system prototype before glibc 2.1. */
.\" .br
.\" .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" \
.\"                       offset ", size_t" " count" )
.\" .br
.\" .B #endif
.\"
\fBssize_t sendfile(int\fP\fI out_fd\fP\fB, int\fP\fI in_fd\fP\fB, off_t *\fP\fIoffset\fP\fB,
size_t\fP\fI count\fP\fB);\fP
.SH ОПИСАНИЕ
Вызов \fBsendfile\fP() копирует данные из одного файлового дескриптора в
другой. Так как копирование производится в ядре, использование \fBsendfile\fP()
более эффективно чем комбинация \fBread\fP(2) и \fBwrite\fP(2), в которой
требуется скопировать данные в и из пользовательского пространства.

В \fIin_fd\fP должен указываться файловый дескриптор, открытый для чтения, а в
\fIout_fd\fP должен указываться файловый дескриптор, открытый для записи.

Если значение \fIoffset\fP не равно NULL, то оно указывает на переменную,
содержащую файловое смещение с которого \fBsendfile\fP() начнёт чтение данных
из \fIin_fd\fP. При завершении \fBsendfile\fP() значение этой переменной будет
содержать указатель на следующий байт после последнего прочитанного. Если
значение \fIoffset\fP не равно NULL, то \fBsendfile\fP() не изменяет текущее
файловое смещение \fIin_fd\fP; иначе текущее файловое смещение изменяется для
отражения количества прочитанных из \fIin_fd\fP байт.

Если значение \fIoffset\fP равно NULL, то данные будут прочитаны из \fIin_fd\fP
начиная с текущего файлового смещения, и по окончании работы вызова файловое
смещение будет обновлено.

В \fIcount\fP содержится количество байт, копируемых между файловыми
дескрипторами.

Значение \fIin_fd\fP должно описывать файл, который поддерживает операции типа
\fBmmap\fP(2) (т.е., не сокет).

В ядрах Linux до версии 2.6.33, значение \fIout_fd\fP должно указывать на
сокет. Начиная с Linux 2.6.33 можно указывать любой файл. Если это обычный
файл, то \fBsendfile\fP() изменит файловое смещение соответствующим образом.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
Если пересылка прошла успешно, то возвращается количество переданных в
\fIout_fd\fP байт. При ошибке возвращается \-1, а переменной \fIerrno\fP
присваивается номер ошибки.
.SH ОШИБКИ
.TP 
\fBEAGAIN\fP
Был выбран неблокирующий ввод\-вывод с помощью \fBO_NONBLOCK\fP, но запись
привела бы блокировке.
.TP 
\fBEBADF\fP
Входной файл не открыт для чтения или выходной файл не открыт для записи.
.TP 
\fBEFAULT\fP
Неправильный адрес.
.TP 
\fBEINVAL\fP
Неправильный или заблокированный дескриптор, или для \fIin_fd\fP недоступна
операция типа \fBmmap\fP(2).
.TP 
\fBEIO\fP
Неизвестная ошибка при чтении \fIin_fd\fP.
.TP 
\fBENOMEM\fP
Не хватает памяти для чтения \fIin_fd\fP.
.SH ВЕРСИИ
Вызов \fBsendfile\fP() впервые появился в Linux 2.2. Файл заголовков
\fI<sys/sendfile.h>\fP появился в glibc 2.1.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Отсутствует в POSIX.1\-2001 и других стандартах.

В других системах UNIX вызов \fBsendfile\fP() реализован с другими семантиками
и прототипами. Не должен использоваться в переносимых программах.
.SH ЗАМЕЧАНИЯ
Если вы планируете использовать \fBsendfile\fP() для отправки файлов через
сокет TCP и вам нужно послать некоторые заголовочные данные перед содержимым
файла, то обратите внимание на параметр \fBTCP_CORK\fP, описанный в \fBtcp\fP(7),
он поможет минимизировать количество пакетов и оптимизировать
производительность.

В Linux 2.4 и более ранних, значение \fIout_fd\fP может также указывать на
обычный файл, и \fBsendfile\fP() изменяет текущее смещение этого файла.

Первоначальная версия Linux \fBsendfile\fP() не была приспособлена для работы с
большими файловыми смещениями. В последствии в Linux 2.4 был добавлен вызов
\fBsendfile64\fP() с более широким диапазоном значений аргумента \fIoffset\fP. В
glibc \fBsendfile\fP() представляет собой обёрточную функцию, которая делает
незаметным разницу между версиями ядер.

Приложение может попытаться воспользоваться \fBread\fP(2)/\fBwrite\fP(2), если
вызов \fBsendfile\fP() завершится с ошибкой \fBEINVAL\fP или \fBENOSYS\fP.

Специальный вызов Linux \fBsplice\fP(2) поддерживает пересылку данных между
произвольными файлами (например, между парой сокетов).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBmmap\fP(2), \fBopen\fP(2), \fBsocket\fP(2), \fBsplice\fP(2)


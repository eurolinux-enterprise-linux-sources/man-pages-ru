.\" t
.\" Copyright (c) 2001, Michael Kerrisk (mtk.manpages@gmail.com)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" aeb, various minor fixes
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH SIGALTSTACK 2 2010\-09\-26 Linux "Руководство программиста Linux"
.SH ИМЯ
sigaltstack \- считывает или устанавливает расположение стека сигналов
.SH ОБЗОР
\fB#include <signal.h>\fP
.sp
\fBint sigaltstack(const stack_t *\fP\fIss\fP\fB, stack_t *\fP\fIoss\fP\fB);\fP
.sp
.in -4n
Требования макроса тестирования свойств для glibc
(см. \fBfeature_test_macros\fP(7)):
.in
.sp
\fBsigaltstack\fP():
.ad l
.RS 4
.PD 0
_BSD_SOURCE || _XOPEN_SOURCE\ >=\ 500 || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
.br
|| /* начиная с glibc 2.12: */ _POSIX_C_SOURCE\ >=\ 200809L
.PD
.RE
.ad
.SH ОПИСАНИЕ
Вызов \fBsigaltstack\fP() позволяет процессу определить новый альтернативный
стек сигналов и/или получить состояние уже имеющегося альтернативного стека
сигналов. Альтернативный стек сигналов используется при выполнении
обработчика сигналов, если он был запрошен при установлении обработчика
(см. \fBsigaction\fP(2)).

Обычный порядок действий для использования альтернативного стека сигналов:
.TP  3
1.
Выделить область памяти, которая будет использована под альтернативный стек
сигналов.
.TP 
2.
Вызвать \fBsigaltstack\fP() для информирования системы о существовании и
расположении альтернативного стека сигналов.
.TP 
3.
При установке обработчика сигналов с помощью \fBsigaction\fP(2) (флагом
\fBSA_ONSTACK\fP) сообщить системе, что обработчик сигналов должен выполняться
с альтернативным стеком сигналов.
.P
Аргумент \fIss\fP используется для указания нового альтернативного стека
сигналов, а аргумент \fIoss\fP используется для получения информации об
установленном в данный момент стеке сигналов. Если интересует какая\-то одна
из этих задач, то другой аргумент указывается как NULL. Каждый из аргументов
представляет структуру следующего вида:
.sp
.in +4n
.nf
typedef struct {
    void  *ss_sp;     /* базовый адрес стека */
    int    ss_flags;  /* флаги */
    size_t ss_size;   /* количество байт в стеке */
} stack_t;
.fi
.in

Чтобы задать новой альтернативный стек сигналов поле \fIss.ss_flags\fP
устанавливается в ноль, а в \fIss.ss_sp\fP и \fIss.ss_size\fP указываются
начальный адрес и размер стека. Для определения альтернативного стека
сигналов достаточного размера можно использовать константу \fBSIGSTKSZ\fP, а
для выделения стека минимального размера можно указать константу
\fBMINSIGSTKSZ\fP.

При вызове обработчика сигнала с альтернативным стеком ядро автоматически
выравнивает адрес, указанный в \fIss.ss_sp\fP, по границе адреса, подходящей
для используемой аппаратной платформы.

Для отключения существующего стека, укажите в \fIss.ss_flags\fP значение
\fBSS_DISABLE\fP. В этом случае остальные поля в \fIss\fP игнорируются.

Если \fIoss\fP не равно NULL, то в нём возвращается информация об
альтернативном стеке сигналов, который использовался до этого вызова
\fBsigaltstack\fP(). В полях \fIoss.ss_sp\fP и \fIoss.ss_size\fP возвращаются
начальный адрес и размер стека. В \fIoss.ss_flags\fP может быть возвращено одно
из следующих значений:
.TP 
\fBSS_ONSTACK\fP
В данный момент альтернативный стек сигналов используется процессом
(заметим, что в этот момент невозможно изменить альтернативный стек
сигналов).
.TP 
\fBSS_DISABLE\fP
В данный момент альтернативный стек сигналов выключен.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении \fBsigaltstack\fP() возвращается 0. В случае ошибки
возвращается \-1, а \fIerrno\fP устанавливается в соответствующее значение.
.SH ОШИБКИ
.TP 
\fBEFAULT\fP
Значение \fIss\fP или \fIoss\fP не равно NULL и указывает за пределы адресного
пространства процесса.
.TP 
\fBEINVAL\fP
Значение \fIss\fP не равно NULL и в поле \fIss_flags\fP содержится ненулевое
значение, не равное \fBSS_DISABLE\fP.
.TP 
\fBENOMEM\fP
Указанный размер нового альтернативного стека сигналов (\fIss.ss_size\fP)
меньше \fBMINSTKSZ\fP.
.TP 
\fBEPERM\fP
Была попытка изменить альтернативный стек сигналов при его активности
(т.е. текущий альтернативный стек сигналов уже задействован при выполнении
процесса).
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
SUSv2, SVr4, POSIX.1\-2001.
.SH ЗАМЕЧАНИЯ
В основном, альтернативный стек сигналов используется при обработке сигнала
\fBSIGSEGV\fP, который возникает при нехватке свободного места в обычном стеке
процесса: в этом случае обработчик сигнала \fBSIGSEGV\fP не может использовать
стек процесса; если требуется обработка данного сигнала, нужно использовать
альтернативный стек сигналов.
.P
Назначение альтернативного стека сигналов полезно, если ожидается, что
процесс может задействовать весь свой обычный стек. Это может случиться,
например, когда стек становится настолько большим, что он встречается с
растущей в вверх «кучей», или достигает ограничения, заданного вызовом
\fBsetrlimit(RLIMIT_STACK, &rlim)\fP. Если стандартный стек закончился, то ядро
посылает процессу сигнал \fBSIGSEGV\fP. В этих условиях единственным способом
поймать сигнал будет задействование альтернативного стека сигналов.
.P
На большинстве аппаратных архитектур, поддерживаемых Linux, стеки растут
сверху вниз. Вызов \fBsigaltstack\fP() автоматически учтёт направление роста
стека.
.P
Функции, вызываемые из обработчика сигналов исполняемого с использованием
альтернативного стека сигналов, также будут использовать альтернативный стек
сигналов (это также применимо к любым обработчикам, вызванным по другим
сигналам в то время как процесс выполняется с альтернативным стеком
сигналов). В отличие от стандартного стека система автоматически не
расширяет альтернативный стек сигналов. Превышение выделенного размера
альтернативного стека сигналов приведёт к непредсказуемым результатам.
.P
При успешном выполнении вызова \fBexecve\fP(2) любой существующий
альтернативный стек сигналов удаляется. Дочерний процесс, созданный с
помощью \fBfork\fP(2), наследует копию настроек альтернативного стека сигналов
своего родителя.
.P
Вызов \fBsigaltstack\fP() заменяет устаревший вызов \fBsigstack\fP(). Для обратной
совместимости в glibc также есть функция \fBsigstack\fP(). Во всех новых
приложениях нужно использовать \fBsigaltstack\fP().
.SS История
Системный вызов \fBsigstack\fP() появился в 4.2BSD. В нём использовалась слегка
другая структура, и его главным недостатком было то, что вызывающий должен
был учитывать направления роста стека.
.SH ПРИМЕР
В следующем сегменте кода показано использование \fBsigaltstack\fP():

.in +4n
.nf
stack_t ss;

ss.ss_sp = malloc(SIGSTKSZ);
if (ss.ss_sp == NULL)
    /* обработка ошибки */;
ss.ss_size = SIGSTKSZ;
ss.ss_flags = 0;
if (sigaltstack(&ss, NULL) == \-1)
    /* обработка ошибки */;
.fi
.in
.SH "СМОТРИТЕ ТАКЖЕ"
\fBexecve\fP(2), \fBsetrlimit\fP(2), \fBsigaction\fP(2), \fBsiglongjmp\fP(3),
\fBsigsetjmp\fP(3), \fBsignal\fP(7)

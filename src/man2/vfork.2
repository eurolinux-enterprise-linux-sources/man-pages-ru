.\" Copyright (c) 1999 Andries Brouwer (aeb@cwi.nl), 1 Nov 1999
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" 1999-11-10: Merged text taken from the page contributed by
.\" Reed H. Petty (rhp@draper.net)
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH VFORK 2 2012\-02\-08 Linux "Руководство программиста Linux"
.SH ИМЯ
vfork \- создаёт дочерний процесс и блокирует родительский
.SH ОБЗОР
\fB#include <sys/types.h>\fP
.br
\fB#include <unistd.h>\fP
.sp
\fBpid_t vfork(void);\fP
.sp
.in -4n
Требования макроса тестирования свойств для glibc
(см. \fBfeature_test_macros\fP(7)):
.in
.sp
\fBvfork\fP():
.ad l
.RS 4
.PD 0
.TP  4
Начиная с glibc 2.12:
.nf
_BSD_SOURCE ||
    (_XOPEN_SOURCE\ >=\ 500 ||
        _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED) &&
    !(_POSIX_C_SOURCE\ >=\ 200809L || _XOPEN_SOURCE\ >=\ 700)
.TP  4
.fi
До glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\ >=\ 500 || _XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
.PD
.RE
.ad b
.SH ОПИСАНИЕ
.SS "Описание в стандарте"
(Из POSIX) Функция \fBvfork\fP() аналогична \fBfork\fP(2) за тем исключением, что
поведение не определено, если процесс, созданный \fBvfork\fP(), изменяет любые
данные, кроме переменной типа \fIpid_t\fP, используемой в качестве значения,
возвращаемого \fBvfork\fP(), или возвращается из функции, из которой была
вызвана функция \fBvfork\fP(), или вызывает любую функцию до удачного
исполнения \fB_exit\fP(2) или одной из функций семейства \fBexec\fP(3).
.SS "Описание в Linux"
\fBvfork\fP(), так же как и \fBfork\fP(2), создаёт дочерний процесс для
вызывающего процесса. Подробности, возвращаемые значения и ошибки смотрите в
\fBfork\fP(2).
.PP
\fBvfork\fP() \(em это специальный вариант \fBclone\fP(2). Он используется для
создания новых процессов без копирования таблиц страниц родительского
процесса. Это может использоваться в приложениях, критичных к
производительности, для создания дочерних процессов, сразу же запускающих
\fBexecve\fP(2).
.PP
Вызов \fBvfork\fP() отличается от \fBfork\fP(2) тем, что вызывающая нить
блокируется до тех пор, пока не завершится потомок (обычно, вызвав
\fB_exit\fP(2) или, что ненормально, из\-за принятого необработанного сигнала)
или не выполнит \fBexecve\fP(2). До этих пор потомок имеет общую память с
родителем, включая стек. Потомок не должен выходить из текущей функции или
вызывать \fBexit\fP(3), но может вызвать \fB_exit\fP(2).

Как и у \fBfork\fP(2), дочерний процесс, созданный \fBvfork\fP(), наследует копии
различных атрибутов вызвавшего процесса (например, дескрипторы файлов,
обработчики сигналов и текущий рабочий каталог); вызов \fBvfork\fP() отличается
только в применении виртуального адресного пространства (как описывалось
выше).

Сигналы передаются родителю после того, как потомок разблокирует его память
(т.е. после того, как потомок завершится или вызовет \fBexecve\fP(2)).
.SS "Историческое описание"
В Linux вызов \fBfork\fP(2) реализован при помощи страниц, «копируемых при
записи» (copy\-on\-write), поэтому единственная задержка, возникающая при
вызове \fBfork\fP(2) \(em это время, необходимое для создания копии таблиц
страниц родительского процесса и уникальной структуры описания задачи
дочернего процесса. Однако, в прошлом для \fBfork\fP(2) могло требоваться
создание полной копии пространства данных вызывающего процесса, что часто
было ненужно, так как в потомке сразу следовал запуск функции
\fBexec\fP(3). Поэтому для большей эффективности в BSD был предложен системный
вызов \fBvfork\fP(), который не копировал адресное пространство процесса, а
использовал то же самое пространство и управления нитью, блокируя
родительский процесс до вызова \fBexecve\fP(2) или до прекращения работы
потомка. Родительский процесс останавливался до тех пор, пока потомок
использовал его ресурсы. Использование \fBvfork\fP() было ненадёжно: например,
сохранность данных родительского процесса зависела от того, хранились ли на
тот момент переменные в регистрах.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
4.3BSD; POSIX.1\-2001 (помечен как УСТАРЕВШИЙ). Из POSIX.1\-2008 описание
\fBvfork\fP() было удалено.

.\" In AIXv3.1 vfork is equivalent to fork.
Требования, предъявляемые стандартами к \fBvfork\fP(), не такие жёсткие как те,
которые предъявляются к \fBfork\fP(2), поэтому в реализации достаточно просто
сделать их синонимами. В частности, программист не может полагаться на
блокировку родителя до завершения потомка или до вызова им \fBexecve\fP(2), и
не может полагаться на специфическое поведение возникновения общей памяти.
.SH ЗАМЕЧАНИЯ
.PP
Некоторые считают, что в семантике \fBvfork\fP() есть архитектурный недостаток,
а в справочной странице BSD написано следующее: «Данный системный вызов
будет удалён после того, как будут правильно реализованы соответствующие
механизмы разделения ресурсов системы. Пользователи не должны опираться на
существующую семантику общей памяти \fBvfork\fP(), то есть программа должна
быть аналогична программе с \fBfork\fP(2)». Однако, даже при том, что
современные аппаратные средства управления памятью уменьшили разницу в
производительности между \fBfork\fP(2) и \fBvfork\fP(), есть другие причины почему
в Linux и других операционных системах \fBvfork\fP() ещё существует:
.IP * 3
Для некоторых критичных к производительности приложений очень важна та
маленькая прибавка к производительности, предоставляемая \fBvfork\fP().
.IP *
.\" http://stackoverflow.com/questions/4259629/what-is-the-difference-between-fork-and-vfork
.\" http://developers.sun.com/solaris/articles/subprocess/subprocess.html
.\" http://mailman.uclinux.org/pipermail/uclinux-dev/2009-April/000684.html
Вызов \fBvfork\fP() может быть реализован в системах, у которых нет блока
управления памятью (MMU), а \fBfork\fP(2) невозможно реализовать на таких
системах (из POSIX.1\-2008 вызов \fBvfork\fP() удалён; для реализации
эквивалента \fBfork\fP(2)+\fBexec\fP(3) в системах без MMU в POSIX предлагается
использовать функцию \fBposix_spawn\fP(3)).
.SS "Замечания, касающиеся Linux"
Обработчики fork, установленные с помощью \fBpthread_atfork\fP(3), не
вызываются когда многонитиевая программа использует вызовы библиотеки нитей
NPTL \fBvfork\fP(). Обработчики fork вызываются в этом случае в программе, в
которой используется библиотека нитей LinuxThreads. (См. в \fBpthreads\fP(7)
описание библиотек нитей Linux.)

Вызов \fBvfork\fP() эквивалентен вызову \fBclone\fP(2) со следующим значением
\fIflags\fP:

     CLONE_VM | CLONE_VFORK | SIGCHLD

.SS История
.\" In the release notes for 4.2BSD Sam Leffler wrote: `vfork: Is still
.\" present, but definitely on its way out'.
Системный вызов \fBvfork\fP() впервые появился в 3.0BSD. В BSD 4.4 он стал
синонимом  \fBfork\fP(2), но в NetBSD он был введён снова:
http://www.netbsd.org/Documentation/kernel/vfork.html. В Linux этот
системный вызов был эквивалентом \fBfork\fP(2) примерно до ядра
2.2.0\-pre6. Начиная с 2.2.0\-pre9 (на i386 и немного позже на других
архитектурах), он стал независимым системным вызовом. Его поддержка была
добавлена в glibc 2.0.112.
.SH ДЕФЕКТЫ
.PP
.\"
.\" As far as I can tell, the following is not true in 2.6.19:
.\" Currently (Linux 2.3.25),
.\" .BR strace (1)
.\" cannot follow
.\" .BR vfork ()
.\" and requires a kernel patch.
Обработка сигналов ещё более запутана и различается от системы к системе. В
справочной странице BSD написано следующее: "Для исключения возможности
взаимных блокировок процессы, находящиеся в середине исполнения \fBvfork\fP(),
никогда не получат сигналов \fBSIGTTOU\fP или \fBSIGTTIN\fP, хотя вывод или
\fIioctl\fP всегда разрешены, а попытки ввода приводят к ситуации появления
конца файла."
.SH "СМОТРИТЕ ТАКЖЕ"
\fBclone\fP(2), \fBexecve\fP(2), \fBfork\fP(2), \fBunshare\fP(2), \fBwait\fP(2)

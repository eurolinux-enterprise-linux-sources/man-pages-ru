.\" Copyright 2002 walter harms (walter.harms@informatik.uni-oldenburg.de)
.\" Distributed under GPL
.\" based on the description in glibc source and infopages
.\"
.\" Corrections and additions, aeb
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH ARGZ_ADD 3 2007\-05\-18 "" "Руководство программиста Linux"
.SH ИМЯ
argz_add, argz_add_sep, argz_append, argz_count, argz_create,
argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next,
argz_replace, argz_stringify \- функции для обработки списка argz
.SH ОБЗОР
.nf
\fB#include <argz.h>\fP
.sp
\fBerror_t argz_add(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, const char *\fP\fIstr\fP\fB);\fP
.sp
\fBerror_t argz_add_sep(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIstr\fP\fB, int \fP\fIdelim\fP\fB);\fP
.sp
\fBerror_t argz_append(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIbuf\fP\fB, size_t \fP\fIbuf_len\fP\fB);\fP
.sp
\fBsize_t argz_count(const char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_create(char * const \fP\fIargv\fP\fB[], char **\fP\fIargz\fP\fB,\fP
.ti 20n
\fBsize_t *\fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_create_sep(const char *\fP\fIstr\fP\fB, int \fP\fIsep\fP\fB, char **\fP\fIargz\fP\fB,\fP
.ti 20n
\fBsize_t *\fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_delete(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, char *\fP\fIentry\fP\fB);\fP
.sp
\fBvoid argz_extract(char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB, char  **\fP\fIargv\fP\fB);\fP
.sp
\fBerror_t argz_insert(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, char *\fP\fIbefore\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIentry\fP\fB);\fP
.sp
\fBchar *argz_next(char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB, const char *\fP\fIentry\fP\fB);\fP
.sp
\fBerror_t argz_replace(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, const char *\fP\fIstr\fP\fB,\fP
.ti 20n
\fBconst char *\fP\fIwith\fP\fB, unsigned int *\fP\fIreplace_count\fP\fB);\fP
.sp
\fBvoid argz_stringify(char *\fP\fIargz\fP\fB, size_t \fP\fIlen\fP\fB, int \fP\fIsep\fP\fB);\fP
.fi
.SH ОПИСАНИЕ
Эти функции есть только в glibc.
.LP
Вектор argz представляет собой указатель на символьный буфер и его
длину. Данный символьный буфер следует считать массивом строк, разделённых
байтами null (\(aq\e0\(aq). Если длина ненулевая, то последний байт в буфере
должен быть null.
.LP
Эти функции предназначены для обработки векторов argz. Пара (NULL,0)
представляет вектор argz и наоборот, векторы argz длиной 0 должны иметь
указатель NULL. Размещение непустых векторов argz осуществляется функцией
\fBmalloc\fP(3), а для высвобождения пространства можно использовать
\fBfree\fP(3).
.LP
Функция \fBargz_add\fP() добавляет строку \fIst\fPr в конец массива \fI*argz\fP, и
обновляет \fI*argz\fP и \fI*argz_len\fP.
.LP
Функция \fBargz_add_sep\fP() делает тоже самое, но разделяет строку \fIstr\fP на
подстроки, разделяя их символом \fIdelim\fP. Например, это можно использовать
при работе с путями поиска UNIX, где разделителем является \(aq:\(aq.
.LP
Функция \fBargz_append\fP() добавляет вектор argz (\fIbuf\fP,\ \fIbuf_len\fP) после
(\fI*argz\fP,\ \fI*argz_len\fP) и обновляет \fI*argz\fP и \fI*argz_len\fP (таким
образом, \fI*argz_len\fP будет увеличено на \fIbuf_len\fP).
.LP
Функция \fBargz_count\fP() подсчитывает количество строк, то есть количество
байтов null в (\(aq\e0\(aq), в (\fIargz\fP,\ \fIargz_len\fP).
.LP
Функция \fBargz_create\fP() преобразует аргумент вектора \fIargv\fP в стиле UNIX,
заканчивающийся на \fI(char *) 0\fP, в вектор argz (\fI*argz\fP,\ \fI*argz_len\fP).
.LP
Функция \fBargz_create_sep\fP() преобразует строку \fIstr\fP, заканчивающуюся
null, в вектор argz (\fI*argz\fP,\ \fI*argz_len\fP), разделяя её при каждом
нахождении разделителя \fIsep\fP.
.LP
Функция \fBargz_delete\fP() удаляет подстроку, на которую указывает \fIentry\fP,
из вектора argz (\fI*argz\fP,\ \fI*argz_len\fP) и обновляет \fI*argz\fP и
\fI*argz_len\fP.
.LP
Функция \fBargz_extract\fP() является противоположностью \fBargz_create\fP(). Она
берёт вектор argz (\fIargz\fP,\ \fIargz_len\fP) и заполняет массив, начиная с
\fIargv\fP, указателями на подстроки и завершая его NULL, тем самым создавая
вектор argv в стиле UNIX. Массив \fIargv\fP должен иметь пространство для
\fIargz_count\fP(\fIargz\fP,\fIargz_len\fP) + 1 указателей.
.LP
Функция \fBargz_insert\fP() является противоположностью \fBargz_delete\fP(). Она
вставляет аргумент \fIentry\fP с позиции \fIbefore\fP в вектор (\fI*argz\fP,\ \fI*argz_len\fP) и обновляет \fI*argz\fP и \fI*argz_len\fP. Если значение \fIbefore\fP
равно NULL, то значение \fIentry\fP будет вставлено в конец.
.LP
Функция \fBargz_next\fP() предназначена для последовательного обхода вектора
argz. Если значение \fIentry\fP равно NULL, то возвращается первый
элемент. Иначе возвращается следующий элемент. Если следующего элемента нет,
то возвращается NULL.
.LP
Функция \fBargz_replace\fP() заменяет каждую найденную строку \fIstr\fP на
\fIwith\fP, изменяя размер argz при необходимости. Если значение
\fIreplace_count\fP не равно NULL, то значение \fI*replace_count\fP будет
увеличено на число замен.
.LP
Функция \fBargz_stringify\fP() является противоположностью
\fBargz_create_sep\fP(). Она преобразует вектор argz в обычную строку, заменяя
все байты null (\(aq\e0\(aq), за исключением последнего, значением \fIsep\fP.
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
Все функции argz, в которых происходит выделение памяти, возвращают
результат, имеющий тип \fIerror_t\fP: 0 — при успешном выполнении и \fBENOMEM\fP —
при ошибке выделения памяти.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
Данные функции являются расширениями GNU. Используйте с осторожностью.
.SH ДЕФЕКТЫ
Векторы argz без завершающего байта null могут привести к ошибкам
сегментирования.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBenvz_add\fP(3)

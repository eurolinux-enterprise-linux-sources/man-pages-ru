.\" -*- nroff -*-
.\" Copyright 1995 Yggdrasil Computing, Incorporated.
.\" written by Adam J. Richter (adam@yggdrasil.com),
.\" with typesetting help from Daniel Quinlan (quinlan@yggdrasil.com).
.\" and Copyright 2003 Michael Kerrisk (mtk.manpages@gmail.com).
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
.\" USA.
.\"
.\" Modified by David A. Wheeler <dwheeler@dwheeler.com> 2000-11-28.
.\" Applied patch by Terran Melconian, aeb, 2001-12-14.
.\" Modified by Hacksaw <hacksaw@hacksaw.org> 2003-03-13.
.\" Modified by Matt Domsch, 2003-04-09: _init and _fini obsolete
.\" Modified by Michael Kerrisk <mtk.manpages@gmail.com> 2003-05-16.
.\" Modified by Walter Harms: dladdr, dlvsym
.\" Modified by Petr Baudis <pasky@suse.cz>, 2008-12-04: dladdr caveat
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH DLOPEN 3 2008\-12\-06 Linux "Руководство программиста Linux"
.SH ИМЯ
dladdr, dlclose, dlerror, dlopen, dlsym, dlvsym \- программный интерфейс к
динамически компонующему загрузчику
.SH ОБЗОР
\fB#include <dlfcn.h>\fP
.sp
\fBvoid *dlopen(const char *\fP\fIfilename\fP\fB, int \fP\fIflag\fP\fB);\fP
.sp
\fBchar *dlerror(void);\fP
.sp
\fBvoid *dlsym(void *\fP\fIhandle\fP\fB, const char *\fP\fIsymbol\fP\fB);\fP
.sp
\fBint dlclose(void *\fP\fIhandle\fP\fB);\fP
.sp
Компонуется при указании параметра \fI\-ldl\fP.
.SH ОПИСАНИЕ
Интерфейс динамически компонующего загрузчика реализован четырьмя функциями:
\fBdlopen\fP(), \fBdlsym\fP(), \fBdlclose\fP(), \fBdlerror\fP().
.SS dlerror()
Функция \fBdlerror\fP() возвращает понятную для человека строку, описывающую
последнюю произошедшую ошибку в \fBdlopen\fP(), \fBdlsym\fP() или \fBdlclose\fP() с
последнего вызова \fBdlerror\fP(). Она возвращает NULL, если ошибок не было с
начала инициализации или с момента её последнего вызова.
.SS dlopen()
Функция \fBdlopen\fP() загружает динамическую библиотеку, имя которой указано в
строке \fIfilename\fP (завершается нулём) и возвращает прямой указатель на
динамическую библиотеку. Если \fIfilename\fP равно NULL, то возвращается
указатель на основную программу. Если \fIfilename\fP содержит косую черту
("/"), то это воспринимается как имя с путём (относительным или
абсолютным). Иначе динамический компоновщик ищет библиотеку в следующих
местах (подробности см. в \fBld.so\fP(8)):
.IP o 4
(только в ELF) Если исполняемый файл вызывающей программы содержит метку
DT_RPATH, т не содержит метки DT_RUNPATH, то производится поиск в каталогах,
описанных в метке DT_RPATH.
.IP o
Если при запуске программы была определена переменная окружения
\fBLD_LIBRARY_PATH\fP, содержащая список каталогов через двоеточие, то
производится поиск в этих каталогах. (По соображениям безопасности эта
переменная игнорируется для программ с установленными битами set\-user\-ID и
set\-group\-ID.)
.IP o
(только в ELF) Если исполняемый файл вызывающей программы содержит метку
DT_RUNPATH, то производится поиск по каталогам, перечисленным в этой метке.
.IP o
Производится проверка в кэширующем файле \fI/etc/ld.so.cache\fP (обслуживается
\fBldconfig\fP(8)) на предмет наличия записи для \fIfilename\fP.
.IP o
Просматриваются каталоги \fI/lib\fP и \fI/usr/lib\fP (именно в таком порядке).
.PP
Если библиотека зависит от других общих библиотек, то они также
автоматически загружаются динамическим компоновщиком согласно этим же
правилам. (Процесс может выполняться рекурсивно, если эти библиотеки, в свою
очередь, зависят от других библиотек, и так далее.)
.PP
В \fIflag\fP должно быть одно из следующих значений:
.TP 
\fBRTLD_LAZY\fP
Выполнять позднее связывание. Выполняется поиск только тех символов, на
которые есть ссылки из кода. Если на символ никогда не ссылаются, то он
никогда не будет разрешён. (Позднее связывание (lazy binding) выполняется
только при ссылке на функции; ссылки на переменные всегда привязываются
сразу при загрузке библиотеки.)
.TP 
\fBRTLD_NOW\fP
Если указано данное значение или переменная окружения \fBLD_BIND_NOW\fP не
пуста, то все неопределённые символы в библиотеке ищутся до возврата из
\fBdlopen\fP(). Если этого сделать не удаётся, то возвращается ошибка.
.PP
Также в В \fIflag\fP может быть ноль или более значение, объединяемых по ИЛИ:
.TP 
\fBRTLD_GLOBAL\fP
Символы, определённые в библиотеке, будут доступны при поиске символов, для
загружаемых далее библиотек.
.TP 
\fBRTLD_LOCAL\fP
Противоположность \fBRTLD_GLOBAL\fP, используется по умолчанию, если не задано
ни одного флага. Символы, определённые в библиотеке, не будут доступны при
разрешении ссылок для загружаемых далее библиотек.
.TP 
\fBRTLD_NODELETE\fP (начиная с glibc 2.2)
.\" (But it is present on Solaris.)
Не выгружать библиотеку при \fBdlclose\fP(). В результате статические
переменные библиотеки не инициализируются повторно, если библиотека
загружается снова по \fBdlopen\fP(). Этого флага нет в POSIX.1\-2001.
.TP 
\fBRTLD_NOLOAD\fP (начиная с glibc 2.2)
.\" (But it is present on Solaris.)
.\"
Не загружать библиотеку. Это можно использовать для тестирования, загружена
ли уже библиотека (\fBdlopen\fP() возвращает NULL, если нет, или указатель на
библиотеку, если она загружена). Этот флаг можно также использовать для
изменения флагов уже загруженной библиотеке. Например, если библиотека была
загружена с флагом \fBRTLD_LOCAL\fP, то её можно повторно открыть с
\fBRTLD_NOLOAD\ |\ RTLD_GLOBAL\fP. Этого флага нет в POSIX.1\-2001.
.TP 
\fBRTLD_DEEPBIND\fP (начиная с glibc 2.3.4)
.\" Inimitably described by UD in
.\" http://sources.redhat.com/ml/libc-hacker/2004-09/msg00083.html.
Задать библиотеку, в которой поиск символов будет осуществляться перед
поиском в области глобальных символов. Это означает, что самодостаточная
библиотека будет использовать свои собственные символы вместо глобальных
символов с тем же именем, содержащихся в библиотеках, которые уже были
загружены. Этого флага нет в POSIX.1\-2001.
.PP
Если вместо \fIfilename\fP указан NULL, то возвращается указатель на главную
программу. При передаче в \fBdlsym\fP(), этот указатель вызывает поиск символа
в главной программе, затем во все общих библиотеках, загруженных при запуске
программы, и затем во всех общих библиотеках, загруженных \fBdlopen\fP() с
флагом \fBRTLD_GLOBAL\fP.
.PP
Внешние ссылки в библиотеке разрешаются с использованием библиотек по их
списку библиотечных зависимостей и других библиотеках, ранее открытых с
флагом \fBRTLD_GLOBAL\fP. Если исполняемый файл скомпонован с параметром
"\-rdynamic" (или тождественным ему "\-\-export\-dynamic"), то глобальные
символы в исполняемом файле будут также использоваться при разрешении
зависимостей в динамически загружаемой библиотеке.
.PP
Если данная библиотека загружается с помощью \fBdlopen\fP() снова, то
возвращается тот же указатель на файл. Библиотека dl ведёт счётчик ссылок
для библиотечных указателей, поэтому динамическая библиотека не
высвобождается \fBdlclose\fP() до тех пор, пока он не будет вызвана столько же
раз сколько и \fBdlopen\fP(). Процедура \fB_init\fP(), если есть, вызывается
только однажды. Но последующий вызов с флагом \fBRTLD_NOW\fP может привести к
поиску символов для библиотеки ранее загруженной с флагом \fBRTLD_LAZY\fP.
.PP
Если по какой\-то причине \fBdlopen\fP() завершается неудачно, то возвращается
NULL.
.SS dlsym()
Функция \fBdlsym\fP() принимает "указатель" динамической библиотеки,
возвращаемой \fBdlopen\fP(), и null\-завершённое имя символа, и возвращает
адрес, по которому этот символ загружен в память. Если символ не найден, в
указанной библиотеке или во всех библиотеках, которые были автоматически
загружены \fBdlopen\fP() при загрузке этой библиотеки, \fBdlsym\fP() возвращает
NULL. (Поиск, выполняемый \fBdlsym\fP(), охватывает всё дерево зависимостей
этих библиотек.) Так как значением символа может быть на самом деле NULL
(возвращаемый NULL из \fBdlsym\fP() не нужно считать ошибкой), правильным
способом проверки на ошибки \(em это вызвать \fBdlerror\fP() для очистки всех
старых условий ошибок, затем вызвать \fBdlsym\fP(), а затем вызвать
\fBdlerror\fP() ещё раз, сохранив возвращаемое значение в переменной, и
проверить, не равно ли сохранённое значение NULL.
.PP
Существует два псевдо\-указателя, \fBRTLD_DEFAULT\fP и \fBRTLD_NEXT\fP. По первому
можно определить первое появление желаемого символа при поиске в библиотеках
в порядке по умолчанию. По последнему будет найдено следующее появление
функции при поиске вне текущей библиотеки. Это позволяет создать обёртку
вокруг функции другой общей библиотеки.
.SS dlclose()
Функция \fBdlclose\fP() уменьшает счётчик ссылок на указатель динамической
библиотеки \fIhandle\fP. Если счётчик ссылок достигает нуля и нет других
загруженных библиотек использующих её символы, то динамическая библиотека
выгружается.
.LP
Функция \fBdlclose\fP() возвращает 0 в случае успешной работы, и не ноль при
ошибке.
.SS "Устаревшие символы _init() и _fini()"
Компоновщик учитывает специальные символы \fB_init\fP и \fB_fini\fP. Если
динамическая библиотека экспортирует процедуру с именем \fB_init\fP(), то её
код исполняется после загрузки, до возврата из \fBdlopen\fP(). Если
динамическая библиотека экспортирует процедуру с именем \fB_fini\fP(), то её
код вызывается перед тем как библиотека будет выгружена. Если вам нужно
избежать компоновки с системными файлами запуска, то можно воспользоваться
параметром командной строки \fBgcc\fP(1) \fI\-nostartfiles\fP.
.LP
.\" void _init(void) __attribute__((constructor));
.\" void _fini(void) __attribute__((destructor));
Использование данных процедур или параметров gcc \fB\-nostartfiles\fP или
\fB\-nostdlib\fP не рекомендуется. Их использование может привести к нежелаемому
поведению, так как не будут выполнены процедуры конструктора/деструктора
(если не будут приняты специальные меры).
.LP
Вместо этого библиотеки должны экспортировать процедуры с помощью атрибутов
функций \fB__attribute__((constructor))\fP и
\fB__attribute__((destructor))\fP. Подробней см. страницы info по
gcc. Процедуры конструктора выполняются до возврата из \fBdlopen\fP(), а
процедуры деструктора выполняются перед возвратом из \fBdlclose\fP().
.SS "Расширения glibc: dladdr() и dlvsym()"
В glibc добавлены две функции, не описанные в POSIX, с прототипами
.sp
.nf
\fB#define _GNU_SOURCE\fP         /* см. feature_test_macros(7) */
\fB#include <dlfcn.h>\fP
.sp
\fBint dladdr(void *\fP\fIaddr\fP\fB, Dl_info *\fP\fIinfo\fP\fB);\fP
.sp
\fBvoid *dlvsym(void *\fP\fIhandle\fP\fB, char *\fP\fIsymbol\fP\fB, char *\fP\fIversion\fP\fB);\fP
.fi
.PP
Функция \fBdladdr\fP() вызывается с указателем на функцию и пытается найти имя
и файл, где она расположена. Информация сохраняется в структуре \fIDl_info\fP:
.sp
.in +4n
.nf
typedef struct {
    const char *dli_fname;  /* Путь к общему объекту с
                               адресом */
    void       *dli_fbase;  /* Адрес, по которому загружен общий
                               объект */
    const char *dli_sname;  /* Имя ближайшего символа с адресом
                               меньше чем \fIaddr\fP */
    void       *dli_saddr;  /* Точный адрес символа с
                               именем в \fIdli_sname\fP */
} Dl_info;
.fi
.in
.PP
Если символ, соответствующий адресу \fIaddr\fP, не найден, то \fIdli_sname\fP и
\fIdli_saddr\fP устанавливаются в NULL.
.PP
В случае ошибки \fBdladdr\fP() возвращает 0, и ненулевое значение в случае
успеха.
.PP
Функция \fBdlvsym\fP(), предоставляемая glibc начиная с версии 2.1, работает
также как и \fBdlsym\fP(), но ожидает строку с версией в качестве
дополнительного аргумента.
.SH "СООТВЕТСТВИЕ СТАНДАРТАМ"
В POSIX.1\-2001 описаны \fBdlclose\fP(), \fBdlerror\fP(), \fBdlopen\fP() и \fBdlsym\fP().
.SH ЗАМЕЧАНИЯ
.\" .LP
.\" The string returned by
.\" .BR dlerror ()
.\" should not be modified.
.\" Some systems give the prototype as
.\" .sp
.\" .in +5
.\" .B "const char *dlerror(void);"
.\" .in
Символы \fBRTLD_DEFAULT\fP и \fBRTLD_NEXT\fP определены в \fI<dlfcn.h>\fP
только когда определён символ \fB_GNU_SOURCE\fP до включения.

Начиная с glibc 2.2.3, \fBatexit\fP(3) может использоваться для регистрации
обработчика завершения работы, который автоматически вызывается при выгрузке
библиотеки.
.SS История
Стандарт интерфейса dlopen впервые появился в SunOS. В этой системе также
была функция \fBdladdr\fP(), но не было \fBdlvsym\fP().
.SH ДЕФЕКТЫ
Иногда указатели на функции, передаваемые в \fBdladdr\fP(), могут вас
удивить. На некоторых архитектурах (в частности, i386 и x86_64),
\fIdli_fname\fP и \fIdli_fbase\fP могут указывать на объект, из которого
вызывалась функция \fBdladdr\fP(), даже если функция, использовавшаяся как
аргумент, должна быть из динамически скомпонованной библиотеки.
.PP
Проблема в том, что указатель на функцию по прежнему ищется во время
компиляции, но всего лишь указывает на раздел \fIplt\fP (таблицу компоновки
процедур) первоначального объекта (которая размещает вызов после запроса
динамического компоновщика на поиск символа). Чтобы обойти это, вы можете
попробовать скомпилировать независимый от размещения код: в этом случае
компилятор больше не сможет подготовить указатель во время компиляции и
\fBgcc\fP(1) создаст код, который просто загрузит конечный адрес символа из
\fIgot\fP (глобальной таблицы смещений) при запуске до передачи его в
\fBdladdr\fP().
.SH ПРИМЕР
Загружает математическую библиотеку и печатает косинус 2.0:
.nf

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int
main(int argc, char **argv)
{
    void *handle;
    double (*cosine)(double);
    char *error;

    handle = dlopen("libm.so", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "%s\en", dlerror());
        exit(EXIT_FAILURE);
    }

    dlerror();    /* Очистка всех результатов ошибок */

    /* Вывод: cosine = (double (*)(double)) dlsym(handle, "cos");
       кажется более естественным, но стандарт C99 оставляет
       преобразование из "void *" к указателю на функцию неопределённым.
       Назначение, используемое ниже, это временное решение
       POSIX.1\-2003 (Technical Corrigendum 1); см. обоснование для
       dlsym() в спецификации POSIX. */

.\" But in fact "gcc -O2 -Wall" will complain about the preceding cast.
    *(void **) (&cosine) = dlsym(handle, "cos");

    if ((error = dlerror()) != NULL)  {
        fprintf(stderr, "%s\en", error);
        exit(EXIT_FAILURE);
    }

    printf("%f\en", (*cosine)(2.0));
    dlclose(handle);
    exit(EXIT_SUCCESS);
}
.fi
.PP
Если эта программа записана в файл с именем "foo.c", то для сборки программы
введите команду:
.in +4n
.LP
    gcc \-rdynamic \-o foo foo.c \-ldl
.in
.PP
Библиотеки, экспортирующие \fB_init\fP() и \fB_fini\fP(), нужно компилировать так
(на примере \fIbar.c\fP):
.in +4n
.LP
    gcc \-shared \-nostartfiles \-o bar bar.c
.in
.SH "СМОТРИТЕ ТАКЖЕ"
\fBld\fP(1), \fBldd\fP(1), \fBdl_iterate_phdr\fP(3), \fBrtld\-audit\fP(7), \fBld.so\fP(8),
\fBldconfig\fP(8), info\-страницы ld.so, gcc и ld

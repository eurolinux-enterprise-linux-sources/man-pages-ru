.\" Copyright (c) 1995 Jim Van Zandt <jrv@vanzandt.mv.com> and aeb
.\" Sun Feb 26 11:46:23 MET 1995
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\" Modified, Sun Feb 26 15:04:20 1995, faith@cs.unc.edu
.\" Modified, Thu Apr 20 22:08:17 1995, jrv@vanzandt.mv.com
.\" Modified, Mon Sep 18 22:32:47 1995, hpa@storm.net (H. Peter Anvin)
.\" FIXME The following are not documented:
.\"     KDFONTOP (since 2.1.111)
.\"     KDGKBDIACRUC (since 2.6.24)
.\"     KDSKBDIACR
.\"     KDSKBDIACRUC (since 2.6.24)
.\"     KDKBDREP (since 2.1.113)
.\"     KDMAPDISP (not implemented as at 2.6.27)
.\"     KDUNMAPDISP (not implemented as at 2.6.27)
.\"     VT_LOCKSWITCH (since 1.3.47, needs CAP_SYS_TTY_CONFIG)
.\"     VT_UNLOCKSWITCH (since 1.3.47, needs CAP_SYS_TTY_CONFIG)
.\"     VT_GETHIFONTMASK (since 2.6.18)
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CONSOLE_IOCTL 4 2009\-02\-28 Linux "Руководство программиста Linux"
.SH ИМЯ
console_ioctl \- управление вводом\-выводом (ioctl) консольного терминала и
виртуальных консолей
.SH ОПИСАНИЕ
Поддерживаются Linux\-ориентированные запросы \fBioctl\fP(2), перечисленные
далее. Для каждого запроса требуется третий аргумент, который далее
именуется \fIargp\fP.
.IP \fBKDGETLED\fP
Получить состояние индикаторов. \fIargp\fP указывает ячейку типа \fIchar\fP. В
младших трёх битах \fI*argp\fP хранится состояние индикаторов:

    LED_CAP       0x04   индикатор caps lock
    LEC_NUM       0x02   индикатор num lock
    LED_SCR       0x01   индикатор scroll lock
.IP \fBKDSETLED\fP
Установить состояние индикаторов. Состояние индикаторов устанавливается в
соответствии с тремя младшими битами \fIargp\fP. Однако, если установлен
старший бит, индикаторы возвращаются в исходное состояние: отображают
состояние функций клавиатуры caps lock, num lock и scroll lock.
.LP
До появления ядра 1.1.54 индикаторы состояния отражали только состояние
флагов клавиатуры, которые также могли быть изменены
KDGETLED/KDSETLED. После появления 1.1.54 они могли отображать уже
произвольную информацию, но по умолчанию показывали флаги
клавиатуры. Последующие две команды ioctl используются для доступа к флагам
клавиатуры.
.IP \fBKDGKBLED\fP
Получить флаги клавиатуры: CapsLock, NumLock, ScrollLock (не
индикаторы). \fIargp\fP указывает на ячейку типа char, в которой сохраняется
состояния флагов. Младшие три бита (маска 0x7) содержат текущее состояние
флагов, следующие три бита (маска 0x70) содержат устанавливаемое состояние
флагам по умолчанию. (Начиная с ядра 1.1.54).
.IP \fBKDSKBLED\fP
Установить флаги клавиатуры: CapsLock, NumLock, ScrollLock (не
индикаторы). \fIargp\fP содержит требуемые состояния флагов. Три младших бита
(маска 0x7) содержат состояния флагов, следующие три бита (маска 0x70)
содержат состояния флагов по умолчанию. (Начиная с 1.1.54).
.IP \fBKDGKBTYPE\fP
Получить тип клавиатуры. Возвращается значение KB_101 равное 0x02.
.IP \fBKDADDIO\fP
Добавить порт ввода/вывода (I/O) как допустимый. Эквивалентно вызову
\fIioperm(arg,1,1)\fP.
.IP \fBKDDELIO\fP
Удалить порт ввода/вывода (I/O) как недопустимый. Эквивалентно вызову
\fIioperm(arg,1,0)\fP.
.IP \fBKDENABIO\fP
Включить ввод/вывод на видеокарту. Эквивалентно вызову \fIioperm(0x3b4,
0x3df\-0x3b4+1, 1)\fP.
.IP \fBKDDISABIO\fP
Выключить ввод/вывод на видеокарту. Эквивалентно вызову \fIioperm(0x3b4,
0x3df\-0x3b4+1, 0)\fP.
.IP \fBKDSETMODE\fP
Установить текстовый/графический режим. \fIargp\fP содержит одно из двух
значений:

    KD_TEXT       0x00
    KD_GRAPHICS   0x01
.IP \fBKDGETMODE\fP
Получить тип режима (текстовый/графический). \fIargp\fP указывает на ячейку
типа \fIlong\fP, которой присваивается одно из вышеперечисленных
устанавливаемых значений.
.IP \fBKDMKTONE\fP
Генерировать тон заданной длительности. Младшие 16 битов \fIargp\fP задают
частоту тона (период в тактах), старшие 16 битов устанавливают его
длительность в мсек. Если длительность равна нулю, звук
выключается. Управление возвращается немедленно. Например, \fIargp\fP =
(125<<16) + 0x637 определяет звук, обычно связанный с
ctrl\-G. (Работает начиная с 0.99pl1; не работает в 2.1.49\-50).
.IP \fBKIOCSOUND\fP
Запустить и остановить генерацию звука. Младшие 16 битов \fIargp\fP определяют
период в тактах (то есть \fIargp\fP = 1193180/частота). Значение \fIargp\fP = 0
выключает звук. В обоих случаях управление возвращается немедленно.
.IP \fBGIO_CMAP\fP
Получить из ядра текущую цветовую карту по умолчанию. \fIargp\fP указывает на
массив из 48 байтов. (Начиная с 1.3.3.)
.IP \fBPIO_CMAP\fP
Изменить цветовую карту по умолчанию для текстового режима.  \fIargp\fP
указывает на массив из 48 байтов, который содержит, по порядку, значения
красного, зеленого и синего для 16\-и доступных экранных цветов: 0 \(em
составляющая выключена, 255 \(em полная интенсивность. Цвета по умолчанию,
по порядку: чёрный, тёмно\-красный, тёмно\-зелёный, коричневый, тёмно\-синий,
тёмно\-сиреневый, тёмно\-голубой, светло\-сервый, тёмно\-серый, ярко\-красный,
ярко\-зелёный, жёлтый, ярко\-синий, ярко\-сиреневый, ярко\-голубой и
белый. (Начиная с 1.3.3).
.IP \fBGIO_FONT\fP
Получить экранный шрифт (256 символов) в расширенном виде. \fIargp\fP указывает
на массив из 8192 байтов. Возвращает код ошибки \fBEINVAL\fP, если текущий
загруженный шрифт содержит 512 символов или консоль находится не в текстовом
режиме.
.IP \fBGIO_FONTX\fP
Получить экранный шрифт и связанную с ним информацию. \fIargp\fP указывает на
\fIstruct consolefontdesc\fP (см. \fBPIO_FONTX\fP). При вызове значение поля
\fIcharcount\fP должно быть равно максимальному числу символов, которое
помещается в буфер, указываемый \fIchardata\fP. При возврате \fIcharcount\fP и
\fIcharheight\fP содержат информацию о текущем загруженном шрифте, а массив
\fIchardata\fP содержит данные шрифта, если согласно начальному значению
\fIcharcount\fP для этого достаточно места; в противном случае буфер остаётся
неизменным и \fIerrno\fP присваивается значение \fBENOMEM\fP. (Начиная с 1.3.1).
.IP \fBPIO_FONT\fP
Установить экранный шрифт из 256 символов. Шрифт загружается в
знакогенератор EGA/VGA. \fIargp\fP указывает на карту размером 8192 байта (32
байта на символ). Только первые N из них используются для шрифта 8x\fIN\fP (0
< \fIN\fP <= 32). Этот вызов также отменяет перекодировку в Юникод.
.IP \fBPIO_FONTX\fP
Установить экранный шрифт и соответствующую информацию для
изображения. \fIargp\fP указывает на структуру:

.in +4n
.nf
struct consolefontdesc {
    unsigned short charcount;  /* число символов в шрифте
                                  (256 или 512) */
    unsigned short charheight; /* число линий сканирования на
                                  символ (1\-32) */
    char          *chardata;   /* данные шрифта в
                                  расширенном формате */
};
.fi
.in

Если требуется, соответственно изменяются размеры экрана и соответствующим
процессам посылается сигнал \fBSIGWINCH\fP. Этот вызов также отменяет
перекодировку в Юникод. (Начиная с 1.3.1).
.IP \fBPIO_FONTRESET\fP
Сбросить экранный шрифт, размер и перекодировку в Юникод в начальные
значения, использованные при загрузке. Аргумент \fIargp\fP не используется, но
его значение должно быть NULL, чтобы эта версия была совместима с будущими
версиями Linux. (Начиная с 1.3.28).
.IP \fBGIO_SCRNMAP\fP
Получить разметку экрана из ядра. \fIargp\fP указывает на область размером
E_TABSZ, которая заполняется позициями символов шрифта, используемыми при
отображении. Вызов возвращает бесполезную информацию, если текущий
загруженный шрифт содержит более 256 символов.
.IP \fBGIO_UNISCRNMAP\fP
Получить полную экранную перекодировку в Юникод из ядра. \fIargp\fP указывает
на область размером E_TABSZ*sizeof(unsigned short), которая заполняется
представлением в Юникоде каждого символа. Специальный набор Юникода,
начинающийся с U+F000, используется для перекодировки "напрямую в
шрифт". (Начиная с 1.3.1).
.IP \fBPIO_SCRNMAP\fP
Загрузить "определяемую пользователем" (четвёртую) таблицу в ядро, по
которой перекодируются байты в символы экрана консоли. \fIargp\fP указывает на
область размером E_TABSZ.
.IP \fBPIO_UNISCRNMAP\fP
Загрузить "определяемую пользователем" (четвёртую) таблицу в ядро,
перекодирующую байты в значения Юникода, которые затем транслируются в
экранные символы согласно текущей загруженной карте соответствия символов
Юникода и шрифта. Специальные коды Юникода, начинающиеся с U+F000, могут
использоваться для непосредственного перевода байтов в символы
шрифта. (Начиная с 1.3.1).
.IP \fBGIO_UNIMAP\fP
Получить соответствие символов Юникода шрифту из ядра. \fIargp\fP указывает на
структуру

.in +4n
.nf
struct unimapdesc {
    unsigned short  entry_ct;
    struct unipair *entries;
};
.fi
.in

где \fIentries\fP указывает на массив структур

.in +4n
.nf
struct unipair {
    unsigned short unicode;
    unsigned short fontpos;
};
.fi
.in

(Начиная с 1.1.92.)
.IP \fBPIO_UNIMAP\fP
Поместить соответствие символов Юникода и экранного шрифта в ядро.
\fIargp\fP указывает на
\fIstruct unimapdesc\fP.
(Начиная с 1.1.92).
.IP \fBPIO_UNIMAPCLR\fP
Очистить таблицу, возможно с помощью алгоритма хэширования. \fIargp\fP
указывает на структуру

.in +4n
.nf
struct unimapinit {
    unsigned short advised_hashsize;  /* 0, если не использовать */
    unsigned short advised_hashstep;  /* 0, если не использовать */
    unsigned short advised_hashlevel; /* 0, если не использовать */
};
.fi
.in

(Начиная с 1.1.92.)
.IP \fBKDGKBMODE\fP
Получить текущий режим клавиатуры. \fIargp\fP указывает на ячейку типа \fIlong\fP,
в которой может быть одно из значений:

    K_RAW         0x00
    K_XLATE       0x01
    K_MEDIUMRAW   0x02
    K_UNICODE     0x03
.IP \fBKDSKBMODE\fP
Установить текущий режим клавиатуры. \fIargp\fP указывает на ячейку типа
\fIlong\fP, значением которой может быть любое из представленных чуть ранее.
.IP \fBKDGKBMETA\fP
Получить режим обработки метаклавиш. \fIargp\fP указывает на ячейку типа
\fIlong\fP, в которой может быть одно из значений:

    K_METABIT     0x03   установлен старший бит
    K_ESCPREFIX   0x04   экранирующий префикс
.IP \fBKDSKBMETA\fP
Установить режим обработки метаклавиш. \fIargp\fP указывает на ячейку типа
\fIlong\fP, значением которой может быть любое из представленных чуть ранее.
.IP \fBKDGKBENT\fP
Получить один элемент из таблицы трансляции клавиш (код клавиши для кода
действия). \fIargp\fP указывает на структуру

.in +4n
.nf
struct kbentry {
    unsigned char  kb_table;
    unsigned char  kb_index;
    unsigned short kb_value;
};
.fi
.in

значения двух первых полей представляют собой: \fIkb_table\fP \(em выбранную
таблицу клавиш (0 <= \fIkb_table\fP < MAX_NR_KEYMAPS) и \fIkb_index\fP
\(em код клавиши (0 <= \fIkb_index\fP < NR_KEYS). \fIkb_value\fP
присваивается соответствующий код действия или K_HOLE, если нет такой
клавиши, или K_NOSUCHMAP, если значение \fIkb_table\fP неверно.
.IP \fBKDSKBENT\fP
Создать элемент в таблице трансляции клавиш. \fIargp\fP указывает на \fIstruct
kbentry\fP.
.IP \fBKDGKBSENT\fP
Получить значение строки функциональной клавиши. \fIargp\fP указывает на
структуру

.in +4n
.nf
struct kbsentry {
    unsigned char kb_func;
    unsigned char kb_string[512];
};
.fi
.in

\fIkb_string\fP равна (заканчивающейся null) строке, соответствующей коду
действия функциональной клавиши \fIkb_func\fP.
.IP \fBKDSKBSENT\fP
Создать элемент строки функциональной клавиши. \fIargp\fP указывает на \fIstruct
kbsentry\fP.
.IP \fBKDGKBDIACR\fP
Получить таблицу акцентов из ядра. \fIargp\fP указывает на структуру

.in +4n
.nf
struct kbdiacrs {
    unsigned int   kb_cnt;
    struct kbdiacr kbdiacr[256];
};
.fi
.in

где \fIkb_cnt\fP \(em число элементов массива, каждый из которых является
структурой

.in +4n
.nf
struct kbdiacr {
    unsigned char diacr;
    unsigned char base;
    unsigned char result;
};
.fi
.in
.IP \fBKDGETKEYCODE\fP
Получить элемент таблицы кодов клавиш ядра (сканкод в код клавиши). \fIargp\fP
указывает на структуру

.in +4n
.nf
struct kbkeycode {
    unsigned int scancode;
    unsigned int keycode;
};
.fi
.in

\fIkeycode\fP устанавливается в соответствии с заданным
\fIscancode\fP. (Допускается 89 <= \fIscancode\fP <= 255. Для 1 <=
\fIscancode\fP <= 88, \fIkeycode\fP==\fIscancode\fP.) (Начиная с 1.1.63.)
.IP \fBKDSETKEYCODE\fP
Записать элемент таблицы кодов клавиш ядра. \fIargp\fP указывает на \fIstruct
kbkeycode\fP.  (Начиная с 1.1.63).
.IP \fBKDSIGACCEPT\fP
Вызывающий процесс показывает свою готовность к приему сигнала \fIargp\fP, если
он генерируется нажатием соответствующей комбинации клавиш. (1 <=
\fIargp\fP <= NSIG). (См. функцию spawn_console() в
linux/drivers/char/keyboard.c).
.IP \fBVT_OPENQRY\fP
Получить первую доступную (не открытую) консоль. \fIargp\fP указывает ячейку
типа \fIint\fP, устанавливаемое значение которой равно номеру vt (1 <=
\fI*argp\fP <= MAX_NR_CONSOLES).
.IP \fBVT_GETMODE\fP
Считывает режим активного vt. \fIargp\fP указывает на структуру

.in +4n
.nf
struct vt_mode {
    char  mode;    /* режим vt */
    char  waitv;   /* при установленном; остановка при записи, если терминал неактивен */
    short relsig;  /* послать сигнал при освобождении req */
    short acqsig;  /* послать сигнал при захвате */
    short frsig;   /* не используется (устанавливается в 0) */
};
.fi
.in

которая задаёт режим активного vt.  \fImode\fP имеет одно из значений:

    VT_AUTO       автоматическое переключение vt
    VT_PROCESS    обрабатывать управление переключением
    VT_ACKACQ     подтверждающий переключатель
.IP \fBVT_SETMODE\fP
Установить режим активного vt. \fIargp\fP указывает на \fIstruct vt_mode\fP.
.IP \fBVT_GETSTATE\fP
Получить общую информацию о состоянии vt. \fIargp\fP указывает на структуру

.in +4n
.nf
struct vt_stat {
    unsigned short v_active;  /* активный vt */
    unsigned short v_signal;  /* посылаемый сигнал */
    unsigned short v_state;   /* битовая маска vt */
};
.fi
.in

Для каждого используемого vt устанавливается соответствующий бит в поле
\fIv_state\fP. (В версиях с 1.0 до 1.1.92).
.IP \fBVT_RELDISP\fP
Освободить дисплей.
.IP \fBVT_ACTIVATE\fP
Переключиться на виртуальный терминал \fIargp\fP (1 <= \fIargp\fP <=
MAX_NR_CONSOLES).
.IP \fBVT_WAITACTIVE\fP
Подождать, пока виртуальный терминал \fIargp\fP не станет активным.
.IP \fBVT_DISALLOCATE\fP
Освободить память, выделенную виртуальному терминалу \fIargp\fP. (Начиная с
1.1.54.)
.IP \fBVT_RESIZE\fP
Установить представление о размере экрана в ядре. \fIargp\fP указывает на
структуру

.in +4n
.nf
struct vt_sizes {
    unsigned short v_rows;       /* количество строк */
    unsigned short v_cols;       /* количество столбцов */
    unsigned short v_scrollsize; /* не используется */
};
.fi
.in

Заметим, что этот вызов не изменяет видеорежим. Смотрите
\fBresizecons\fP(8). (Начиная с 1.1.54.)
.IP \fBVT_RESIZEX\fP
Установить значение различных параметров экрана в ядре. \fIargp\fP указывает на
структуру

.in +4n
.nf
struct vt_consize {
    unsigned short v_rows;  /* количество строк */
    unsigned short v_cols;  /* количество столбцов */
    unsigned short v_vlin;  /* количество строк на экране
                               в пикселях */
    unsigned short v_clin;  /* количество строк в символе
                               в пикселях */
    unsigned short v_vcol;  /* количество столбцов на экране
                               в пикселях */
    unsigned short v_ccol;  /* количество столбцов в символе
                               в пикселях */
};
.fi
.in

Любому параметру может быть присвоено нулевое значение, указывающее
"оставить без изменений", но, если задано несколько параметров, то они
должны быть согласованы. Этот вызов не изменяет видеорежим. Смотрите
\fBresizecons\fP(8). (Начиная с 1.3.3).
.PP
Действие следующих ioctl зависит от первого байта структуры, указываемой
\fIargp\fP, далее называемой \fIsubcode\fP. Доступны только суперпользователю или
владельцу текущего tty.
.IP "\fBTIOCLINUX, subcode=0\fP"
Сделать дамп экрана. Удалено в 1.1.92. (С ядром 1.1.92 и более поздним
используйте чтение из /dev/vcsN или /dev/vcsaN).
.IP "\fBTIOCLINUX, subcode=1\fP"
Получить информацию о задании. Удалено в 1.1.92.
.IP "\fBTIOCLINUX, subcode=2\fP"
Произвести выделение. \fIargp\fP указывает на структуру
.in +4n
.nf

struct {
   char  subcode;
   short xs, ys, xe, ye;
   short sel_mode;
};

.fi
.in
\fIxs\fP и \fIys\fP \(em начальные столбец и строка. \fIxe\fP и \fIye\fP \(em конечные
столбец и строка. (У левого верхнего угла строка=столбец=1.) Значение
\fIsel_mode\fP равно 0 для выделения "символ за символом", 1 для выделения
"слово за словом" или 2 для выделения "строки за строкой". Выделенные
символы подсвечиваются и сохраняются в статическом массиве sel_buffer из
devices/char/console.c.
.IP "\fBTIOCLINUX, subcode=3\fP"
Вставить выделение. Символы буфера выделения записываются в \fIfd\fP.
.IP "\fBTIOCLINUX, subcode=4\fP"
Включить погашенный ранее (blank) экран.
.IP "\fBTIOCLINUX, subcode=5\fP"
Установить содержимое 256\-битной таблицы поиска определения символов в
"word" для выделения "слово за словом". (Начиная с 1.1.32).
.IP "\fBTIOCLINUX, subcode=6\fP"
\fIargp\fP указывает ячейку типа char, которая устанавливает значение
переменной ядра \fIshift_state\fP. (Начиная 1.1.32.)
.IP "\fBTIOCLINUX, subcode=7\fP"
\fIargp\fP указывает ячейку типа char, которая устанавливает значение
переменной ядра \fIreport_mouse\fP. (Начиная с 1.1.33.)
.IP "\fBTIOCLINUX, subcode=8\fP"
Сделать дамп значений ширины и высоты экрана, позиции курсора и всех пар
символ\-атрибут. (Только в версиях с 1.1.67 по 1.1.91. С ядром 1.1.92 и более
поздних версий используйте чтение из /dev/vcsa*).
.IP "\fBTIOCLINUX, subcode=9\fP"
Восстановить ширину и высоту экрана, позицию курсора и все пары
символ\-атрибут. (Только в версиях с 1.1.67 по 1.1.91. С ядром 1.1.92 и более
поздних версий используйте запись в /dev/vcsa*).
.IP "\fBTIOCLINUX, subcode=10\fP"
Обработчик функций энергосбережения для нового поколения мониторов. Режим
гашения (blanking) экрана VESA устанавливается равным \fIargp\fP[1], который
определяет тип гашения:

    \fI0\fP: гашение экрана выключено.

    \fI1\fP: текущие установки регистров видеоадаптера сохраняются, когда контроллер  программируется на отключение вертикальной синхронизации. Происходит перевод монитора в режим "ожидания" (standby).
Если в мониторе есть таймер Off_Mode, то он может в итоге сам
выключить питание.

    \fI2\fP: текущие настройки сохраняются, а затем вертикальная и
горизонтальная синхронизации отключаются. Происходит перевод
в режим "выключен" (off). Если в мониторе нет таймера
Off_Mode или вы хотите отключить питание сразу же по
истечении времени blank_timer, то можете выбрать это значение.
(\fIВнимание:\fP частое выключение питания может повредить монитор.)

(Начиная с 1.1.76.)
.SH "ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ"
При успешном выполнении возвращается 0. В случае ошибки возвращается \-1, а
\fIerrno\fP устанавливается в соответствующее значение.
.SH ОШИБКИ
Переменная \fIerrno\fP может принимать следующие значения:
.TP 
\fBEBADF\fP
Неправильный файловый дескриптор.
.TP 
\fBENOTTY\fP
Файловый дескриптор не связан со специальным символьным устройством, или
указанный запрос к нему неприменим.
.TP 
\fBEINVAL\fP
Неправильный файловый дескриптор или \fIargp\fP.
.TP 
\fBEPERM\fP
Недостаточно прав.
.SH ЗАМЕЧАНИЯ
\fBПредупреждение\fP: не рассматривайте эту справочную страницу как
документацию о ioctl консоли Linux. Она предназначена только для
любознательных, как альтернатива исходному коду. Ioctl \(em это внутренние
недокументированные возможности Linux, которые могут изменяться без
предупреждения. (И на самом деле, эта страница более или менее полно
описывает параметры ядра версии 1.1.94; они несколько отличаются от
параметров ядра более ранних версий.)

Очень часто ioctl вводятся для обмена между ядром и какой\-то определённой
известной программой (fdisk, hdparm, setserial, tunelp, loadkeys, selection,
setfont и т.д.), и их поведение изменяется по требованию этой программы.

Программы, использующие такие ioctl, не могут быть перенесены в другие
версии UNIX, не будут работать в старых версиях Linux и могут не работать в
будущих версия Linux.

Используйте функции POSIX.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBdumpkeys\fP(1), \fBkbd_mode\fP(1), \fBloadkeys\fP(1), \fBmknod\fP(1), \fBsetleds\fP(1),
\fBsetmetamode\fP(1), \fBexecve\fP(2), \fBfcntl\fP(2), \fBioperm\fP(2), \fBtermios\fP(3),
\fBconsole\fP(4), \fBconsole_codes\fP(4), \fBmt\fP(4), \fBsd\fP(4), \fBtty\fP(4),
\fBtty_ioctl\fP(4), \fBttyS\fP(4), \fBvcs\fP(4), \fBvcsa\fP(4), \fBcharsets\fP(7),
\fBmapscrn\fP(8), \fBresizecons\fP(8), \fBsetfont\fP(8), \fI/usr/include/linux/kd.h\fP,
\fI/usr/include/linux/vt.h\fP

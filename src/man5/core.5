.\" Copyright (c) 2006, 2008 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH CORE 5 2012\-01\-17 Linux "Руководство программиста Linux"
.SH ИМЯ
core \- файла дампа памяти процесса
.SH ОПИСАНИЕ
Для определённых сигналов действием по умолчанию является завершение
процесса и создание \fIдампа памяти процесса\fP \(em дискового файла,
содержащего образ памяти процесса на момент завершения. Этот образ может
быть использован в отладчике (например, \fBgdb\fP(1)) для исследования
состояния программы на момент её завершения. Список сигналов, которые
приводят к созданию дампа памяти процесса, можно найти в \fBsignal\fP(7).

Процесс может установить свой программный предел ресурса \fBRLIMIT_CORE\fP в
максимальное значение по размеру файла дампа, который будет создан, если
процесс получит сигнал "дампа памяти"; подробней смотрите в \fBgetrlimit\fP(2).

Есть несколько обстоятельств, при которых файл дампа памяти не создаётся:
.IP * 3
У процесса нет прав на запись файла дампа. (По умолчанию файл дампа
называется \fIcore\fP и создаётся в текущем рабочем каталоге. Подробней об
именовании смотрите далее.) Запись файла дампа завершится неудачно, если
каталог, в котором он создаётся, недоступен для записи, или если файл с
таким же именем уже существует и недоступен для записи или это необычный
файл (например, это каталог или символьная ссылка).
.IP *
Существует файл (обычный, доступный на запись) с именем, которое будет
использовано для дампа памяти, но есть более одной жёсткой ссылки на этот
файл.
.IP *
Файловая система, где должен быть создан файл дампа, переполнена,
закончились иноды, она смонтирована только для чтения, достигнут предел
пользовательской квоты.
.IP *
Каталог, в котором должен быть создан файл дампа, не существует.
.IP *
Пределы ресурсов \fBRLIMIT_CORE\fP (размер файла дампа) или \fBRLIMIT_FSIZE\fP
(размер файла) для процесса установлены в ноль; смотрите \fBgetrlimit\fP(2) и
документацию на команду оболочки \fIulimit\fP (\fIlimit\fP в \fBcsh\fP(1)).
.IP *
Исполняемый процессом файл недоступен на чтение.
.IP *
.\" FIXME . Perhaps relocate discussion of /proc/sys/fs/suid_dumpable
.\" and PR_SET_DUMPABLE to this page?
Процесс выполняет программу с установленными битом set\-user\-ID
(set\-group\-ID), который принадлежит пользователю (группе) не совпадающей с
ID реального пользователя (группы) процесса. (Однако посмотрите описание
операции \fBprctl\fP(2) \fBPR_SET_DUMPABLE\fP, и описание файла
\fI/proc/sys/fs/suid_dumpable\fP в \fBproc\fP(5).)
.SS "Именование файлов дампов памяти"
По умолчанию, файлу с дампом памяти присваивается имя \fIcore\fP, но с помощью
файла \fI/proc/sys/kernel/core_pattern\fP (начиная с Linux 2.6 и 2.4.21) можно
задать шаблон, который будет использован для именования файлов дампов
памяти. Шаблон может содержать описатели %, которые заменяются на следующие
значения при создании файла дампа:
.PP
.RS 4
.PD 0
.TP  4
%%
одиночный символ %
.TP 
%p
PID процесса, с которого делается дамп
.TP 
%u
(число) реальный UID процесса, с которого делается дамп
.TP 
%g
(число) реальный GID процесса, с которого делается дамп
.TP 
%s
номер сигнала, вызвавшего создание дампа
.TP 
%t
время дампа, выражается в секундах с начала эпохи, 1970\-01\-01 00:00:00 +0000
(UTC)
.TP 
%h
имя узла (как \fInodename\fP, возвращаемое \fBuname\fP(2))
.TP 
%e
имя исполняемого файла (без пути)
.TP 
%E
путь к исполняемому файлу, в котором символы косой черты (\(aq/\(aq)
заменена на восклицательные знаки (\(aq!\(aq).
.TP 
%c
программный предел размера файла дампа рухнувшего процесса (начиная с Linux
2.6.24)
.PD
.RE
.PP
Одиночный % в конце шаблона отбрасывается от имени файла дампа вместе с
символом после %, отличным от перечисленных ранее. Все остальные символы в
шаблоне вставляются в имя файла дампа как есть. Шаблон может содержать
символы \(aq/\(aq, которые интерпретируются как разделители для имён
каталогов. Максимальный размер получаемого имени файла дампа равен 128
байтам (64 байта для ядер до версии 2.6.19). Значение по умолчанию в этом
файле равно "core". Для обратной совместимости, если
\fI/proc/sys/kernel/core_pattern\fP не содержит "%p" и значение в
\fI/proc/sys/kernel/core_uses_pid\fP (см. далее) не равно нулю, то к имени
файла дампа будет добавлен .PID.

Начиная с версии 2.4, Linux также предоставляет более примитивный метод
управления именем файла дампа памяти. Если файл
\fI/proc/sys/kernel/core_uses_pid\fP содержит значение 0, то файл дампа памяти
просто называется \fIcore\fP. Если в этом файле содержится ненулевое значение,
то к имени файла дампа добавится ID процесса (в виде \fIcore.PID\fP).
.SS "Передача дампов памяти в программу через канал"
Начиная с версии 2.6.19, Linux поддерживает альтернативный синтаксис файла
\fI/proc/sys/kernel/core_pattern\fP. Если первым символом в этом файле будет
символ канала (\fB|\fP), то оставшаяся строка воспринимается как программа
которую нужно запустить. Вместо записи файла на диск дамп памяти передаётся
в стандартный ввод программы. Отметим следующие моменты:
.IP * 3
Программа должна быть задана абсолютным именем файла (или путём относительно
корневого каталога, \fI/\fP), и имя должна сразу следовать за символом '|'.
.IP *
Создаваемый процесс для запуска программы будет выполняться с правами группы
и пользователя \fIroot\fP.
.IP *
Программе можно передать аргументы командной строки (начиная с версии
2.6.24), отделяя их пробелами (максимальный размер строки 128 байт).
.IP *
В аргументах командной строки могут быть описатели %, перечисленные
ранее. Например, чтобы передать PID процесса, для которого делается дамп,
укажите в аргументе \fI%p\fP.
.SS "Управление отображениями, записываемыми в дамп памяти"
Начиная с версии 2.6.23, в Linux появился файл \fI/proc/PID/coredump_filter\fP,
который определяет какие сегменты памяти записываются в файл дампа памяти
при отклике на событие создания дампа памяти процесса с соответствующим ID
процесса.

Значение в файле является битовой маской типов отображений памяти
(см. \fBmmap\fP(2)). Если бит в маске установлен, то выполняется дамп
отображения памяти соответствующего типа; иначе дамп не выполняется. Биты в
этом файле имеют следующее значение:
.PP
.PD 0
.RS 4
.TP 
бит 0
Выполнять дамп анонимных частных отображений.
.TP 
бит 1
Выполнять дамп анонимных общих отображений.
.TP 
бит 2
Выполнять дамп частных отображений из виртуальной памяти (file\-backed).
.TP 
бит 3
.\" file-backed shared mappings of course also update the underlying
.\" mapped file.
Выполнять дамп общих отображений из виртуальной памяти (file\-backed).
.TP 
бит 4 (начиная с Linux 2.6.24)
Выполнять дамп заголовков ELF.
.TP 
бит 5 (начиная с Linux 2.6.28)
Выполнять дамп частных огромных страниц.
.TP 
бит 6 (начиная с Linux 2.6.28)
Выполнять дамп общих огромных страниц.
.RE
.PD
.PP
По умолчанию, установлены следующие биты: 0, 1, 4 (если включён параметр
настройки ядра \fBCONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS\fP) и 5. Значения этого
файла отображается в шестнадцатеричной системе счисления. (То есть значение
по умолчанию выглядит как 33.)

Для страниц ввода\-вывода, отображённых в память, таких как фрейм\-буфер, дамп
никогда не выполняется, а виртуальные страницы DSO попадают в дамп всегда,
независимо от значения \fIcoredump_filter\fP.

Дочерний процесс, созданный \fBfork\fP(2), наследует значение
\fIcoredump_filter\fP родителя; значение \fIcoredump_filter\fP сохраняется и при
\fBexecve\fP(2).

Полезно указывать значение \fIcoredump_filter\fP в родительской оболочке до
запуска программы, например:

.in +4n
.nf
$\fB echo 0x7 > /proc/self/coredump_filter\fP
$\fB ./какая\-то_программа\fP
.fi
.in
.PP
Этот файл есть в системе, только если ядро было собрано с параметром
настройки \fBCONFIG_ELF_CORE\fP.
.SH ЗАМЕЧАНИЯ
Команду \fBgdb\fP(1) \fIgcore\fP можно использовать для получения дампа памяти
работающего процесса.

.\" Always including the PID in the name of the core file made
.\" sense for LinuxThreads, where each thread had a unique PID,
.\" but doesn't seem to serve any purpose with NPTL, where all the
.\" threads in a process share the same PID (as POSIX.1 requires).
.\" Probably the behavior is maintained so that applications using
.\" LinuxThreads continue appending the PID (the kernel has no easy
.\" way of telling which threading implementation the userspace
.\" application is using). -- mtk, April 2006
Если для многонитевого процесса (или, точнее, процесса, который делит свою
памяти с другим процессом, созданным с флагом \fBCLONE_VM\fP через \fBclone\fP(2))
выполняется дамп памяти, то ID процесса всегда добавляется к имени файла
дампа, если ID процесса уже не включён в это имя с помощью %p в
\fI/proc/sys/kernel/core_pattern\fP. (Это, главным образом, полезно когда
применяется реализация LinuxThreads, где каждая нить процесса имеет свой
PID.)
.SH ПРИМЕР
Эта программа может использоваться для демонстрации синтаксиса канала в
файле \fI/proc/sys/kernel/core_pattern\fP. Следующий сеанс оболочки
демонстрирует использование данной программы (при компиляции был создан
исполняемый файл с именем \fIcore_pattern_pipe_test\fP):
.PP
.in +4n
.nf
$\fB cc \-o core_pattern_pipe_test core_pattern_pipe_test.c\fP
$\fB su\fP
Password:
#\fB echo "|$PWD/core_pattern_pipe_test %p UID=%u GID=%g sig=%s" > \e\fP
\fB/proc/sys/kernel/core_pattern\fP
#\fB exit\fP
$\fB sleep 100\fP
\fB^\e\fP                     # type control\-backslash
Quit (core dumped)
$\fB cat core.info\fP
argc=5
argc[0]=</home/mtk/core_pattern_pipe_test>
argc[1]=<20575>
argc[2]=<UID=1000>
argc[3]=<GID=100>
argc[4]=<sig=3>
Total bytes in core dump: 282624
.fi
.in
.SS "Исходный код программы"
\&
.nf
/* core_pattern_pipe_test.c */

#define _GNU_SOURCE
#include <sys/stat.h>
#include <fcntl.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define BUF_SIZE 1024

int
main(int argc, char *argv[])
{
    int tot, j;
    ssize_t nread;
    char buf[BUF_SIZE];
    FILE *fp;
    char cwd[PATH_MAX];

    /* Изменяем наш текущий рабочий каталог на тот, что у
       упавшего процесса */

    snprintf(cwd, PATH_MAX, "/proc/%s/cwd", argv[1]);
    chdir(cwd);

    /* Записываем вывод в файл "core.info" в этом каталоге */

    fp = fopen("core.info", "w+");
    if (fp == NULL)
        exit(EXIT_FAILURE);

    /* Показываем аргументы командной строки, переданные программе
       core_pattern */

    fprintf(fp, "argc=%d\en", argc);
    for (j = 0; j < argc; j++)
        fprintf(fp, "argc[%d]=<%s>\en", j, argv[j]);

    /* Подсчитываем байты стандартного ввода (дампа памяти) */

    tot = 0;
    while ((nread = read(STDIN_FILENO, buf, BUF_SIZE)) > 0)
        tot += nread;
    fprintf(fp, "Total bytes in core dump: %d\en", tot);

    exit(EXIT_SUCCESS);
}
.fi
.SH "СМОТРИТЕ ТАКЖЕ"
\fBbash\fP(1), \fBgdb\fP(1), \fBgetrlimit\fP(2), \fBmmap\fP(2), \fBprctl\fP(2),
\fBsigaction\fP(2), \fBelf\fP(5), \fBproc\fP(5), \fBpthreads\fP(7), \fBsignal\fP(7)

.\" t
.\" Don't change the line above. it tells man that tbl is needed.
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: ip.7,v 1.19 2000/12/20 18:10:31 ak Exp $
.\"
.\" FIXME: Document IP_MINTTL, added in Linux 2.6.34
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH IP 7 2011\-09\-22 Linux "Руководство программиста Linux"
.SH ИМЯ
ip \- реализация протокола IPv4 в Linux
.SH ОБЗОР
\fB#include <sys/socket.h>\fP
.br
.\" .B #include <net/netinet.h> -- does not exist anymore
.\" .B #include <linux/errqueue.h> -- never include <linux/foo.h>
\fB#include <netinet/in.h>\fP
.br
\fB#include <netinet/ip.h> \fP/* включает предыдущий */
.sp
\fItcp_socket\fP\fB = socket(AF_INET, SOCK_STREAM, 0);\fP
.br
\fIudp_socket\fP\fB = socket(AF_INET, SOCK_DGRAM, 0);\fP
.br
\fIraw_socket\fP\fB = socket(AF_INET, SOCK_RAW, \fP\fIprotocol\fP\fB);\fP
.SH ОПИСАНИЕ
.\" FIXME has someone verified that 2.1 is really 1812 compliant?
В Linux реализован Internet Protocol (IP) версии 4, описанный в RFC\ 791 и
RFC\ 1122. В модуле \fBip\fP содержится реализация второго уровня групповых
сообщений, которая соответствует RFC\ 1112. Кроме того, в нём имеется
маршрутизатор IP с фильтрацией пакетов.
.PP
Программный интерфейс совместим с интерфейсом сокетов BSD. Более подробную
информацию смотрите в \fBsocket\fP(7).
.PP
IP\-сокет создаётся с помощью вызова \fBsocket\fP(2) вида \fBsocket(AF_INET,
\fP\fIsocket_type\fP\fB, \fP\fIprotocol\fP\fB)\fP. Значением типа сокета (\fIsocket_type\fP)
может быть: \fBSOCK_STREAM\fP (для открытия сокета \fBtcp\fP(7)), \fBSOCK_DGRAM\fP
(для открытия сокета \fBudp\fP(7)), \fBSOCK_RAW\fP (для открытия сокета \fBraw\fP(7)
с прямым доступом к протоколу IP). В \fIprotocol\fP указывается значение
протокола IP в IP\-заголовке для принимаемых или отправляемых
пакетов. Допустимые значения для параметра \fIprotocol\fP: 0 и \fBIPPROTO_TCP\fP —
для сокетов TCP, 0 и \fBIPPROTO_UDP\fP — для сокетов UDP. Для \fBSOCK_RAW\fP можно
указать любой из IP\-протоколов, описанных в RFC\ 1700 и зарегистрированных в
IANA.
.PP
.\" FIXME ip current does an autobind in listen, but I'm not sure
.\" if that should be documented.
Если процесс хочет принимать новые входящие пакеты или соединения, то он
должен связать сокет с адресом локального интерфейса с помощью
\fBbind\fP(2). Каждый IP\-сокет может быть связан только с одной задаваемой
локальной парой (адрес, порт). Если в вызове \fBbind\fP(2) указать
\fBINADDR_ANY\fP, то сокет будет связан со \fIвсеми\fP локальными
интерфейсами. При вызове \fBlisten\fP(2) или \fBconnect\fP(2) для несвязанного
сокета происходит автоматическая привязка к произвольно выбранному
свободному порту и локальному адресу \fBINADDR_ANY\fP.

После закрытия связанного локального TCP\-сокета его адрес будет недоступен в
течение некоторого времени, если только не был установлен флаг
\fBSO_REUSEADDR\fP. Следует проявлять осторожность при использовании этого
флага, поскольку это делает TCP менее надежным.
.SS "Формат адреса"
Адрес IP\-сокета определяется как комбинация IP\-адреса интерфейса и номера
порта. В самом протоколе IP нет номеров портов, они реализуются протоколами
более высокого уровня, например \fBudp\fP(7) и \fBtcp\fP(7). У «сырых» (raw)
сокетов номер протокола IP указывается в \fIsin_port\fP.
.PP
.in +4n
.nf
struct sockaddr_in {
    sa_family_t    sin_family; /* семейство адресов: AF_INET */
    in_port_t      sin_port;   /* порт сокета в сетевом порядке
                                  байт */
    struct in_addr sin_addr;   /* Интернет\-адрес */
};

/* Интернет\-адрес */
struct in_addr {
    uint32_t       s_addr;     /* адрес в сетевом порядке байт */
};
.fi
.in
.PP
Значение \fIsin_family\fP всегда устанавливается в \fBAF_INET\fP. Это обязательно;
в Linux 2.2 большая часть сетевых функций возвращает код ошибки \fBEINVAL\fP,
если это условие не выполняется. В \fIsin_port\fP указывается номер порта в
сетевом порядке байт. Порты, номера которых меньше 1024, называются
\fIпривилегированными портами\fP (или, иногда, \fIзарезервированными
портами\fP). Только привилегированные процессы (т.е., имеющие мандат
\fBCAP_NET_BIND_SERVICE\fP) могут быть связаны с этими сокетами с помощью
\fBbind\fP(2). Заметим, что у «сырого» протокола IPv4, как такового, нет
понятия порта, они реализуются только протоколами более высокого уровня,
типа \fBtcp\fP(7) и \fBudp\fP(7).
.PP
В \fIsin_addr\fP указывается IP\-адрес узла. В поле \fIs_addr\fP структуры \fIstruct
in_addr\fP содержится адрес интерфейса узла в сетевом порядке байт. Значение
\fIin_addr\fP должно быть одним из \fBINADDR_*\fP (например, \fBINADDR_ANY\fP) или
устанавливаться с помощью библиотечных функций \fBinet_aton\fP(3),
\fBinet_addr\fP(3), \fBinet_makeaddr\fP(3) или напрямую с помощью преобразователя
имён (смотрите \fBgethostbyname\fP(3)).

.\" Leave a loophole for XTP @)
Адреса IPv4 делятся на однозначные (unicast), широковещательные (broadcast)
и групповые (multicast). Однозначный адрес указывает на один интерфейс узла,
широковещательный адрес указывает на  все узлы в сети, а групповой адрес
указывает на все узлы определённой группы (multicast group). Дейтаграммы
могут посылаться или приниматься по широковещательным адресам только, если
для сокета установлен флаг \fBSO_BROADCAST\fP. В текущей реализации сокетам,
ориентированным на соединения, разрешено иметь только однозначные адреса.

Заметим, что значения адреса и порта всегда хранятся в сетевом порядке
байт. В частности, это означает, что требуется вызывать \fBhtons\fP(3) для
числа, обозначающего порт. Все функции из стандартной библиотеки,
используемые для работы с адресами/портами, используют сетевой порядок байт.

Есть несколько специальных адресов: \fBINADDR_LOOPBACK\fP (127.0.0.1) всегда
ссылается на локальный узел через интерфейс обратной петли; \fBINADDR_ANY\fP
(0.0.0.0) означает любой адрес для связывания; \fBINADDR_BROADCAST\fP
(255.255.255.255) означает любой узел и, по историческим причинам, при
связывании подобен \fBINADDR_ANY\fP.
.SS "Параметры сокета"
.\" or SOL_IP on Linux
IP поддерживает некоторые параметры сокета, относящиеся к протоколу, которые
могут быть установлены с помощью \fBsetsockopt\fP(2) и прочитаны с помощью
\fBgetsockopt\fP(2). Значением уровня (level) параметров сокета для IP является
\fBIPPROTO_IP\fP. Логический флаг в виде целого числа со значением ноль
означает «ложь», другие значения — «истина».
.TP 
\fBIP_ADD_MEMBERSHIP\fP (начиная с Linux 1.2)
Присоединиться к группе. В аргументе указывается структура \fIip_mreqn\fP.
.sp
.in +4n
.nf
struct ip_mreqn {
    struct in_addr imr_multiaddr; /* IP\-адрес группы */
    struct in_addr imr_address;   /* IP\- локального
                                     интерфейса */
    int            imr_ifindex;   /* индекс интерфейса */
};
.fi
.in
.sp
.\" (i.e., within the 224.0.0.0-239.255.255.255 range)
В \fIimr_multiaddr\fP содержится адрес группы, в которую приложение хочет войти
или выйти. Это должен быть правильный групповой адрес (иначе
\fBsetsockopt\fP(2) завершится с ошибкой \fBEINVAL\fP). В \fIimr_address\fP
указывается адрес локального интерфейса, через который система должна войти
в группу; если указано значение \fBINADDR_ANY\fP, то нужный интерфейса
выбирается системой самостоятельно. В \fIimr_ifindex\fP указывается индекс
интерфейса, через который нужно войти/выйти в группу \fIimr_multiaddr\fP, или
0, если интерфейс может быть любым.
.IP
.\"
Структура \fIip_mreqn\fP появилась только с Linux 2.2. Для совместимости,
старая структура \fIip_mreq\fP (существует с Linux 1.2) всё ещё поддерживается;
она отличается от \fIip_mreqn\fP только отсутствующим полем
\fIimr_ifindex\fP. Может использоваться только в \fBsetsockopt\fP(2).
.TP 
\fBIP_DROP_MEMBERSHIP\fP (начиная с Linux 1.2)
Выйти из группы. Аргументом является структура \fIip_mreqn\fP или \fIip_mreq\fP,
описана в \fBIP_ADD_MEMBERSHIP\fP.
.TP 
\fBIP_FREEBIND\fP (начиная с Linux 2.4)
.\" Precisely: 2.4.0-test10
Этот логический параметр позволяет привязаться (если значение равно
«истина») к IP\-адресу, который не является локальным или (пока) не
существует. Это позволяет прослушивать сокет, не имея нижележащего сетевого
интерфейса или назначенного динамического IP\-адреса, которых может ещё не
быть, когда приложение пытается связаться с ним. На каждый сокет этот
параметр имеет эквивалентный интерфейс в \fI/proc\fP — \fIip_nonlocal_bind\fP
(описан далее).
.TP 
\fBIP_HDRINCL\fP (начиная с Linux 2.0)
.\"
.\" FIXME Document IP_IPSEC_POLICY
.\" Since Linux 2.5.47
.\" Needs CAP_NET_ADMIN
Если значение равно «истина», то это означает, что пользователь добавил
заголовок IP в начало своих данных. Допустим только для сокетов
\fBSOCK_RAW\fP.  Более подробную информацию смотрите в \fBraw\fP(7). Если этот
флаг установлен, то значения, заданные параметрами \fBIP_OPTIONS\fP, \fBIP_TTL\fP
и \fBIP_TOS\fP, игнорируются.
.TP 
\fBIP_MTU\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.124
Возвращает известное в данный момент значение MTU маршрута текущего
сокета. Допустим, только если сокет установил соединение. Возвращает целое
число. Применяется только в \fBgetsockopt\fP(2).
.TP 
\fBIP_MTU_DISCOVER\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.124
Устанавливает или возвращает значение Path MTU Discovery (обнаружение
значения MTU маршрута) для сокета. Если он установлен, то Linux будет
производить обнаружение значения MTU маршрута для сокетов \fBSOCK_STREAM\fP
согласно RFC\ 1191. Для сокетов не \fBSOCK_STREAM\fP при значении
\fBIP_PMTUDISC_DO\fP у всех исходящих пакетов будет устанавливаться флаг
запрета фрагментации. Ответственность за разбивку данных на пакеты согласно
размеру MTU, и за выполнение, по\-необходимости, повторной передачи данных,
лежит на пользователе. Ядро будет отвергать пакеты (с ошибкой \fBEMSGSIZE\fP),
размер которых больше текущего значения MTU у маршрута. При значении
\fBIP_PMTUDISC_WANT\fP дейтаграмма будет фрагментироваться по размеру MTU, если
требуется, иначе устанавливается флаг запрета фрагментации.

Системное значение по умолчанию можно переключать между \fBIP_PMTUDISC_WANT\fP
и \fBIP_PMTUDISC_DONT\fP, записывая, соответственно, нулевое и ненулевое
значение в файл \fI/proc/sys/net/ipv4/ip_no_pmtu_disc\fP.

.TS
tab(:);
c l
l l.
Флаг Path MTU discovery:Назначение
IP_PMTUDISC_WANT:Использовать для каждого маршрута своё
:значение.
IP_PMTUDISC_DONT:Никогда не выполнять обнаружение
:значения MTU маршрута.
IP_PMTUDISC_DO:Всегда выполнять обнаружение
:значения MTU маршрута.
IP_PMTUDISC_PROBE:Установить DF, но игнорировать Path MTU.
.TE

Если значение Path MTU Discovery задано, то ядро автоматически следит за MTU
маршрута для каждого удалённого узла. Когда с некоторым узлом установлено
соединение с помощью \fBconnect\fP(2), текущее значение MTU маршрута можно
легко получить через параметр сокета \fBIP_MTU\fP (например, после
возникновения ошибки \fBEMSGSIZE\fP). Значение MTU может со временем
меняться. Для сокетов без установления соединения, которые имеют несколько
узлов\-получателей, новое значение MTU для заданного узла назначения может
быть получено с помощью очереди ошибок (смотрите \fBIP_RECVERR\fP). При каждом
входящем сообщении об обновлении MTU в очередь будет добавляться новая
ошибка.

Во время процесса обнаружения MTU начальные пакеты от дейтаграмных сокетов
могут быть отброшены. Приложения, использующие UDP, должны учитывать это и
не думать, что эти пакеты будут переданы повторно.

.\" FIXME this is an ugly hack
Чтобы запустить процесс обнаружения MTU маршрута для сокетов без
установления соединения можно сначала установить большой размер дейтаграммы
(с размером заголовка до 64Кбайт) и сокращать его при изменении MTU
маршрута.

Чтобы получить начальную оценку MTU маршрута, соедините дейтаграмный сокет с
адресом назначения, используя \fBconnect\fP(2), и узнайте значение MTU путем
вызова \fBgetsockopt\fP(2) с параметром \fBIP_MTU\fP.

Возможно реализовать исследование MTU согласно RFC 4821 с помощью сокетов
типа \fBSOCK_DGRAM\fP или \fBSOCK_RAW\fP, установив значение \fBIP_PMTUDISC_PROBE\fP
(доступно, начиная с Linux 2.6.22). В частности, это также полезно для
инструментов диагностики, таких как \fBtracepath\fP(8), которым нужно умышленно
посылать проверочные пакеты большего размера чем исследуемый Path MTU.
.TP 
\fBIP_MULTICAST_IF\fP (начиная с Linux 1.2)
Назначает локальное устройство для группового сокета (multicast
socket). Аргументом является структура \fIip_mreqn\fP или \fIip_mreq\fP, описана в
\fBIP_ADD_MEMBERSHIP\fP.
.IP
Если сокету передается неправильный параметр, то возвращается ошибка
\fBENOPROTOOPT\fP.
.TP 
\fBIP_MULTICAST_LOOP\fP (начиная с Linux 1.2)
Устанавливает или возвращает логический флаг в виде целого числа, в
зависимости от того, будут ли пакеты, использующие групповую адресацию,
закольцовываться на локальные сокеты.
.TP 
\fBIP_MULTICAST_TTL\fP (начиная с Linux 1.2)
Устанавливает или возвращает значение времени существования (time\-to\-live)
для исходящих из этого сокета пакетов, использующих групповую адресацию. Для
подобных пакетов очень важно установить наименьшее возможное значение
TTL. По умолчанию оно равно 1, это значит, что групповые пакеты не выйдут за
пределы локальной сети, если только пользовательская программа явно не
попросит этого. Значением аргумента является целое число.
.TP 
\fBIP_NODEFRAG\fP (начиная с Linux 2.6.36)
Если уставлен (аргумент не равен нулю), то уровне netfilter запрещается
выполнять переборку (reassembly) исходящих пакетов. Этот параметр
допускается только для сокетов с типом \fBSOCK_RAW\fP. sockets. Значением
аргумента является целое число.
.TP 
\fBIP_OPTIONS\fP (начиная с Linux 2.0)
.\" Precisely: 1.3.30
.\" FIXME Document IP_PASSSEC
.\" Boolean
.\" Since Linux 2.6.17
.\" commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
.\" Author: Catherine Zhang <cxzhang@watson.ibm.com>
Устанавливает или возвращает параметры IP, которые посылаются с каждым
пакетом из данного сокета. Аргументами являются указатель на буфер памяти с
этими параметрами и размер параметра. Системный вызов \fBsetsockopt\fP(2)
устанавливает параметры IP, связанные с сокетом. Для IPv4 максимальный
размер параметра IPv4 равен 40 байтам. Все возможные параметры перечислены в
RFC\ 791. Если пакет, устанавливающий соединение с сокетом типа
\fBSOCK_STREAM\fP, содержит параметры IP, то эти параметры IP (с
инвертированными заголовками маршрутизации) будут использоваться в этом
сокете. После установления соединения изменять параметрывходящими пакетами
запрещено. По умолчанию, обработка всех параметров, связанных с
маршрутизацией от источника, отключена, но её можно включить через интерфейс
\fIaccept_source_route\fP \fI/proc\fP. Другие параметры, например связанные с
временными отметками (timestamp), продолжают обрабатываться. Для
дейтаграмных сокетов параметры IP могут быть установлены только локальным
пользователем. Вызов \fBgetsockopt\fP(2) с параметром \fBIP_OPTIONS\fP помещает в
указанный буфер текущие параметры IP, используемые при отправке.
.TP 
\fBIP_PKTINFO\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Передает вспомогательное (ancillary) сообщение \fBIP_PKTINFO\fP с структурой
\fIpktinfo\fP, которая содержит некоторую информацию о входящем
пакете. Допускается только для сокетов, ориентированных на посылку
дейтаграмм. Аргументом является флаг, который сообщает сокету, нужно ли
посылать сообщение \fBIP_PKTINFO\fP или нет. Само сообщение может быть
послано/получено только в виде управляющего сообщения с пакетом, используя
\fBrecvmsg\fP(2) или \fBsendmsg\fP(2).
.IP
.in +4n
.nf
struct in_pktinfo {
    unsigned int   ipi_ifindex;  /* индекс интерфейса */
    struct in_addr ipi_spec_dst; /* локальный адрес */
    struct in_addr ipi_addr;     /* заголовок адреса
                                    назначения */
};
.fi
.in
.IP
.\" FIXME elaborate on that.
.\" This field is grossly misnamed
\fIipi_ifindex\fP это уникальный индекс интерфейса, из которого был получен
этот пакет. \fIipi_spec_dst\fP это локальный адрес пакета, а \fIipi_addr\fP это
адрес назначения, указанный в заголовке пакета. Если параметр \fBIP_PKTINFO\fP
передаётся в \fBsendmsg\fP(2) и \fIipi_spec_dst\fP не равно нулю, то
\fIipi_spec_dst\fP будет использован как локальный адрес источника при
просмотре таблицы маршрутизации и для установки IP\-параметров маршрутизации
от источника. Если значение \fIipi_ifindex\fP не равно нулю, то при поиске в
таблице маршрутизации вместо значения \fIipi_spec_dst\fP используется первичный
локальный адрес интерфейса с указанным индексом.
.TP 
\fBIP_RECVERR\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.15
.\" or SOL_IP on Linux
Делает передачу сообщений об ошибках более надёжной. Если этот параметр
установлен для дейтаграмного сокета, то все возникающие ошибки будут
поставлены в очередь ошибок, свою для каждого сокета. Для получения ошибки
при операции с сокетом пользователь может воспользоваться вызовом
\fBrecvmsg\fP(2) с установленным флагом \fBMSG_ERRQUEUE\fP. Структура
\fIsock_extended_err\fP, описывающая ошибку, будет передана в вспомогательном
сообщении с типом \fBIP_RECVERR\fP и уровнем \fBIPPROTO_IP\fP. Этот параметр
полезен для надежной обработки ошибок для сокетов без установления
соединения. В пакете с ошибкой из очереди ошибок, также содержится порция
полученных данных.
.IP
Управляющее сообщение типа \fBIP_RECVERR\fP содержит структуру
\fIsock_extended_err\fP:
.IP
.in +4n
.ne 18
.nf
#define SO_EE_ORIGIN_NONE    0
#define SO_EE_ORIGIN_LOCAL   1
#define SO_EE_ORIGIN_ICMP    2
#define SO_EE_ORIGIN_ICMP6   3

struct sock_extended_err {
    uint32_t ee_errno;   /* номер ошибки */
    uint8_t  ee_origin;  /* где возникла ошибка */
    uint8_t  ee_type;    /* тип */
    uint8_t  ee_code;    /* код */
    uint8_t  ee_pad;
    uint32_t ee_info;    /* дополнительная информация */
    uint32_t ee_data;    /* другие данные */
    /* Дальше могут следовать данные */
};

struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);
.fi
.in
.IP
В \fIee_errno\fP содержится номер ошибки в очереди. В \fIee_origin\fP содержится
код источника ошибки. Значение остальных полей зависит от протокола. Макрос
\fBSO_EE_OFFENDER\fP возвращает указатель на адрес сетевого объекта, в котором
возникла ошибка, согласно указанному указателю на вспомогательное
сообщение. Если адрес неизвестен, то поле \fIsa_family\fP структуры \fIsockaddr\fP
содержит \fBAF_UNSPEC\fP, и остальные поля \fIsockaddr\fP не определены.
.IP
.\" FIXME . Is it a good idea to document that? It is a dubious feature.
.\" On
.\" .B SOCK_STREAM
.\" sockets,
.\" .B IP_RECVERR
.\" has slightly different semantics. Instead of
.\" saving the errors for the next timeout, it passes all incoming
.\" errors immediately to the user.
.\" This might be useful for very short-lived TCP connections which
.\" need fast error handling. Use this option with care:
.\" it makes TCP unreliable
.\" by not allowing it to recover properly from routing
.\" shifts and other normal
.\" conditions and breaks the protocol specification.
Для IP  структура \fIsock_extended_err\fP используется следующим образом:
значение поля \fIee_origin\fP устанавливается в \fBSO_EE_ORIGIN_ICMP\fP, если
ошибка получена из пакета ICMP, или в \fBSO_EE_ORIGIN_LOCAL\fP, если возникла
локальная ошибка. Неизвестные значения следует игнорировать. Значения полей
\fIee_type\fP и \fIee_code\fP устанавливаются исходя из значений полей типа и кода
заголовка ICMP. При ошибках \fBEMSGSIZE\fP поле \fIee_info\fP содержит
обнаруженную величину MTU. Сообщение также содержит структуру \fIsockaddr_in
для узла\fP, вызвавшего ошибку, к которой доступна через макрос
\fBSO_EE_OFFENDER\fP. Если источник неизвестен, то поле \fIsin_family\fP адреса,
возвращённого макросом \fBSO_EE_OFFENDER\fP, содержит значение
\fBAF_UNSPEC\fP. Если ошибка  возникла в сети, то все параметры IP
(\fBIP_OPTIONS\fP, \fBIP_TTL\fP и т.д.), которые используются сокетом и содержатся
в пакете с описанием ошибки, передаются в управляющих сообщениях. Данные
пакета, вызвавшего ошибку, возвращаются как нормальные данные. Заметьте, что
у TCP нет очереди ошибок; флаг \fBMSG_ERRQUEUE\fP нельзя использовать для
сокетов типа \fBSOCK_STREAM\fP. Параметр \fBIP_RECVERR\fP допустим для TCP, но все
ошибки возвращаются только через функцию сокета или через параметр
\fBSO_ERROR\fP.
.IP
Для «сырых» сокетов, параметр \fBIP_RECVERR\fP включает передачу в приложение
всех получаемых ошибок ICMP, иначе сообщается только об ошибках в сокетах
ориентированных на соединение.
.IP
Этот параметр устанавливается или возвращается как логический флаг в виде
целого числа. По умолчанию, параметр \fBIP_RECVERR\fP выключен.
.TP 
\fBIP_RECVOPTS\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.15
Передает пользователю все входящие параметры IP с помощью управляющего
сообщения \fBIP_OPTIONS\fP. Для локального узла заполняется заголовок
маршрутизации и другие параметры. Не поддерживается сокетами типа
\fBSOCK_STREAM\fP.
.TP 
\fBIP_RECVORIGDSTADDR\fP (начиная с Linux 2.6.29)
.\" commit e8b2dfe9b4501ed0047459b2756ba26e5a940a69
Данный логический параметр включает вспомогательное сообщение
\fBIP_ORIGDSTADDR\fP в \fBrecvmsg\fP(2), в котором ядро возвращает первоначальный
адрес назначения полученной дейтаграммы. Вспомогательное сообщение содержит
структуру \fIstruct sockaddr_in\fP.
.TP 
\fBIP_RECVTOS\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Если включён, то вместе с входящими пакетами передаётся вспомогательное
сообщение \fBIP_TOS\fP. В нём содержится байт, в котором указано поле типа
сервиса/приоритета из заголовка пакета. Ожидается логическое значение в виде
целого числа.
.TP 
\fBIP_RECVTTL\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Если этот флаг установлен, то передаётся управляющее сообщение \fBIP_TTL\fP с
байтом значения поля времени существования из полученного пакета. Не
поддерживается сокетами типа \fBSOCK_STREAM\fP.
.TP 
\fBIP_RETOPTS\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.15
Идентичен параметру \fBIP_RECVOPTS\fP, но возвращает необработанные параметры,
при чём без заполненных временных меток и записи о маршрутизации до этой
точки (hop).
.TP 
\fBIP_ROUTER_ALERT\fP (начиная с Linux 2.2)
.\" Precisely: 2.1.68
Передаёт этому сокету все пересылаемые (forwarded) пакеты с установленным
параметром IP Router Alert. Этот параметр используется для «сырых»
сокетов. Он может быть полезен, например, для служб RSVP, запущенных в
пространстве пользователя. Перехваченные пакеты дальше ядром не
пересылаются: ответственность за их отсылку лежит на
пользователе. Связывание сокета игнорируется, так как пакеты фильтруются по
протоколу. Ожидается логическое значение в виде целого числа.
.TP 
\fBIP_TOS\fP (начиная с Linux 1.0)
.\" FIXME elaborate on this
.\" Needs CAP_NET_ADMIN
.\" Boolean
.\" Since Linux 2.6.27
.\" Author: KOVACS Krisztian <hidden@sch.bme.hu>
.\" http://lwn.net/Articles/252545/
Устанавливает или получает значение поля Type\-Of\-Service (TOS, тип сервиса)
каждого IP\-пакета, который отсылается с этого сокета. Это поле используется
для указания приоритета пакета в сети. Значение TOS хранится в одном
байте. Существует несколько стандартных флагов TOS: \fBIPTOS_LOWDELAY\fP — для
минимизации задержки передаваемого трафика, \fBIPTOS_THROUGHPUT\fP — для
оптимизации пропускной способности, \fBIPTOS_RELIABILITY\fP — для увеличения
надёжности, \fBIPTOS_MINCOST\fP — для пересылки данных, которым неважна
скорость передачи. Может быть указано не более одного из этих значений
TOS. Все другие биты являются недействительными и должны быть обнулены. По
умолчанию, Linux посылает дейтаграммы с \fBIPTOS_LOWDELAY\fP первыми, но точное
поведение зависит от настроенного порядка очередности (queueing
discipline). Для установки некоторых высокоприоритетных типов сервиса могут
потребоваться права суперпользователя (мандат \fBCAP_NET_ADMIN\fP). Приоритет
также можно указать не зависящим от типа протокола способом через параметр
сокета (\fBSOL_SOCKET\fP, \fBSO_PRIORITY\fP, см. socket(7)).
.TP 
\fBIP_TRANSPARENT\fP (начиная с Linux 2.6.24)
.\" commit f5715aea4564f233767ea1d944b2637a5fd7cd2e
.\"     This patch introduces the IP_TRANSPARENT socket option: enabling that
.\"     will make the IPv4 routing omit the non-local source address check on
.\"     output. Setting IP_TRANSPARENT requires NET_ADMIN capability.
.\" http://lwn.net/Articles/252545/
Установка этого логического параметра включает прозрачное проксирование на
заданный сокет. Данный параметр сокета позволяет вызвавшему приложению
привязаться к нелокальному IP\-адресу и работать клиентом и сервером с
внешним адресом как с локальной конечной точкой. ЗАМЕЧАНИЕ: требуется
настройка маршрутизации пакетов для внешнего адреса через TProxy. Для
установки данного параметра сокета требуются права суперпользователя (мандат
\fBCAP_NET_ADMIN\fP).
.IP
Также, для установки данного параметра на перенаправляемый сокет требуется
перенаправление TProxy с помощью цели TPROXY в iptables.
.TP 
\fBIP_TTL\fP (начиная с Linux 1.0)
.\" FIXME Document IP_XFRM_POLICY
.\" Since Linux 2.5.48
.\" Needs CAP_NET_ADMIN
Устанавливает или получает текущее значение поля времени существования (time
to live), которое указывается в каждом пакете, который отсылается с этого
сокета.
.SS "Интерфейсы в /proc"
.\" FIXME As at 2.6.12, 14 Jun 2005, the following are undocumented:
.\"	ip_queue_maxlen
.\"	ip_conntrack_max
.\"
Настройку глобальных параметров протокола IP можно осуществлять через
интерфейс \fI/proc\fP. Все параметры доступны посредством чтения или записи
файлов из каталога \fI/proc/sys/net/ipv4/\fP. Для логических (\fIBoolean\fP)
параметров значения указываются в виде целых чисел: ненулевое значение
(«истина») означает включает параметра, а нулевое значение («ложь») —
выключение.
.TP 
\fIip_always_defrag\fP (Boolean; начиная с Linux 2.2.13)
[Появилось в ядре версии 2.2.13; в ранних версиях это свойство
контролировалось с помощью флага \fBCONFIG_IP_ALWAYS_DEFRAG\fP во время
компиляции; данный параметр убран в 2.4.x]

Если этот флаг включен (не равен 0), то входящие фрагменты (части
IP\-пакетов, которые образуются, если некоторый узел, находящийся между
отправителем и получателем, решает, что пакеты слишком велики и разделяет их
на кусочки) будут снова собраны (дефрагментированы) перед дальнейшей
обработкой, даже если они должны быть пересланы дальше.

Включайте этот параметр только на межсетевом экране, который является
единственной связью с вашей сетью, или на прозрачном прокси; никогда не
включайте его на обычном маршрутизаторе или узле. В противном случае,
соединение может быть нарушено, если фрагменты передаются по различным
линиям. Дефрагментация также требует много памяти и процессорного времени.

.\"
Этот параметр включается автоматически при настройки маскарадинга или
прозрачного проксирования.
.TP 
\fIip_autoconfig\fP (в Linux 2.2 по 2.6.17)
.\" Precisely: since 2.1.68
.\" FIXME document ip_autoconfig
.\"
Не описан.
.TP 
\fIip_default_ttl\fP (integer; по умолчанию: 64; начиная с Linux 2.2)
.\" Precisely: 2.1.15
.\"
Устанавливает значение time\-to\-live по умолчанию для исходящих пакетов. Это
значение может быть изменено для каждого отдельного сокета с помощью
параметра \fBIP_TTL\fP.
.TP 
\fIip_dynaddr\fP (Boolean; по умолчанию: выключен; начиная с Linux 2.0.31)
.\"
Включает динамическую адресацию сокета и подмену (masquerading) при
изменении адреса интерфейса. Это полезно для интерфейсов коммутируемых
соединений (dialup) с изменяющимися IP\-адресами. Значение 0 означает не
подменять, 1 включает подмену и 2 включает режим подробностей работы.
.TP 
\fIip_forward\fP (Boolean; по умолчанию: выключен; начиная с Linux 1.2)
.\"
Включает/выключает пересылку (forwarding) IP\-пакетов. Пересылка IP также
может быть включена для каждого интерфейса в отдельности.
.TP 
\fIip_local_port_range\fP (начиная с Linux 2.2)
.\" Precisely: since 2.1.68
.\"
Содержит два целых числа, определяющих диапазон локальных портов по
умолчанию, которые зарезервированы для сокетов. Резервирование начинается с
первого числа и оканчивается вторым. Заметим, что эти порты не должны
конфликтовать с портами, которые используются для маскарадинга (хотя это
тоже обрабатывается). Кроме того, произвольный выбор диапазона может
привести к проблемам с некоторыми фильтрами пакетов на межсетевом экране,
которые делают предположение об используемых локальных портах. Первое число
должно быть, по крайней мере больше 1024, а лучше более 4096, чтобы избежать
конфликтов с известными портами и минимизировать проблемы с межсетевыми
экранами.
.TP 
\fIip_no_pmtu_disc\fP (Boolean; по умолчанию: выключен; начиная с Linux 2.2)
.\" Precisely: 2.1.15
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
Если включен, то, по умолчанию, не производится обнаружение значения MTU у
маршрута для TCP сокетов. Обнаружение MTU маршрута может завершиться с
ошибкой из\-за встретившихся на пути неверно настроенных межсетевых экранов
(которые отбрасывают все пакеты ICMP) или из\-за неверно настроенных
интерфейсов (например, соединение точка\-точка, у которого оба конца не
договорились о MTU). Лучше исправить встреченные на пути неисправные
маршрутизаторы, чем глобально отключать обнаружение MTU маршрута, потому что
это отключение приведет к высокой нагрузке на сеть.
.TP 
\fIip_nonlocal_bind\fP (Boolean; по умолчанию: выключен; начиная с Linux 2.4)
.\" Precisely: patch-2.4.0-test10
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
Если установлен, то это позволяет процессам привязываться (\fBbind\fP(2)) к
нелокальным IP\-адресам, что полезно, но может привести к неработоспособности
некоторых приложений.
.TP 
\fIip6frag_time\fP (integer; по умолчанию: 30)
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
Время в секундах, на которое фрагмент IPv6 остаётся в памяти.
.TP 
\fIip6frag_secret_interval\fP (integer; по умолчанию: 600)
Интервал регенерации (в секундах) контрольной суммы секрета (hash secret)
(или время существования контрольной суммы секрета) фрагментов IPv6.
.TP 
\fIipfrag_high_thresh\fP (integer), \fIipfrag_low_thresh\fP (integer)
Если количество фрагментов IP, стоящих в очереди, достигает значения
\fIipfrag_high_thresh\fP, то очередь укорачивается до значения
\fIipfrag_low_thresh\fP. Содержит целое число, означающее количество байт.
.TP 
\fIneigh/*\fP
.\" FIXME Document the conf/*/* interfaces
.\" FIXME Document the route/* interfaces
.\" FIXME document them all
Смотрите в \fBarp\fP(7).
.SS "Вызовы ioctl"
.\" 2006-04-02, mtk
.\" commented out the following because ipchains is obsolete
.\" .PP
.\" The ioctls to configure firewalling are documented in
.\" .BR ipfw (4)
.\" from the
.\" .B ipchains
.\" package.
Все вызовы ioctl, описанные в \fBsocket\fP(7), применимы к \fBip\fP.
.PP
.\" FIXME Add a discussion of multicasting
Вызовы ioctl для настройки общих параметров устройств описаны в
\fBnetdevice\fP(7).
.SH ОШИБКИ
.\" FIXME document all errors.
.\"     We should really fix the kernels to give more uniform
.\"     error returns (ENOMEM vs ENOBUFS, EPERM vs EACCES etc.)
.TP 
\fBEACCES\fP
Пользователь попытался выполнить действие, не имея на это необходимых
полномочий. Примеры таких действий: посылка пакета по широковещательному
адресу без предварительной установки флага \fBSO_BROADCAST\fP; посылка пакета
по \fIзапрещенному\fP маршруту; изменение настроек межсетевого экрана не имея
прав суперпользователя (мандата \fBCAP_NET_ADMIN\fP); связывание сокета с
зарезервированным портом, не имея прав суперпользователя (мандата
\fBCAP_NET_BIND_SERVICE\fP).
.TP 
\fBEADDRINUSE\fP
Попытка связать сокет с уже используемым адресом.
.TP 
\fBEADDRNOTAVAIL\fP
Был запрошен несуществующий интерфейс или запрошенный исходящий адрес не
является локальным.
.TP 
\fBEAGAIN\fP
Действие над неблокирующим сокетом привело бы к его блокировке.
.TP 
\fBEALREADY\fP
Операция соединения на неблокирующем сокете уже находится в процессе
выполнения.
.TP 
\fBECONNABORTED\fP
Соединение закрыто во время \fBaccept\fP(2).
.TP 
\fBEHOSTUNREACH\fP
В таблице маршрутизации нет допустимых записей, соответствующих адресу
назначения. Эта ошибка может возникнуть из\-за ICMP\-сообщения от удалённого
маршрутизатора или из\-за локальной таблицы маршрутизации.
.TP 
\fBEINVAL\fP
Передан недопустимый аргумент. При операциях отправки эта ошибка может
возникнуть из\-за передачи по маршруту \fIчёрная дыра\fP (blackhole).
.TP 
\fBEISCONN\fP
Вызов \fBconnect\fP(2) запущен для сокета, уже установившего соединение.
.TP 
\fBEMSGSIZE\fP
Дейтаграмма больше значения MTU на маршруте, и она не может быть
фрагментирована.
.TP 
\fBENOBUFS\fP, \fBENOMEM\fP
Недостаточно свободной памяти. Часто это означает, что выделение памяти
ограничено не размером системной памяти, а границами буфера сокета, но это
не всегда так.
.TP 
\fBENOENT\fP
\fBSIOCGSTAMP\fP вызван для сокета, который ещё не получил ни одного пакета.
.TP 
\fBENOPKG\fP
Не настроена подсистема ядра.
.TP 
\fBENOPROTOOPT\fP и \fBEOPNOTSUPP\fP
Передана недопустимый параметр сокета.
.TP 
\fBENOTCONN\fP
Операция определена только для сокета, установившего соединение, а этот
сокет не соединён.
.TP 
\fBEPERM\fP
У пользователя нет достаточных полномочий, чтобы повысить приоритет,
изменить настройку или послать сигнал запрашиваемому процессу или группе
процессов.
.TP 
\fBEPIPE\fP
Соединение неожиданно закрылось или завершено (shut down) другой стороной.
.TP 
\fBESOCKTNOSUPPORT\fP
Сокет не настроен или запрошен неизвестный тип сокета.
.PP
Протоколами более высокого уровня могут генерироваться другие ошибки;
смотрите \fBtcp\fP(7), \fBraw\fP(7), \fBudp\fP(7) и \fBsocket\fP(7).
.SH ЗАМЕЧАНИЯ
.\" IP_PASSSEC is Linux-specific
.\" IP_XFRM_POLICY is Linux-specific
.\" IP_IPSEC_POLICY is a nonstandard extension, also present on some BSDs
Значения \fBIP_FREEBIND\fP, \fBIP_MTU\fP, \fBIP_MTU_DISCOVER\fP,
\fBIP_RECVORIGDSTADDR\fP, \fBIP_PKTINFO\fP, \fBIP_RECVERR\fP, \fBIP_ROUTER_ALERT\fP и
\fBIP_TRANSPARENT\fP есть только в Linux.

Будьте осторожны при использовании параметра \fBSO_BROADCAST\fP — в Linux он не
является привилегированным. Если небрежно относиться к широковещательным
сообщениям, то можно легко перегрузить сеть. В новых протоколах для
приложений лучше использовать групповое вещание вместо
широковещательного. Не используйте широковещание.
.PP
Для определения адреса назначения и интерфейса полученных дейтаграмм в
некоторые реализациях BSD сокетов введены параметры сокетов \fBIP_RCVDSTADDR\fP
и \fBIP_RECVIF\fP. В Linux для этой цели есть общий параметр \fBIP_PKTINFO\fP.
.PP
В некоторые реализациях BSD сокетов также есть параметр \fBIP_RECVTTL\fP, но
вспомогательное сообщение с типом \fBIP_RECVTTL\fP передаётся с входным
пакетом. В этом отличие от параметра \fBIP_TTL\fP, используемого в Linux.
.PP
Использование уровня параметров сокета \fBSOL_IP\fP непереносимо — в BSD\-стеках
используется уровень \fBIPPROTO_IP\fP.
.SS Совместимость
Для совместимости с Linux 2.0 устаревший синтаксис \fBsocket(AF_INET,
SOCK_PACKET, \fP\fIprotocol\fP\fB)\fP всё ещё поддерживается для открытия сокетов
типа \fBpacket\fP(7). Такое использование не поощряется и должно быть заменено
на \fBsocket(AF_PACKET, SOCK_RAW, \fP\fIprotocol\fP\fB)\fP. Основное различие между
ними в новой адресной структуре \fIsockaddr_ll\fP (вместо старой структуры
\fBsockaddr_pkt\fP.), хранящей информацию обобщённого уровня соединения,
.SH ДЕФЕКТЫ
Слишком много противоречий в значениях ошибок.
.PP
Не описаны ioctl для настройки специальных параметров IP для интерфейса и
таблиц ARP.
.PP
В некоторых версиях glibc не объявлена структура \fIin_pktinfo\fP. Это можно
обойти, скопировав объявление этой структуры из этой справочной страницы.
.PP
.\" .SH AUTHORS
.\" This man page was written by Andi Kleen.
Получение исходного адреса назначения в \fImsg_name\fP с помощью
\fBMSG_ERRQUEUE\fP вызовом \fBrecvmsg\fP(2) не работает в некоторых ядрах 2.2.
.SH "СМОТРИТЕ ТАКЖЕ"
\fBrecvmsg\fP(2), \fBsendmsg\fP(2), \fBbyteorder\fP(3), \fBipfw\fP(4),
\fBcapabilities\fP(7), \fBnetlink\fP(7), \fBraw\fP(7), \fBsocket\fP(7), \fBtcp\fP(7),
\fBudp\fP(7)
.PP
Первоначальная спецификация IP описана в RFC\ 791.
.br
Требования к узлу IPv4 приведены в RFC\ 1122.
.br
Требования к маршрутизатору IPv4 приведены в RFC\ 1812.
.\" FIXME autobind INADDR REUSEADDR

'\" t
.\" Don't change the line above. it tells man that tbl is needed.
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: ip.7,v 1.13 1999/06/12 10:11:38 freitag Exp $
.\"
.\" Вычитано и скорректировано by Alexey Mahotkin <alexm@hsys.msk.ru>
.\" для проекта http://alexm.here.ru/manpages-ru/
.\"
.TH IP  7 "11 Мая 1999" "Страницы Руководства по Linux" "Руководство программиста Linux" 
.SH НАЗВАНИЕ
ip \- реализация протокола IPv4 под Linux
.SH ОБЗОР
.B #include <sys/socket.h>
.br
.\" .B #include <net/netinet.h> -- больше не существует
.\" .B #include <linux/errqueue.h> -- никогда не включайте <linux/что-то.h>
.B #include <netinet/in.h>
.sp
.IB tcp_socket " = socket(PF_INET, SOCK_STREAM, 0);"
.br 
.IB raw_socket " = socket(PF_INET, SOCK_RAW, " protocol ");"
.br
.IB udp_socket " = socket(PF_INET, SOCK_DGRAM, " protocol ");"
.SH ОПИСАНИЕ 
Linux реализует Internet Protocol (IP) версии 4, описанный в RFC791 и
RFC1122.
.B ip 
включает в себя второй уровень 
реализации групповых сообщений, соответствующий RFC1112.  Кроме того, он содержит
маршрутизатор IP, включающий в себя фильтр пакетов.
.\" XXX: Кто-нибудь проверял, что linux 2.1 действительно подчиняется RFC1812 ?
.PP
Интерфейс программирования совместим с интерфейсом BSD-сокетов.
Более подробную информацию смотри в 
.BR socket (7). 
.PP
IP-сокет создается с помощью вызова функции
.BR socket (2) 
в виде 
.BR "socket(PF_INET, socket_type, protocol)" .
Возможными типами сокета являются 
.BR SOCK_STREAM ,
чтобы открыть сокет 
.BR tcp (7), 
.B SOCK_DGRAM
чтобы открыть сокет 
.BR udp (7),
или
.BR SOCK_RAW ,
чтобы открыть сокет 
.BR raw (7)
для прямого доступа к IP протоколу. 
.IR протокол "\~--"
это IP-протокол, указанный в IP-заголовке, который будет принят или
отослан.  Единственные возможные значения для параметра
.IR протокол "\~--"
это 
.B 0
или
.B IPPROTO_TCP
для TCP сокетов, 
.B 0
или
.B IPPROTO_UDP 
для UDP сокетов.  Для 
.B SOCK_RAW 
можно указать зарегистрированный в IANA IP-протокол, один из тех, что
описаны в RFC1700.
.PP
.\" XXX ip-поток производит автосвязывание в процессе "слушания", но я не
.\" уверен следует ли это описывать.
Если процесс хочет принимать новые входящие пакеты или соединения, то он 
должен связать сокет с адресом локального интерфейса, используя
.BR bind (2).
Только один IP-сокет может быть связан с каждой заданной локальной парой (адрес, порт).
Если при вызове bind указать 
.BR INADDR_ANY , 
то сокет будет связан со
.I всеми
локальными интерфейсами. Если 
.BR listen (2)
или
.BR connect (2)
вызываются для несвязанного сокета, то он будет автоматически привязан
к выбранному наугад свободному порту, а в качестве локального адреса
будет указан
.BR INADDR_ANY .

Адрес локального TCP-сокета, который был связан, будет недоступен в течение некоторого 
времени после его закрытия, если только не был установлен флаг 
.BR SO_REUSEADDR . 
Следует проявлять осторожность при использовании этого флага, поскольку он
делает TCP менее надежным.  

.SH ФОРМАТ АДРЕСА
Адрес IP сокета определяется как комбинация адреса IP интерфейса
и номера порта.  Сам по себе IP протокол не присваивает номера портов, они
реализуются протоколами более высокого уровня, типа 
.BR udp (7)
и
.BR tcp (7).
У сокетов типа raw переменная
.B sin_port
содержит протокол IP.

.PP
.RS
.nf
.ta 4n 19n 31n
struct sockaddr_in {
	sa_family_t	sin_family;	/* семейство адресов: AF_INET */
	u_int16_t	sin_port;	/* порт сокета в сетевом порядке байт */
	struct in_addr  sin_addr;	/* адрес в интернете */
};

/* Адрес в интернете. */
struct in_addr {
	u_int32_t	s_addr;	/* адрес сокета в сетевом порядке байт */
};
.ta
.fi
.RE
.PP
Значение переменной 
.I sin_family 
всегда равно 
.BR AF_INET . 
Это обязательно; в Linux 2.2 большая часть сетевых функций возвращает код ошибки 
.BR EINVAL , 
если это условие не выполняется.
Переменная 
.I sin_port
содержит порт сокета в сетевом порядке байт.
Порты, номера которых меньше 1024, называются
.IR "зарезервированными портами" .
Только процессы с фактическим идентификатором пользователя 0 или со способностью 
.B CAP_NET_BIND_SERVICE 
могут быть связаны с этими сокетами с помощью
.BR bind (2).  
Заметьте, что у чистого протокола IPv4, как такового, нет понятия 
порта, они реализуются только протоколами более высокого уровня, типа
.BR tcp (7)
и
.BR udp (7).
.PP
Значением переменной
.I sin_addr 
является адрес IP-хоста.
Переменная 
.IR addr , 
являющаяся членом структуры 
.BR "struct in_addr" , 
содержит адрес сокета в сетевом формате. 
Работать со структурой 
.B in_addr 
следует только посредством библиотечных функций
.BR inet_aton (3),
.BR inet_addr (3),
.BR inet_makeaddr (3)
или напрямую с помощью преобразователя имен (смотри
.BR gethostbyname (3)).
Адреса IPv4 делятся на одиночные, широковещательные 
и групповые. Каждый одиночный адрес указывает на один интерфейс хоста,
широковещательные адреса указывают на все хосты в сети, а групповые адреса 
соответствуют всем хостам в группе. Датаграммы могут посылаться по 
широковещательным адресам только если установлен флаг 
.BR SO_BROADCAST . 
В текущей реализации сокетам, ориентированным на соединения, 
разрешено иметь только одиночные адреса.
.\" Оставлена лазейка для XTP @)

Заметьте, что значения адреса и порта всегда хранятся в сетевом формате.
В частности, это означает, что требуется вызывать
.BR htons (3) 
для числа, обозначающего порт.  Все функции из стандартной библиотеки, 
манипулирующие с адресами/портами, работают с сетевым форматом.

Есть несколько специальных адресов: 
.B INADDR_LOOPBACK
(127.0.0.1)
всегда приписывается локальному хосту через закольцовывающий интерфейс;
.B INADDR_ANY 
(0.0.0.0)
означает любой адрес для связывания;
.B INADDR_BROADCAST
(255.255.255.255)
означает любой хост и по историческим причинам при связывании создает
тот же эффект, что и
.BR INADDR_ANY .

.SH ОПЦИИ СОКЕТА

IP поддерживает некоторые опции сокета, относящиеся к протоколу,
которые могут быть установлены с помощью
.BR setsockopt (2),
и прочитаны с помощью
.BR getsockopt (2).
Параметр "уровень опции сокета" этих функций равен
.BR SOL_IP .
Двоичный флаг со значением нуль означает "ложь", другие значения --
"истина".

.TP
.B IP_OPTIONS
Устанавливает или возвращает те опции IP, которые посылаются с каждым пакетом из данного
сокета.  Аргументами являются указатель на область памяти, содержащую эти опции, 
и размер опции.
Системный вызов
.BR setsockopt (2)
устанавливает опции IP, связанные с сокетом.
Для IPv4 максимальный размер этой опции равен 40 байтам.  Все возможные опции 
перечислены в RFC791. Если запрос, устанавливающий соединение с сокетом типа
.BR SOCK_STREAM , 
содержит опции IP, то такие же IP-опции (с инвертированными
заголовками маршрутизации) будут использоваться в этом сокете.
Входящие пакеты не могут изменять опции после того, как соединение
установлено.
По умолчанию обработка всех опций, связанных с маршрутизацией по отправителю,
отключена, но ее можно включить, используя sysctl-значение 
.BR accept_source_route . 
Другие опции, например связанные с временными отметками, продолжают обрабатываться.
Для датаграммных сокетов опции IP могут быть установлены только локальным 
пользователем. В результате вызова
.BR getsockopt (2)
с  параметром
.I IP_OPTIONS
текущие опции IP, используемые при отправки пакетов, будут помещены 
в указанный буфер.

.TP
.B IP_PKTINFO
Передает служебное сообщение
.IR IP_PKTINFO , 
содержащее структуру
.BR pktinfo , 
которая содержит некоторую информацию о входящем пакете. Эта опция 
используется только для сокетов, ориентированных на посылку датаграмм.
Аргумент является флагом, который сообщает сокету, нужно ли посылать
сообщение IP_PKTINFO или нет.  Само сообщение может быть
послано/получено только в виде контрольного сообщения с пакетом,
используя
.BR recvmsg (2)
или
.BR sendmsg (2).

.IP
.RS
.ta 4n 19n 33n
.nf
struct in_pktinfo {
	unsigned int	ipi_ifindex; 	/* указатель на интерфейс */
	struct in_addr	ipi_spec_dst;	/* локальный адрес */
	struct in_addr	ipi_addr;	/* адрес назначения из заголовка */
};
.fi
.RE
.IP
.\" XXX над этим надо поработать.
.B ipi_ifindex
это уникальный указатель на интерфейс, от которого был получен этот пакет.
.B ipi_spec_dst
это локальный адрес пакета, а
.B ipi_addr
это адрес назначения, указанный в заголовке пакета.
Если опция
.I IP_PKTINFO 
передана
.BR sendmsg (2), 
то исходящий пакет будет послан через интерфейс,
указанный в
.BR ipi_ifindex ,
по адресу из
.BR ipi_spec_dst .

.TP
.B IP_RECVTOS
Если включена, то вместе с исходящими пакетами передается 
вспомогательное сообщение 
.IR IP_TOS . 
Оно содержит байт, который определяет поле Тип Сервиса/Приоритет 
в заголовке пакета.  Ожидается логический целочисленный флаг.

.TP
.B IP_RECVTTL
Если этот флаг установлен, то в поле Время Жизни (time to live) получаемого пакета, 
как байт, передается управляющее сообщение 
.IR IP_RECVTTL . 
Не поддерживается сокетами типа
.BR SOCK_STREAM .

.TP
.B IP_RECVOPTS
Передает пользователю все входящие опции IP, с помощью управляющего сообщения
.IR IP_OPTIONS . 
Заголовок маршрутизации и другие опции уже установлены для 
локального хоста. Не поддерживается сокетами типа
.IR SOCK_STREAM .

.TP
.B IP_RETOPTS
Идентична опции 
.IR IP_RECVOPTS , 
но возвращает необработанные опции, причем временные отметки и записи
о маршрутизации для этого хопа еще не заполнены.

.TP
.B IP_TOS
Устанавливает или получает значение поля Тип-Сервиса (Type-Of-Service (TOS)), 
которое посылается с каждым IP-пакетом, который отсылается с этого
сокета.  Это поле
используется, чтобы задавать сетевые приоритеты пакетов.  TOS хранится 
в одном байте. 
Существует несколько стандартных значений флага TOS:
.BR IPTOS_LOWDELAY ,
чтобы минимизировать задержки для передаваемого трафика,
.BR IPTOS_THROUGHPUT ,
чтобы улучшить пропускную способность,
.BR IPTOS_RELIABILITY ,
чтобы увеличить надежность,
.BR IPTOS_MINCOST ,
следует использовать для "необязательных данных", которые можно
пересылать на минимальной скорости.  Может быть указано не более
одного из этих значений TOS.
Все другие биты являются недействительными и должны быть обнулены.
По умолчанию Linux посылает датаграммы 
.B IPTOS_LOWDELAY 
первыми, но точное поведение зависит от сконфигурированного порядка
очередности. 
.\" XXX над этим надо поработать. 
Для установки некоторых высокоприоритетных типов сервиса фактический
идентификатор
пользователя должен быть равен 0, или же у процесса должна быть способность
.BR CAP_NET_ADMIN .
Приоритеты также можно расставить не зависящим от типа протокола способом, 
через опции сокета (
.BR SOL_SOCKET ", " SO_PRIORITY )
(см.
.BR socket (7)).

.TP  
.B IP_TTL
Устанавливает или получает текущее значение поля Время Жизни (time to live),
которое указывается в каждом пакете, который отсылается с этого сокета. 

.TP
.B IP_HDRINCL
Включение этого флага означает, что пользователь уже добавил заголовок
IP в начало своих данных.  Применяется только в сокетах
типа 
.BR SOCK_RAW .
Более подробную информацию см. в 
.BR raw (7). 
Если этот флаг включен, то значения, установленные опциями 
.IR IP_OPTIONS ,
.I IP_TTL
и 
.IR IP_TOS ,
игнорируются.

.TP
.BR IP_RECVERR " (объявлено в <linux/errqueue.h>)"
Включает более надежную передачу сообщений об ошибках. 
Если эта опция включена для датаграмного сокета, то все появляющиеся
ошибки будут поставлены в очередь ошибок, свою для каждого сокета.
Если при работе сокета возникает ошибка,
то пользователь может получить ее путем вызова 
.BR recvmsg (2) 
с установленным флагом 
.BR MSG_ERRQUEUE .
Структура 
.BR sock_extended_err ,
описывающая ошибку, будет передана в служебном сообщении типа 
.I IP_RECVERR 
через 
.BR SOL_IP . 
Эта опция полезна для надежной обработки ошибок на еще не соединенных
сокетах.  Порция данных, получаемая из очереди ошибок,
содержит пакет с описанием ошибки. 
.IP
Контрольное сообщение
.I IP_RECVERR
содержит структуру
.BR sock_extended_err :
.IP
.RS+.ne 18
.nf
.ta 4n 20n 32n
#define SO_EE_ORIGIN_NONE      0
#define SO_EE_ORIGIN_LOCAL     1
#define SO_EE_ORIGIN_ICMP      2
#define SO_EE_ORIGIN_ICMP6     3

struct sock_extended_err {
       u_int32_t       ee_errno;       /* номер ошибки */
       u_int8_t        ee_origin;      /* откуда появилась ошибка */ 
       u_int8_t        ee_type;        /* тип */
       u_int8_t        ee_code;        /* код */
       u_int8_t        ee_pad;
       u_int32_t       ee_info;        /* дополнительная информация */
       u_int32_t       ee_data;        /* другие данные */  
       /* Дальше могу следовать еще данные */ 
};

struct sockaddr *SOCK_EE_OFFENDER(struct sock_extended_err *);
.ta
.fi
.RE
.IP
.B ee_errno
содержит код ошибки, помещенной в очередь.
.BR ee_origin " --"
это код источника ошибки.
Остальные поля специфичны для каждого протокола.  Макрос
.B SOCK_EE_OFFENDER
получает указатель на служебное сообщение и возвращает указатель на
адрес сетевого объекта, от которого пришла ошибка.  Если этот адрес
неизвестен, то поле
.I sa_family
структуры
.B sockaddr
содержит
.BR AF_UNSPEC ,
а остальные ее поля не определены.
.IP
IP использует структуру 
.B sock_extended_err
следующим образом: 
значение поля 
.I ee_origin 
равно 
.B SO_EE_ORIGIN_ICMP 
для ошибок, полученных как ICMP пакет, или
.B SO_EE_ORIGIN_LOCAL 
для локально возникших ошибок.  Неизвестные значения следует
игнорировать.
Значения полей 
.I ee_type 
и 
.I ee_code 
устанавливаются, исходя из значений полей Тип (type) и Код (code), 
содержащихся в заголовке ICMP. Поле 
.I ee_info
содержит обнаруженную величину MTU для ошибок 
.BR EMSGSIZE .
Сообщение также содержит
.I sockaddr_in
узла, вызвавшего ошибку, к этой структуре можно обратиться с помощью
макроса
.BR SOCK_EE_OFFENDER .
Поле
.I sin_family
адреса, возвращенного этим макросом, содержит
.IR AF_UNSPEC ,
если источник неизвестен.
Если ошибка происходит в сети, то все опции IP 
.RI ( IP_OPTIONS ", " IP_TTL ", "
и т.\~д.), которые используются сокетом и содержатся в пакете с описанием ошибки, 
передаются как управляющее сообщение. Данные пакета, вызвавшего ошибку,
возвращаются как нормальные данные.
.IP
.\" XXX: Хорошая ли идея описывать это? Это сомнительная особенность. 
.\" В сокетах типа 
.\" .B SOCK_STREAM , 
.\" у опции 
.\" .I IP_RECVERR 
.\" несколько другая семантика. Вместо того, чтобы
.\" хранить ошибки до следующего тайм-аута, она передает пользователю все 
.\" входящие ошибки немедленно. 
.\" Это полезно для очень коротких TCP соединений, которым требуется 
.\" быстрая обработка ошибок. Будьте осторожны при пользовании этой опцией: 
.\" она делает TCP ненадежным, не позволяя ему восстанавливаться должным 
.\" образом при изменении маршрутизации и при других нормальных 
.\" условиях, и нарушает спецификацию протокола. 
Заметьте, что у TCP нет очереди ошибок; Флаг 
.B MSG_ERRQUEUE
нельзя использовать для сокетов типа 
.BR SOCK_STREAM .
Таким образом, все ошибки можно получить только как значение, возвращаемое 
функцией сокета, или через опцию 
.BR SO_ERROR .
.IP
Для сокетов типа raw, опция 
.I IP_RECVERR 
включает передачу в приложение всех получаемых ошибок ICMP, 
или же, сообщается только об ошибках в сокетах установивших соединение.
.IP
Эта опция устанавливает или возвращает значение ноль или единица. По умолчанию, опция 
.I IP_RECVERR
отключена. 

.TP
.B IP_PMTU_DISCOVER
Устанавливает или возвращает значение опции Path MTU Discovery (Обнаружение MTU Маршрута) 
установленной для сокета. Если она включена, то Linux будет производить обнаружение 
MTU маршрута, как описано в RFC1191
для данного сокета. В противном случае, флаг фрагментации будет устанавливаться у всех
исходящих датаграмм.  Значение по умолчанию для всей системы контролируется
sysctl-значением 
.B ip_no_pmtu_disc 
для сокетов типа 
.BR SOCK_STREAM , 
а для сокетов других типов эта опция отключена. Если тип сокета не 
.BR SOCK_STREAM , 
то ответственность за разбивку данных на пакеты, размер которых соответствует
MTU, и за выполнение, по-необходимости, повторной передачи данных, ложится на 
пользователя. Если этот флаг установлен, то ядро будет отвергать пакеты, 
размер которых больше заданного значения MTU маршрута (оно задается
через опцию
.BR EMSGSIZE ). 

.TS
tab(:);
c l
l l.
Флаги опции:Их значения
Path MTU Discovery:
===================:============
IP_PMTUDISC_WANT:Использовать установки
:маршрутизаторов.
IP_PMTUDISC_DONT:Никогда не производить
:обнаружение MTU маршрута.
IP_PMTUDISC_DO:Всегда производить обнаружение
:MTU маршрута. 
.TE   


Если опция Path MTU Discovery включена, то ядро автоматически следит за MTU 
маршрута для каждого удаленного хоста. 
Если с некоторым узлом устанавливается соединение с помощью 
.BR connect (2), 
то текущее значение MTU маршрута может быть установлено заново используя 
опцию сокета 
.B IP_MTU 
(например, после возникновения ошибки
.BR EMSGSIZE ).
Значение MTU может меняться время от времени. 
Для сокетов без предварительного установления соединения, которые имеют 
несколько хостов-получателей, новое значение MTU для заданного хоста может быть 
получено с помощью очереди ошибок (смотри 
.BR IP_RECVERR ).
При каждом входящем сообщении об обновлении MTU, в очередь будет поставлена 
новая ошибка. 

Во время процесса обнаружения MTU, пакеты, инициализирующие соединение, 
от датаграмных сокетов, могут быть отброшены.  Приложения, использующие UDP, 
должны знать это и не принимать во внимание в своих методах повторной передачи данных.

Чтобы запустить процесс обнаружения MTU маршрута для сокетов, не установивших 
соединение, можно сначала установить большой размер датаграммы 
(с размером заголовка до 64K) и позволить обновлениям MTU маршрута сократить его.
.\" XXX это безобразный хак

Чтобы получить начальную оценку MTU маршрута, установите соединение между 
датаграммным сокетом и адресом назначения, используя 
.BR connect (2)
и узнайте значение MTU путем вызова
.BR getsockopt (2)
с опцией
.BR IP_MTU .

.TP
.B IP_MTU
Возвращает используемое в данный момент значение MTU маршрута текущего сокета. 
Эта опция используется только если сокет установил соединение. Возвращает целое
число. Значение этой опции можно получить только 
через 
.BR getsockopt (2). 
.\"
.TP
.B IP_ROUTER_ALERT
Передает этому сокету все пакеты, которые пересылаются с опцией 
IP Router Alert. 
Эта опция используется только в сокетах типа raw. Она может быть полезна, например, 
для демонов RSVP, запущенных на пользовательском уровне. Перехваченные пакеты не 
пересылаются ядром: ответственность за их повторную отсылку лежит на пользователе.
Связывание сокета игнорируется, такие пакеты фильтруются только протоколом.
В качестве аргумента использует целочисленный флаг. 
.\"
.TP
.B IP_MULTICAST_TTL
Устанавливает или возвращает значение time-to-live для исходящих из этого 
сокета пакетов, использующих групповую адресацию. Для подобных пакетов 
очень важно установить наименьшее возможное значение TTL. 
По умолчанию оно равно 1, это значит, что эти пакеты не выйдут за пределы локальной 
сети, если только пользовательская программа явно не попросит этого. Значением 
аргумента является целое число.
.\"
.TP
.B IP_MULTICAST_LOOP
Устанавливает или возвращает значение ноль или единица, в зависимости от того,
будут ли пакеты, использующие групповую адресацию, закольцовываться на 
локальные сокеты.
.\"
.TP
.B IP_ADD_MEMBERSHIP
Присоединяет к группе для группового вызова. Аргументом является структура 
.BR struct ip_mreqn . 
.PP
.RS
.nf
.ta 4n 19n 34n
struct ip_mreqn {
	struct in_addr	imr_multiaddr;	/* IP адрес группы для группового вызова */
	struct in_addr	imr_address;	/* IP адрес локального интерфейса */
	int	imr_ifindex;	/* указатель на интерфейс */
};
.fi
.RE
.IP
.I imr_multiaddr
содержит адрес группы для группового вызова, к которой приложение хочет присоединиться 
или покинуть. 
Значением должен быть допустимый адрес группового вызова. 
.I imr_address
это адрес локального интерфейса через который система присоединяется к группе 
группового вызова; если он равен 
.BR INADDR_ANY ,
то соответствующий интерфейс выбирается системой.
.I imr_ifindex
это либо указатель на интерфейс, который должен быть добавлен/удален из группы 
.IR imr_multiaddr , 
либо 0, что означает любой интерфейс. 
.IP
Для совместимости, старая структура 
.B ip_mreq 
все еще поддерживается. Она отличается от структуры 
.B ip_mreqn 
только отсутствием поля 
.IR imr_ifindex . 
Эта опция используется только через 
.BR setsockopt (2).
.\"
.TP
.B IP_DROP_MEMBERSHIP
Удаляет из группы для группового вызова. Аргументом является структура 
.B ip_mreqn 
или 
.B ip_mreq , 
подобно опции
.IR IP_ADD_MEMBERSHIP . 
.\"
.TP
.B IP_MULTICAST_IF
Устанавливает локальное устройство как сокет группового вызова. 
Аргументом является структура 
.B ip_mreqn 
или 
.B ip_mreq 
подобно опции 
.IR IP_ADD_MEMBERSHIP .
.IP
Если сокету передается неправильная опция, то возвращается ошибка 
.B ENOPROTOOPT . 
.SH SYSCTL-ЗНАЧЕНИЯ
IP протокол 
поддерживает интерфейс sysctl для конфигурирования некоторых глобальных опций. 
К sysctl-значениям можно получить доступ путем чтения или записи в файлы
.B /proc/sys/net/ipv4/* 
или через использование интерфейса 
.BR sysctl (2) .  
.\"
.TP
.B ip_default_ttl 
Устанавливает значение по умолчанию для величины time-to-live исходящих пакетов. 
Это значение может быть изменено для каждого отдельного сокета с помощью опции 
.IR IP_TTL . 
.\"
.TP
.B ip_forward
Включает/отключает перенаправление IP-пакетов в зависимости от
значения флага.  Перенаправление IP также может быть установлено для
каждого интерфейса в отдельности.
.\"
.TP
.B ip_dynaddr
Включает динамическую адресацию сокета и маскарадинг подмены входного адреса при 
изменении адреса интерфейса. Это полезно для коммутируемого интерфейса с 
изменяющимся IP адресом.
0 означает не подменять, 1 включает подмену и 2 включает многословный режим.
.\"
.TP
.B ip_autoconfig
Не описан.
.\"
.TP
.B ip_local_port_range
Содержит два целых числа, которые определяют диапазон локальных портов, которые по 
умолчанию зарезервированы для сокетов. Резервирование ведется с первого числа и 
оканчивается на втором. 
Заметьте, что эти порты не должны конфликтовать с портами, которые используются 
для маскарадинга (хотя такой случай специально обрабатывается). Кроме того, произвольный 
выбор диапазона может привести к проблемам с некоторыми фильтрами пакетов файервол, 
которые делают предположение об используемых локальных портах. 
Первое число должно быть, по крайней мере >1024, а лучше >4096, чтобы избежать 
конфликтов с известными портами и минимизировать проблемы с файерволами.
.\"
.TP
.B ip_no_pmtu_disc
Если включено, то, по умолчанию, не производится обнаружение MTU маршрута для TCP 
сокетов. Обнаружение MTU маршрута может потерпеть неудачу из-за встретившихся на 
пути неверно сконфигурированных файерволов (которые отбрасывают все ICMP пакеты) 
или из-за неверно сконфигурированного интерфейса (например, соединение точка-точка, 
у которого оба конца не установили MTU). Лучше исправить встреченные на пути 
неисправные маршрутизаторы, чем глобально отключать обнаружение MTU маршрута, 
потому что это отключение приведет к высокой нагрузке на сеть. 
.\"
.TP
.B ipfrag_high_thresh, ipfrag_low_thresh 
Если количество фрагментов IP, стоящих в очереди, достигает значения 
.BR ipfrag_high_thresh ,
то очередь 
укорачивается до значения 
.BR ipfrag_low_thresh .
Содержит целое число, означающее количество 
байт.
.TP
.B ip_always_defrag
[Появилось начиная с ядра 2.2.13; в ранних версиях ядра эта
возможность контролировалась во время компиляции с помощью флага
.BR CONFIG_IP_ALWAYS_DEFRAG ].

Если этот флаг включен (его значение не равно 0), то входящие фрагменты
(части IP пакетов, 
которые образуются, если некоторый хост, находящийся между отправителем и 
адресатом, решает, что пакеты слишком велики и разделяет их на кусочки)
будут снова собраны (дефрагментированы) перед дальнейшей обработкой, даже
если они должны быть пересланы дальше. 

Включайте эту опцию только на файерволе, который является единственной связью
с вашей сетью или на прозрачном прокси-сервере; никогда не включайте ее на 
нормальном маршрутизаторе или хосте. В противном случае, соединение может быть нарушено
если фрагменты передаются по различным линиям. Дефрагментация 
также требует много памяти и процессорного времени.

Эта опция включается автоматически, если конфигурируется маскарадинг 
или прозрачный прокси-сервер.
.TP
.B neigh/*
Смотри 
.BR arp (7). 
.\" XXX Описать sysctl-значения conf/*/* 
.\" XXX Описать sysctl-значения route/* 
.\" XXX Описать их все
.SH IOCTLS
Все ioctls, описанные в 
.BR socket (7),
применимы к ip.
.PP 
Ioctls для конфигурирования файерволов, описаны в
.BR ipfw (7)
из пакета 
.BR ipchains .
.PP
Ioctls для конфигурирования характерных параметров устройств, описаны в 
.BR netdevice (7).  
.\" XXX Добавить главу о групповом вызове
.SH ЗАМЕЧАНИЯ
Будьте осторожны при использовании опции 
.B SO_BROADCAST
\- она не является привилегированной в Linux. Если небрежно относиться к 
широковещательным сообщениям, то можно легко перегрузить сеть.
В новых протоколах для приложений лучше использовать групповой вызов
вместо широковещательных сообщений. Широковещательные сообщения сейчас 
используются реже. 
.PP
Некоторые другие реализации BSD сокетов предоставляют опции сокета 
.I IP_RCVDSTADDR 
и 
.IR IP_RECVIF ,
чтобы узнать адрес назначения и интерфейс полученных датаграмм. 
У Linux есть опция более общего назначения 
.I IP_PKTINFO
для выполнения той же задачи. 
.PP
.SH КОДЫ ОШИБОК
.\" XXX описать все ошибки. Нам действительно надо подправить ядро, чтобы сделать 
.\"     коды ошибок более единообразными (ENOMEM вместо ENOBUFS, EPERM вместо EACCES 
.\"     и т.д.)  
.TP
.B ENOTCONN
Действие должно выполняться только над сокетом, установившем соединение, а этот 
сокет соединение не установил.
.TP
.B EINVAL
Передан недопустимый аргумент. 
При передаче пакета эта ошибка может возникнуть из-за передачи на маршрутизатор типа 
.IR "черная дыра" . 
.TP
.B EMSGSIZE 
Датаграмма больше, чем MTU на данном маршруте, и она не может быть фрагментирована.
.TP
.B EACCES
Пользователь попытался выполнить действие, не имея на это необходимых
полномочий.  Примеры таких действий:
посылка широковещательного сообщения без предварительной установки флага
.B SO_BROADCAST ;
посылка пакета через 
.I запрещенный 
маршрут;
изменение настроек файервола, не имея возможности
.BR CAP_NET_ADMIN ,
или нулевого фактического идентификатора пользователя;
связывание сокета с зарезервированным портом, не имея возможности
.BR CAP_NET_BIND_SERVICE ,
или нулевого фактического идентификатора пользователя.

.TP
.B EADDRINUSE
Попытка связать сокет с уже используемым адресом.
.TP
.BR ENOPROTOOPT " и " EOPNOTSUPP
Передана недопустимая опция. 
.TP
.B EPERM
У пользователя нет достаточных полномочий, чтобы повысить приоритет, изменить 
конфигурацию или послать сигнал запрашиваемому процессу или группе 
процессов. 
.TP
.B EADDRNOTAVAIL
Был запрошен несуществующий интерфейс или запрошенный исходящий адрес не является
локальным.
.TP
.B EAGAIN
Действие над неблокирующим сокетом привело бы к его блокировке.
.TP
.B ESOCKTNOSUPPORT
Сокет не сконфигурирован или запрошен неизвестный тип сокета.
.TP
.B EISCONN
Функция
.BR connect (2)
вызвана для сокета, уже установившего соединение.
.TP
.B EALREADY
Операция соединения на неблокируемом сокете уже находится в процессе
выполнения.
.TP
.B ECONNABORTED
Соединение закрыто во время 
.BR accept (2). 
.TP
.B EPIPE
Соединение неожиданно закрылось или завершено другой стороной.
.TP
.B ENOENT
.B SIOCGSTAMP 
вызван для сокета, который еще не получил ни одного пакета. 
.TP
.B EHOSTUNREACH
В таблице маршрутизации нет разрешенных записей, соответствующих
адресу назначения.  Эта ошибка может возникнуть из-за ICMP-сообщения от 
удаленного маршрутизатора или из-за локальной таблицы маршрутизации. 
.TP
.B ENODEV 
Сетевое устройство недоступно или неспособно посылать IP пакеты.
.TP
.B ENOPKG 
IP-подсистема ядра не сконфигурирована.
.TP
.B ENOBUFS, ENOMEM
Недостаточно свободной памяти.
Часто это означает, что распределение памяти ограничивается не размером системной
памяти, а границами буфера сокета, но это не всегда так.
.PP
Протоколами более высокого уровня могут генерироваться другие ошибки; смотри
.BR tcp (7),
.BR raw (7),
.BR udp (7)
и
.BR socket (7).
.SH ВЕРСИИ
Опции
.IR IP_PKTINFO , 
.IR IP_MTU , 
.IR IP_PMTU_DISCOVER , 
.IR IP_PKTINFO , 
.IR IP_RECVERR
и
.IR IP_ROUTER_ALERT
являются новыми в Linux 2.2.
Более того, они специфичны для Linux и поэтому их не следует
использовать в переносимых программах.
.PP
Структура
.B ip_mreqn 
появилась в Linux 2.2.  Linux 2.0 поддерживал только структуру 
.BR ip_mreq .
.PP
Sysctl-значения были введены в Linux 2.2. 
.SH СОВМЕСТИМОСТЬ
Для совместимости с Linux 2.0, устаревший синтаксис
.BI "socket(PF_INET, SOCK_RAW, "protocol ")"
все еще поддерживается, чтобы создавать сокеты типа 
.BR packet (7). 
Такое использование не поощряется и должно быть заменено на
.BI "socket(PF_PACKET, SOCK_RAW, "protocol ")"
Основная разница между ними в новой структуре 
.BR sockaddr_ll ,
хранящей информацию обобщенного уровня соединения, вместо старой
структуры
.BR sockaddr_pkt .
.SH ОШИБКИ РЕАЛИЗАЦИИ
Слишком много противоречивых значений ошибок. 
.PP
Не описаны ioctls для конфигурирования специфичных для IP опций интерфейса 
и таблиц ARP.
.PP
Некоторые версии glibc забывали объявить
.IR in_pktinfo .
Обойти это можно, скопировав объявление этой структуры из этой
страницы руководства.
.PP
Получение исходного адреса назначения в
.I msg_name
с помощью
.B MSG_ERRQUEUE
функцией
.BR recvmsg (2)
не работает в некоторых ядрах 2.2.
.SH АВТОРЫ
Эту страницу руководства написал Andi Kleen. 
.SH СМОТРИ ТАКЖЕ 
.BR sendmsg (2),
.BR recvmsg (2),
.BR socket (7),
.BR netlink (7),
.BR tcp (7),
.BR udp (7),
.BR raw (7),
.BR ipfw (7).
.PP
RFC791, где описана изначальная спецификация IP.
.br
RFC1122, где описаны требования к хосту для IPv4.
.br
RFC1812, где описаны требования к маршрутизатору для IPv4.
.SH ПЕРЕВОД
Copyright (C) 2000 Антон Аюпов <astray@yandex.ru>
\"  Loc alWords:  XXX автосвязывание INADDR REUSEADDR

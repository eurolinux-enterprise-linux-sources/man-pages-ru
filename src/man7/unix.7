.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\"
.\" Modified, 2003-12-02, Michael Kerrisk, <mtk.manpages@gmail.com>
.\" Modified, 2003-09-23, Adam Langley
.\" Modified, 2004-05-27, Michael Kerrisk, <mtk.manpages@gmail.com>
.\"	Added SOCK_SEQPACKET
.\" 2008-05-27, mtk, Provide a clear description of the three types of
.\"     address that can appear in the sockaddr_un structure: pathname,
.\"     unnamed, and abstract.
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH UNIX 7 2012\-05\-10 Linux "Руководство программиста Linux"
.SH ИМЯ
unix \- сокеты для локального межпроцессного взаимодействия
.SH ОБЗОР
\fB#include <sys/socket.h>\fP
.br
\fB#include <sys/un.h>\fP

\fIunix_socket\fP\fB = socket(AF_UNIX, type, 0);\fP
.br
\fIerror\fP\fB = socketpair(AF_UNIX, type, 0, int *\fP\fIsv\fP\fB);\fP
.SH ОПИСАНИЕ
Семейство сокетов \fBAF_UNIX\fP (также известное, как \fBAF_LOCAL\fP) используется
для эффективного взаимодействия между процессами на одной машине. Доменные
сокеты UNIX могут быть как безымянными, так и иметь имя файла в файловой
системе (типизированный сокет). В Linux также поддерживается абстрактное
пространство имён, которое не зависит от файловой системы.

Допустимые типы: потоковый сокет \fBSOCK_STREAM\fP и датаграмный сокет
\fBSOCK_DGRAM\fP, сохраняющий границы сообщений (в большинстве реализаций UNIX,
доменные датаграмные сокеты UNIX всегда надёжны и не меняют порядок
датаграмм); и (начиная с Linux 2.6.4)  ориентированный на соединение сокет
\fBSOCK_SEQPACKET\fP, сохраняющий границы сообщений и доставляющий сообщения в
том же порядке, в каком они были отправлены.

Доменные сокеты UNIX поддерживают передачу файловых дескрипторов или
информацию (credentials) о процессе другим процессам, используя
вспомогательные (ancillary) данные.
.SS "Формат адреса"
Адрес доменного сокета UNIX представляет собой следующую структуру:
.in +4n
.nf

#define UNIX_PATH_MAX    108

struct sockaddr_un {
    sa_family_t sun_family;               /* AF_UNIX */
    char        sun_path[UNIX_PATH_MAX];  /* имя пути */
};
.fi
.in
.PP
\fIsun_family\fP всегда содержит \fBAF_UNIX\fP.

В этой структуре различают три типа адресов:
.IP * 3
\fIс именем пути\fP: доменный сокет UNIX может быть привязан к имени пути (с
завершающимся null) в файловой системе с помощью \fBbind\fP(2). При возврате
адреса сокета с помощью \fBgetsockname\fP(2), \fBgetpeername\fP(2) и \fBaccept\fP(2),
его длина равна \fIoffsetof(struct sockaddr_un, sun_path) + strlen(sun_path)
+ 1\fP, а в \fIsun_path\fP содержится имя пути с завершающимся null.
.IP *
.\" There is quite some variation across implementations: FreeBSD
.\" says the length is 16 bytes, HP-UX 11 says it's zero bytes.
\fIбезымянный\fP: Потоковый сокет, который не привязан к имени пути с помощью
\fBbind\fP(2), не имеет имени. Аналогично, два сокета, создаваемые
\fBsocketpair\fP(2), также не имеют имён.  При возврате адреса сокета с помощью
\fBgetsockname\fP(2), \fBgetpeername\fP(2) и \fBaccept\fP(2), его длина равна
\fIsizeof(sa_family_t)\fP, а значение \fIsun_path\fP не используется.
.IP *
\fIабстрактный\fP: абстрактный адрес сокета отличается тем, что значением
\fIsun_path[0]\fP является байт null (\(aq\e0\(aq). Адрес сокета в этом
пространстве имён определяется дополнительными байтами в \fIsun_path\fP,
количество которых определяется длиной указанной структуры адреса. Байты
null в имени не имеют специального значения. Имя не связано с именем пути в
файловой системе. При возврате адреса абстрактного сокета с помощью
\fBgetsockname\fP(2), \fBgetpeername\fP(2) и \fBaccept\fP(2), возвращаемое значение
\fIaddrlen\fP больше чем \fIsizeof(sa_family_t)\fP (т.е. больше 2), а имя сокета
содержится в первых \fI(addrlen \- sizeof(sa_family_t))\fP байтах
\fIsun_path\fP. Пространство имён абстрактных сокетов является непереносимым
расширением Linux.
.SS "Параметры сокетов"
В силу исторических причин эти параметры сокетов относятся к типу
\fBSOL_SOCKET\fP, даже если они относятся к \fBAF_UNIX\fP. Они могут быть
установлены с помощью \fBsetsockopt\fP(2) и прочитаны с помощью
\fBgetsockopt\fP(2); тип \fBSOL_SOCKET\fP указывается в качестве семейства сокета.
.TP 
\fBSO_PASSCRED\fP
Разрешает приём информационных данных (credentials) посылающего процесса во
вспомогательном сообщении. Если при включении этого параметра сокет пока ещё
не соединён, то в абстрактном пространстве имён будет автоматически создано
уникальное имя. Ожидается целочисленный логический флаг.
.SS "Свойство автоматической привязки"
.\" i.e. sizeof(short)
Если в вызов \fBbind\fP(2) передано значение \fIaddrlen\fP равное
\fIsizeof(sa_family_t)\fP, или для сокета, который не привязан к адресу явно,
был указан параметр сокета \fBSO_PASSCRED\fP, то сокет автоматически
привязывается к абстрактному адресу. Адрес состоит из байта null и 5 байтов
символов из набора \fI[0\-9a\-f]\fP. Таким образом, максимальное количество
автоматически привязываемых адресов равно 2^20 (в Linux 2.1.15, когда была
добавлена автоматическая привязка, использовалось 8 байт, и, таким образом,
ограничение было 2^32 адресов. В Linux 2.3.15 количество байт сократили до
5).
.SS "Программный интерфейс сокетов"
В следующих параграфах описываются специфичные тонкости доменов и
неподдерживаемые возможности программного интерфейса сокетов для доменных
сокетов UNIX в Linux.

Доменные сокеты UNIX не поддерживают передачу внеполосных данных (флаг
\fBMSG_OOB\fP у \fBsend\fP(2) и \fBrecv\fP(2)).

Флаг \fBMSG_MORE\fP у \fBsend\fP(2) не поддерживается доменными сокетами UNIX.

Использование \fBMSG_TRUNC\fP в аргументе \fIflags\fP у \fBrecv\fP(2) не
поддерживается доменными сокетами UNIX.

Параметр сокета \fBSO_SNDBUF\fP учитывается в доменных сокетах UNIX, а параметр
\fBSO_RCVBUF\fP \(em нет. Для датаграмных сокетов значение \fBSO_SNDBUF\fP
считается максимальным размером для исходящих датаграмм. Это ограничение,
вычисляемое как удвоенное значение (см. \fBsocket\fP(7))  параметра, содержит
меньше 32 байт накладных расходов.
.SS "Вспомогательные сообщения"
Вспомогательные данные отправляются и принимаются с помощью \fBsendmsg\fP(2) и
\fBrecvmsg\fP(2). В силу исторических причин перечисленные типы вспомогательных
сообщений относятся к типу \fBSOL_SOCKET\fP, даже если они относятся к
\fBAF_UNIX\fP. Для того, чтобы отправить их, установите значение поля
\fIcmsg_level\fP структуры \fIcmsghdr\fP равным \fBSOL_SOCKET\fP, а в значении поля
\fIcmsg_type\fP укажите его тип. Дополнительная информация приведена в
\fBcmsg\fP(3).
.TP 
\fBSCM_RIGHTS\fP
Передать или принять набор открытых файловых дескрипторов из другого
процесса. Часть с данными содержит целочисленный массив файловых
дескрипторов. Переданные файловые дескрипторы действуют так, как если бы они
были созданы \fBdup\fP(2).
.TP 
\fBSCM_CREDENTIALS\fP
Передать или принять информацию о UNIX. Может быть использовано для
аутентификации. Информация передаётся в виде структуры \fIstruct ucred\fP
вспомогательного сообщения. Эта структура определена в
\fI<sys/socket.h>\fP следующим образом:

.in +4n
.nf
struct ucred {
    pid_t pid;    /* идентификатор посылающего процеса */
    uid_t uid;    /* идентификатор пользователя посылающего процесса */
    gid_t gid;    /* идентификатор группы посылающего процесса */
};
.fi
.in

Начиная с glibc 2.8, чтобы получить определение данной структуры должен быть
определён макрос тестирования свойств \fB_GNU_SOURCE\fP (до включения
\fIкаких\-либо\fP заголовочных файлов).

Информация (credentials), указываемая отправителем, проверяется
ядром. Процесс с идентификатором эффективного пользователя 0 может указывать
значения, отличные от его собственных. Отправитель должен указать
идентификатор своего процесса (если только он не имеет мандата
\fBCAP_SYS_ADMIN\fP), свой идентификатор пользователя, эффективный
идентификатор или сохранённый set\-user\-ID (если только он не имеет
\fBCAP_SETUID\fP) и идентификатор своей группы, эффективный идентификатор
группы или сохранённый set\-group\-ID (если только он не имеет
\fBCAP_SETGID\fP). Для получения сообщения со структурой \fIstruct ucred\fP для
сокета нужно включить параметр \fBSO_PASSCRED\fP.
.SS "Вызовы ioctl"
Следующие вызовы \fBioctl\fP(2) возвращают информацию в аргументе
\fIvalue\fP. Корректный синтаксис:
.PP
.RS
.nf
\fBint\fP\fI value\fP\fB;\fP
\fIerror\fP\fB = ioctl(\fP\fIunix_socket\fP\fB, \fP\fIioctl_type\fP\fB, &\fP\fIvalue\fP\fB);\fP
.fi
.RE
.PP
Значением \fIioctl_type\fP может быть:
.TP 
\fBSIOCINQ\fP
.\" FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
.\" filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
.\" SIOCOUTQ also has an effect for UNIX domain sockets, but not
.\" quite what userland might expect. It seems to return the number
.\" of bytes allocated for buffers containing pending output.
.\" That number is normally larger than the number of bytes of pending
.\" output. Since this info is, from userland's point of view, imprecise,
.\" and it may well change, probably best not to document this now.
Возвращает количество непрочитанных данных в очереди в приёмном
буфере. Сокет не должен быть в состоянии LISTEN, иначе возвращается ошибка
(\fBEINVAL\fP). Значение \fBSIOCINQ\fP определено в
\fI<linux/sockios.h>\fP. В качестве альтернативы вы можете использовать
синоним \fBFIONREAD\fP, определённый в \fI<sys/ioctl.h>\fP.
.SH ОШИБКИ
.TP 
\fBEADDRINUSE\fP
Заданный локальный адрес уже используется, или сокетный объект файловой
системы уже существует.
.TP 
\fBECONNREFUSED\fP
Удалённый адрес, указанный \fBconnect\fP(2) не является слушающим сокетом. Эта
ошибка также может возникнуть, если имя файла назначения не является
сокетом.
.TP 
\fBECONNRESET\fP
Удалённый сокет был неожиданно закрыт.
.TP 
\fBEFAULT\fP
Некорректный адрес пользовательской памяти.
.TP 
\fBEINVAL\fP
Передан неправильный аргумент. Основная причина \(em не задано значение
\fBAF_UNIX\fP в поле \fIsun_type\fP передаваемых адресов или сокет находится в
некорректном состоянии для производимой операции.
.TP 
\fBEISCONN\fP
Вызов \fBconnect\fP(2) запущен для уже соединённого сокета, или адрес
назначения указывает на соединённый сокет.
.TP 
\fBENOENT\fP
Путь, указанный в удалённом адресе для \fBconnect\fP(2), не существует.
.TP 
\fBENOMEM\fP
Не хватает памяти.
.TP 
\fBENOTCONN\fP
Для операции над сокетом требуется адрес назначения, а сокет не соединён.
.TP 
\fBEOPNOTSUPP\fP
Вызвана потоковая операция для непотокового сокета, или произведена попытка
использования параметра для внеполосных данных.
.TP 
\fBEPERM\fP
Отправитель указал неправильную информацию (credentials) в структуре
\fIstruct ucred\fP.
.TP 
\fBEPIPE\fP
Удалённый сокет был закрыт в потоковом сокете. Если разрешено, также будет
послан сигнал \fBSIGPIPE\fP. Этого можно избежать, передав флаг \fBMSG_NOSIGNAL\fP
при вызове \fBsendmsg\fP(2)  или \fBrecvmsg\fP(2).
.TP 
\fBEPROTONOSUPPORT\fP
Указанный протокол не является \fBAF_UNIX\fP.
.TP 
\fBEPROTOTYPE\fP
Удалённый сокет не совпадает с типом локального сокета (\fBSOCK_DGRAM\fP против
\fBSOCK_STREAM\fP).
.TP 
\fBESOCKTNOSUPPORT\fP
Неизвестный тип сокета.
.PP
При создании сокетного объекта на уровне сокетов или файловой системы могут
генерироваться другие ошибки. За дополнительной информацией обращайтесь к
соответствующей справочной странице.
.SH ВЕРСИИ
\fBSCM_CREDENTIALS\fP и абстрактное пространство имён появились в Linux 2.2 и
не должны использоваться в переносимых программах. Некоторые клоны BSD также
поддерживают передачу дополнительной информации (credential), но методы
реализации передачи могут серьезно отличаться на разных системах.
.SH ЗАМЕЧАНИЯ
В реализации Linux учитываются права доступа к каталогу, в котором находятся
сокеты, видимые в файловой системе. Владелец, группа и права, присвоенные
сокетам, могут быть изменены. Если процесс не имеет прав на запись и поиск
(запуск) в каталоге, то создать новый сокет в нём не удастся. Соединение
сокетных объектов требует права на запись/чтение. Это действие отличается от
действий большинства клонов BSD, игнорирующих права доменных сокетов
UNIX. Переносимые программы не должны полагаться на эту возможность для
обеспечения безопасности.

Привязка сокета к имени файла создаёт сокет в файловой системе, который
должен быть удалён создателем, когда необходимость в нём отпадёт (с помощью
\fBunlink\fP(2)). Обычная система ссылок UNIX также подходит для работы с
сокетами; сокет может быть удалён в любое время, а реальное удаление из
файловой системы будет произведено при закрытии последней на него ссылки.

Для передачи файловых дескрипторов или информации (credentials) через
\fBSOCK_STREAM\fP необходимо передать/принять, по меньшей мере, один байт
недополнительных данных в одном из вызовов: \fBsendmsg\fP(2) или \fBrecvmsg\fP(2).

В потоковых доменных сокетах UNIX отсутствует такое понятие как внеполосные
данные.
.SH ПРИМЕР
См. \fBbind\fP(2).

Пример использования \fBSCM_RIGHTS\fP приведён в \fBcmsg\fP(3).
.SH "СМОТРИТЕ ТАКЖЕ"
\fBrecvmsg\fP(2), \fBsendmsg\fP(2), \fBsocket\fP(2), \fBsocketpair\fP(2), \fBcmsg\fP(3),
\fBcapabilities\fP(7), \fBcredentials\fP(7), \fBsocket\fP(7)
